


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/.mvn/wrapper/MavenWrapperDownloader.java
// ============================================

/*
 * Copyright 2007-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.net.*;
import java.io.*;
import java.nio.channels.*;
import java.util.Properties;

public class MavenWrapperDownloader {

    private static final String WRAPPER_VERSION = "0.5.6";
    /**
     * Default URL to download the maven-wrapper.jar from, if no 'downloadUrl' is provided.
     */
    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/"
        + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";

    /**
     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to
     * use instead of the default one.
     */
    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =
            ".mvn/wrapper/maven-wrapper.properties";

    /**
     * Path where the maven-wrapper.jar will be saved to.
     */
    private static final String MAVEN_WRAPPER_JAR_PATH =
            ".mvn/wrapper/maven-wrapper.jar";

    /**
     * Name of the property which should be used to override the default download url for the wrapper.
     */
    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";

    public static void main(String args[]) {
        System.out.println("- Downloader started");
        File baseDirectory = new File(args[0]);
        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());

        // If the maven-wrapper.properties exists, read it and check if it contains a custom
        // wrapperUrl parameter.
        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
        String url = DEFAULT_DOWNLOAD_URL;
        if(mavenWrapperPropertyFile.exists()) {
            FileInputStream mavenWrapperPropertyFileInputStream = null;
            try {
                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {
                System.out.println("- ERROR loading '" + MAVEN_WRAPPER_PROPERTIES_PATH + "'");
            } finally {
                try {
                    if(mavenWrapperPropertyFileInputStream != null) {
                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }
            }
        }
        System.out.println("- Downloading from: " + url);

        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
        if(!outputFile.getParentFile().exists()) {
            if(!outputFile.getParentFile().mkdirs()) {
                System.out.println(
                        "- ERROR creating output directory '" + outputFile.getParentFile().getAbsolutePath() + "'");
            }
        }
        System.out.println("- Downloading to: " + outputFile.getAbsolutePath());
        try {
            downloadFileFromURL(url, outputFile);
            System.out.println("Done");
            System.exit(0);
        } catch (Throwable e) {
            System.out.println("- Error downloading");
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        if (System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {
            String username = System.getenv("MVNW_USERNAME");
            char[] password = System.getenv("MVNW_PASSWORD").toCharArray();
            Authenticator.setDefault(new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });
        }
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();
    }

}


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/broker/MessageBroker.java
// ============================================

package org.example.broker;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;

import org.example.model.Message;
import org.example.model.MessageType;
import org.example.repository.JsonMessageRepository;
import org.example.server.ClientHandler;

public class MessageBroker {
    private static MessageBroker instance;
    private final Map<String, MessageQueue> userQueues;
    private final JsonMessageRepository messageRepo;

    public static synchronized MessageBroker getInstance() {
        if (instance == null) {
            instance = new MessageBroker();
        }
        return instance;
    }

    private MessageBroker() {
        this.userQueues = new ConcurrentHashMap<>();
        this.messageRepo = new JsonMessageRepository();
        loadPendingMessages();
    }

    // Subscription
    public void registerListener(final String email, final ClientHandler listener) {

        final MessageQueue queue = getOrCreateQueue(email);
        queue.setListener(listener);

        queue.clearQueue();
        queue.reloadPersistedMessages();
        queue.deliverPendingMessages();
    }

    public void unregisterListener(final String email) {
        final MessageQueue queue = userQueues.remove(email);
        if (queue != null) {
            queue.setListener(null);
            queue.clearQueue();
        }
    }

    public void sendMessage(final Message message) {
        // N'initialiser et persister que les messages de type CHAT
        if (message.getType() == MessageType.CHAT) {
            initializeMessage(message);
        }

        // Messages de statut : envoyer à tous les clients concernés
        if (message.getType() == MessageType.STATUS_UPDATE) {
            broadcastStatusUpdate(message);
            return;
        }

        // Message standard à un destinataire
        final MessageQueue queue = userQueues.get(message.getReceiverEmail());
        if (queue != null && queue.tryDeliver(message)) {
            if (message.getType() == MessageType.CHAT) {
                message.setStatus("DELIVERED");
                try {
                    // Mettre à jour le statut du message dans le repository
                    messageRepo.updateMessage(message);
                } catch (IOException e) {
                    System.err.println("Erreur lors de la mise à jour du statut du message: " + e.getMessage());
                }
            }
        } else if (message.getType() == MessageType.CHAT) {
            PersistMessage(message);
        }
    }

    public void sendTypingEvent(final Message message) {
        final MessageQueue queue = userQueues.get(message.getReceiverEmail());
        if (queue != null) {
            queue.tryDeliver(message);
        }
    }

    private void initializeMessage(final Message message) {
        if (message.getId() == null) {
            message.setId(UUID.randomUUID().toString());
        }
        if (message.getTimestamp() == null) {
            message.setTimestamp(LocalDateTime.now());
        }
        message.setStatus("PENDING");
    }

    private void PersistMessage(final Message message) {
        message.setStatus("QUEUED");
        try {
            messageRepo.saveMessage(message);
            // getOrCreateQueue(message.getReceiverEmail()).addMessageToQueue(message);
        } catch (final IOException e) {
            System.err.println("Failed to queue message: " + e.getMessage());
        }
    }

    private void broadcastStatusUpdate(Message statusMessage) {
        String senderEmail = statusMessage.getSenderEmail();
        boolean isOnline = Boolean.parseBoolean(statusMessage.getContent());
        
        // Trouver tous les utilisateurs qui ont senderEmail comme contact
        userQueues.forEach((userEmail, queue) -> {
            try {
                if (!userEmail.equals(senderEmail)) {
                    // Pour chaque utilisateur connecté, notifier du changement de statut
                    if (queue.hasListener()) {
                        Message notif = new Message();
                        notif.setType(MessageType.STATUS_UPDATE);
                        notif.setSenderEmail(senderEmail);
                        notif.setContent(statusMessage.getContent());
                        queue.tryDeliver(notif);
                    }
                }
            } catch (Exception e) {
                System.err.println("Erreur lors de la diffusion du statut: " + e.getMessage());
            }
        });
        
        System.out.println("Statut " + (isOnline ? "en ligne" : "hors ligne") + " de " + senderEmail + " diffusé à tous les contacts");
    }

    private MessageQueue getOrCreateQueue(final String email) {
        return userQueues.computeIfAbsent(email, MessageQueue::new);
    }

    private void loadPendingMessages() {
        try {
            messageRepo.loadMessages().stream()
                    .filter(m -> "QUEUED".equals(m.getStatus()))
                    .forEach(m -> getOrCreateQueue(m.getReceiverEmail()).addMessageToQueue(m));
        } catch (final IOException e) {
            System.err.println("Error loading pending messages: " + e.getMessage());
        }
    }

    /**
     * Vérifie si un client est actuellement connecté au broker
     * @param email Email de l'utilisateur à vérifier
     * @return true si l'utilisateur a une connexion active, false sinon
     */
    public boolean hasActiveClient(final String email) {
        MessageQueue queue = userQueues.get(email);
        return queue != null && queue.hasListener();
    }

    private class MessageQueue {
        private final String userEmail;
        private final BlockingQueue<Message> messages;
        private ClientHandler listener;

        MessageQueue(final String userEmail) {
            this.userEmail = userEmail;
            this.messages = new LinkedBlockingQueue<>();
        }

        synchronized void setListener(final ClientHandler listener) {
            this.listener = listener;
        }

        void addMessageToQueue(final Message message) {
            messages.offer(message);
        }

        synchronized void clearQueue() {
            messages.clear();
        }

        synchronized void reloadPersistedMessages() {
            try {
                messageRepo.loadMessages().stream()
                        .filter(m -> "QUEUED".equals(m.getStatus()) &&
                                userEmail.equals(m.getReceiverEmail()))
                        .forEach(this::addMessageToQueue);
            } catch (final IOException e) {
                System.err.println("Error reloading persisted messages for " + userEmail + ": " + e.getMessage());
            }
        }

        boolean tryDeliver(final Message message) {
            if (listener != null) {
                try {
                    listener.onMessageReceived(message);
                    return true;
                } catch (final IOException e) {
                    System.err.println("Delivery failed for " + message.getId());
                }
            }
            return false;
        }

        void deliverPendingMessages() {
            while (!messages.isEmpty()) {
                final Message message = messages.peek();
                if (tryDeliver(message)) {
                    try {
                        messages.poll();
                    } catch (final Exception e) {
                        System.err.println("Delivery failed, keeping message in queue");
                        break;
                    }
                } else {
                    break;
                }
            }
        }

        boolean hasListener() {
            return listener != null;
        }
    }
}

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/client/gui/ChatClientApplication.java
// ============================================

package org.example.client.gui;

import java.io.IOException;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.stage.Stage;

public class ChatClientApplication extends Application {

    @Override
    public void start(final Stage primaryStage) {
        try {
            // Vérification que les ressources FXML peuvent être chargées
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            final Parent root = loader.load();
            
            primaryStage.setTitle("Chat Application");
            primaryStage.setScene(new Scene(root, 600, 400));
            primaryStage.setMinWidth(600);
            primaryStage.setMinHeight(400);
            primaryStage.show();
        } catch (final IOException e) {
            showErrorAndExit("Erreur de chargement FXML", 
                    "Impossible de charger l'interface utilisateur: " + e.getMessage());
        } catch (final Exception e) {
            showErrorAndExit("Erreur d'initialisation", 
                    "L'application n'a pas pu démarrer correctement: " + e.getMessage());
        }
    }

    /**
     * Affiche une erreur et quitte l'application
     */
    private void showErrorAndExit(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText("Erreur critique");
        alert.setContentText(message);
        alert.showAndWait();
        Platform.exit();
    }

    public static void main(final String[] args) {
        try {
            launch(args);
        } catch (final Exception e) {
            System.err.println("Erreur lors du lancement de l'application JavaFX:");
            System.err.println("Cette erreur peut être due à l'absence de modules JavaFX.");
            System.err.println("Veuillez lancer l'application avec les arguments VM suivants:");
            System.err.println("--module-path <chemin/vers/javafx-sdk>/lib --add-modules javafx.controls,javafx.fxml");
            e.printStackTrace();
        }
    }
    
    @Override
    public void stop() {
        // Nettoyage des ressources lors de la fermeture de l'application
        System.out.println("Application fermée");
    }
}


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/client/gui/controllers/ChatController.java
// ============================================

package org.example.client.gui.controllers;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Optional;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.example.client.repository.JsonLocalMessageRepository;
import org.example.model.Message;
import org.example.model.MessageType;
import org.example.model.User;
import org.example.service.ChatService;
import org.example.service.NotificationService;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.ListCell;
import javafx.scene.control.TextField;
import javafx.scene.control.TextInputDialog;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.layout.Region;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import javafx.scene.input.KeyCode;

public class ChatController {
    @FXML
    private Label userEmailLabel;

    @FXML
    private Label userStatusLabel;

    @FXML
    private Label typingIndicatorLabel;

    @FXML
    private ListView<String> contactListView;

    @FXML
    private TextField newContactField;

    @FXML
    private VBox chatHistoryContainer;

    @FXML
    private TextField messageField;

    @FXML
    private Label statusLabel;

    private ChatService chatService;
    private String userEmail;
    private String selectedContact;

    private final ObservableList<String> contacts = FXCollections.observableArrayList();
    private static final DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm");
    private final JsonLocalMessageRepository localRepo = new JsonLocalMessageRepository();

    // Gestion des événements de frappe
    private final ScheduledExecutorService typingExecutor = Executors.newSingleThreadScheduledExecutor();
    private java.util.concurrent.ScheduledFuture<?> stopTypingFuture;
    private boolean isTyping = false;
    private static final int TYPING_TIMEOUT = 3000; // 3 secondes

    private final NotificationService notificationService = NotificationService.getInstance();
    private final Map<String, Label> contactLabels = new HashMap<>();
    private final Map<String, Boolean> contactOnlineStatus = new HashMap<>();

    @FXML
    public void initialize() {
        contactListView.setItems(contacts);
        contactListView.setCellFactory(lv -> new ListCell<String>() {
            @Override
            protected void updateItem(String contact, boolean empty) {
                super.updateItem(contact, empty);
                if (empty || contact == null) {
                    setText(null);
                    setGraphic(null);
                } else {
                    HBox container = new HBox(5);
                    container.setAlignment(Pos.CENTER_LEFT);
                    container.setPadding(new Insets(0, 5, 0, 5));
                    
                    // Créer un cercle pour l'indicateur de statut
                    Region statusDot = new Region();
                    statusDot.setPrefSize(8, 8);
                    statusDot.setMinSize(8, 8);
                    statusDot.setMaxSize(8, 8);
                    
                    // Récupérer le statut actuel, par défaut considérer comme hors ligne (false)
                    boolean isOnline = contactOnlineStatus.getOrDefault(contact, false);
                    statusDot.setStyle(
                        "-fx-background-radius: 4px; " +
                        "-fx-background-color: " + (isOnline ? "#2ecc71" : "#e74c3c") + ";"
                    );
                    
                    // Email du contact
                    Label emailLabel = new Label(contact);
                    emailLabel.setStyle("-fx-font-size: 14px;");
                    
                    container.getChildren().addAll(statusDot, emailLabel);
                    setGraphic(container);
                    
                    // Stocker la référence pour les mises à jour futures
                    contactLabels.put(contact, emailLabel);
                }
            }
        });

        // Ajouter un écouteur pour la sélection
        contactListView.getSelectionModel().selectedItemProperty().addListener(
                (observable, oldValue, newValue) -> {
                    if (newValue != null) {
                        selectedContact = newValue;
                        loadConversation(selectedContact);
                    }
                });

        // Configurer le champ de message
        messageField.setOnKeyPressed(event -> {
            if (event.getCode() == KeyCode.ENTER) {
                handleSendMessage();
            }
        });

        // Configurer l'indicateur de frappe
        messageField.textProperty().addListener((observable, oldValue, newValue) -> {
            handleTyping();
        });
    }

    public void setUserEmail(String email) {
        this.userEmail = email;
        userEmailLabel.setText(email);
        loadUserStatus();
        loadContacts();
    }

    public void setChatService(ChatService service) {
        this.chatService = service;
        chatService.setMessageConsumer(this::processMessage);
        
        // Rafraîchir les statuts toutes les 30 secondes au lieu de 10 secondes
        ScheduledExecutorService statusRefreshExecutor = Executors.newSingleThreadScheduledExecutor();
        statusRefreshExecutor.scheduleAtFixedRate(() -> {
            if (chatService != null) {
                chatService.refreshOnlineStatuses();
            }
        }, 15, 30, TimeUnit.SECONDS);
    }

    private void processMessage(Message message) {
        if (message.getType() == MessageType.STATUS_UPDATE) {
            handleStatusUpdate(message);
        } else if (message.getType() == MessageType.CHAT) {
            handleChatMessage(message);
        } else if (message.getType() == MessageType.TYPING) {
            handleTypingIndicator(message, true);
        } else if (message.getType() == MessageType.STOP_TYPING) {
            handleTypingIndicator(message, false);
        }
    }

    private void handleStatusUpdate(Message message) {
        String contactEmail = message.getSenderEmail();
        boolean isOnline = Boolean.parseBoolean(message.getContent());
        
        Platform.runLater(() -> {
            // Mettre à jour le statut dans la map
            boolean oldStatus = contactOnlineStatus.getOrDefault(contactEmail, false);
            contactOnlineStatus.put(contactEmail, isOnline);
            
            // Ne rafraîchir que si le statut a réellement changé
            if (oldStatus != isOnline) {
                // Rafraîchir la vue pour mettre à jour les indicateurs visuels
                contactListView.refresh();
                System.out.println("Mise à jour du statut pour " + contactEmail + ": " + 
                    (isOnline ? "en ligne" : "hors ligne") + " (changement détecté)");
                
                // Si c'est le contact actuellement sélectionné, mettre à jour son statut dans l'interface
                if (contactEmail.equals(selectedContact)) {
                    updateSelectedContactStatus(isOnline);
                }
            }
        });
    }

    private void updateSelectedContactStatus(boolean isOnline) {
        if (selectedContact != null) {
            // Mettre à jour un indicateur visuel dans l'interface pour le contact sélectionné
            String statusText = isOnline ? "en ligne" : "hors ligne";
            Platform.runLater(() -> {
                setStatus("Contact " + selectedContact + " est " + statusText);
            });
        }
    }

    private void handleTyping() {
        if (selectedContact == null) return;
        
        if (!isTyping) {
            isTyping = true;
            try {
                Message typingMsg = new Message();
                typingMsg.setType(MessageType.TYPING);
                typingMsg.setSenderEmail(userEmail);
                typingMsg.setReceiverEmail(selectedContact);
                chatService.sendMessage(typingMsg);
            } catch (IOException e) {
                System.err.println("Erreur lors de l'envoi de l'indicateur de frappe: " + e.getMessage());
            }
        }
        
        // Réinitialiser le timer d'arrêt de frappe
        if (stopTypingFuture != null) {
            stopTypingFuture.cancel(false);
        }
        
        // Programmer l'arrêt de l'indicateur après 2 secondes d'inactivité
        stopTypingFuture = typingExecutor.schedule(() -> {
            stopTypingIndicator();
        }, 2, TimeUnit.SECONDS);
    }

    private void handleTypingIndicator(Message message, boolean isTyping) {
        Platform.runLater(() -> {
            // Afficher l'indicateur uniquement si le message vient du contact sélectionné
            if (selectedContact != null && message.getSenderEmail().equals(selectedContact)) {
                typingIndicatorLabel.setText(isTyping ? selectedContact + " est en train d'écrire..." : "");
            }
        });
    }

    @FXML
    private void handleSendMessage() {
        final String content = messageField.getText().trim();
        if (content.isEmpty() || selectedContact == null) {
            return;
        }

        try {
            final Message message = new Message();
            message.setContent(content);
            message.setRecipientEmail(selectedContact);
            message.setSenderEmail(userEmail);
            message.setTimestamp(LocalDateTime.now());

            chatService.sendMessage(message);
            messageField.clear();
            addMessageToChat(message);
        } catch (final IOException e) {
            setStatus("Erreur lors de l'envoi du message: " + e.getMessage());
        }
    }

    @FXML
    private void handleAddContact() {
        final String email = newContactField.getText().trim();

        if (email.isEmpty()) {
            setStatus("Veuillez saisir un email");
            return;
        }

        try {
            final boolean added = chatService.addContact(userEmail, email);
            if (added) {
                contacts.add(email);
                newContactField.clear();
                setStatus("Contact ajouté: " + email);
            }
        } catch (final IllegalArgumentException e) {
            // Afficher le message d'erreur spécifique
            setStatus("Erreur: " + e.getMessage());
        } catch (final IOException e) {
            setStatus("Erreur de connexion: " + e.getMessage());
        }
    }

    @FXML
    private void handleRemoveContact() {
        if (selectedContact == null) {
            setStatus("Aucun contact sélectionné pour la suppression");
            return;
        }
        try {
            final boolean removed = chatService.removeContact(userEmail, selectedContact);
            if (removed) {
                contacts.remove(selectedContact);
                // Nettoyer la conversation affichée
                chatHistoryContainer.getChildren().clear();
                // Supprimer la conversation persistée localement
                localRepo.removeConversation(userEmail, selectedContact);
                setStatus("Contact et conversation supprimés: " + selectedContact);
                selectedContact = null;
            } else {
                setStatus("La suppression du contact a échoué");
            }
        } catch (final IOException e) {
            setStatus("Erreur: " + e.getMessage());
        }
    }

    @FXML
    private void handleLogout() {
        try {
            // Arrêter l'indicateur de frappe avant la déconnexion
            stopTypingIndicator();
            typingExecutor.shutdown();
            
            System.out.println("Déconnexion de l'utilisateur: " + userEmail);
            // Le ChatService va notifier le PresenceManager de la déconnexion
            chatService.disconnect();

            // Revenir à l'écran de connexion
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            final Parent loginView = loader.load();

            final Stage stage = (Stage) userEmailLabel.getScene().getWindow();
            stage.setTitle("Chat Application");
            stage.setScene(new Scene(loginView, 600, 400));
            stage.centerOnScreen();
        } catch (final IOException e) {
            setStatus("Erreur lors de la déconnexion: " + e.getMessage());
        }
    }

    @FXML
    private void handleEditStatus() {
        TextInputDialog dialog = new TextInputDialog(userStatusLabel.getText());
        dialog.setTitle("Modifier le statut");
        dialog.setHeaderText("Entrez votre nouveau statut");
        dialog.setContentText("Statut:");

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(newStatus -> {
            try {
                chatService.updateUserStatus(userEmail, newStatus);
                userStatusLabel.setText(newStatus.isEmpty() ? "👍 Disponible" : newStatus);
                setStatus("Statut mis à jour");
            } catch (IOException e) {
                setStatus("Erreur lors de la mise à jour du statut: " + e.getMessage());
            }
        });
    }

    private void loadContacts() {
        try {
            final List<String> contactList = chatService.getContacts(userEmail);
            Platform.runLater(() -> {
                contacts.clear();
                contacts.addAll(contactList);

                // Initialiser les statuts des contacts
                contactList.forEach(contact -> {
                    try {
                        User user = chatService.getUser(contact);
                        if (user != null) {
                            // Par défaut en ligne sauf si explicitement marqué hors ligne
                            contactOnlineStatus.put(contact, user.isOnline());
                            System.out.println("Statut initial de " + contact + ": " + (user.isOnline() ? "en ligne" : "hors ligne"));
                        }
                    } catch (IOException e) {
                        // En cas d'erreur, considérer l'utilisateur comme en ligne
                        contactOnlineStatus.put(contact, true);
                        System.err.println("Erreur lors du chargement du statut pour " + contact + ": " + e.getMessage());
                    }
                });

                // Sélectionner automatiquement le premier contact
                if (!contacts.isEmpty()) {
                    contactListView.getSelectionModel().select(0);
                }
                
                // Rafraîchir la vue
                contactListView.refresh();
            });
        } catch (final IOException e) {
            setStatus("Erreur lors du chargement des contacts: " + e.getMessage());
        }
    }

    private void loadConversation(final String contactEmail) {
        chatHistoryContainer.getChildren().clear();

        try {
            // Charger les messages depuis le serveur
            List<Message> messages = chatService.getConversation(userEmail, contactEmail);
            messages.forEach(this::addMessageToChat);
            setStatus("Conversation chargée avec " + contactEmail);
        } catch (final IOException e) {
            setStatus("Erreur lors du chargement de la conversation : " + e.getMessage());
        }
    }

    private void handleChatMessage(final Message message) {
        Platform.runLater(() -> {
            String senderEmail = message.getSenderEmail();
            
            // Afficher une notification si ce n'est pas le contact actif
            if (!senderEmail.equals(selectedContact)) {
                notificationService.showNotification(senderEmail, message.getContent());
                updateContactStyle(senderEmail, true);
            }

            // Afficher le message s'il appartient à la conversation active
            if (selectedContact != null &&
                    (senderEmail.equals(selectedContact) ||
                            message.getReceiverEmail().equals(selectedContact))) {
                addMessageToChat(message);
            }

            // Enregistrer localement le message
            try {
                localRepo.addLocalMessage(userEmail, message);
            } catch (final IOException e) {
                System.err.println("Erreur de sauvegarde locale : " + e.getMessage());
            }

            // Mise à jour des contacts si nécessaire
            final String otherUser = senderEmail.equals(userEmail) ? message.getReceiverEmail()
                    : senderEmail;
            if (!contacts.contains(otherUser)) {
                contacts.add(otherUser);
            }

            // Envoyer l'accusé de réception
            try {
                chatService.acknowledgeMessage(message.getId());
            } catch (final IOException e) {
                System.err.println("Failed to acknowledge message: " + e.getMessage());
            }
        });
    }

    private void addMessageToChat(final Message message) {
        final boolean isMine = message.getSenderEmail().equals(userEmail);

        // Créer une boîte pour le message
        final HBox messageBox = new HBox();
        messageBox.setMaxWidth(chatHistoryContainer.getWidth() * 0.8);
        messageBox.setPadding(new Insets(5));
        messageBox.setAlignment(isMine ? Pos.CENTER_RIGHT : Pos.CENTER_LEFT);

        // Contenu du message
        final VBox messageContent = new VBox();
        messageContent.setMaxWidth(chatHistoryContainer.getWidth() * 0.7);
        messageContent.setPadding(new Insets(10));
        messageContent.setStyle("-fx-background-color: " + (isMine ? "#DCF8C6" : "#E1E1E1") + ";" +
                "-fx-background-radius: 10;");

        final Label contentLabel = new Label(message.getContent());
        contentLabel.setWrapText(true);

        // Afficher l'heure et le status du message
        final String statusDisplay = message.getTimestamp().format(timeFormatter)
                + " - " + (message.getStatus() != null ? message.getStatus() : "N/A");
        final Label statusLabel = new Label(statusDisplay);
        statusLabel.setTextFill(Color.GRAY);

        messageContent.getChildren().addAll(contentLabel, statusLabel);
        messageBox.getChildren().add(messageContent);

        // Ajouter le message à l'historique
        Platform.runLater(() -> {
            chatHistoryContainer.getChildren().add(messageBox);
            // Faire défiler vers le bas pour voir le nouveau message
            chatHistoryContainer.heightProperty().addListener(observable -> chatHistoryContainer.layout());
        });
    }

    private void setStatus(final String status) {
        Platform.runLater(() -> statusLabel.setText(status));
    }

    private void loadUserStatus() {
        try {
            User user = chatService.getUser(userEmail);
            Platform.runLater(() -> {
                String status = user.getStatus();
                userStatusLabel.setText(status.isEmpty() ? "👍 Disponible" : status);
            });
        } catch (IOException e) {
            setStatus("Erreur lors du chargement du statut: " + e.getMessage());
        }
    }

    private void stopTypingIndicator() {
        if (selectedContact != null && isTyping) {
            isTyping = false;
            try {
                Message stopTypingMessage = new Message();
                stopTypingMessage.setSenderEmail(userEmail);
                stopTypingMessage.setReceiverEmail(selectedContact);
                stopTypingMessage.setType(MessageType.STOP_TYPING);
                chatService.sendMessage(stopTypingMessage);
            } catch (IOException e) {
                System.err.println("Erreur lors de l'envoi de l'événement STOP_TYPING: " + e.getMessage());
            }
        }
        Platform.runLater(() -> typingIndicatorLabel.setText(""));
    }

    private void updateContactStyle(String contact, boolean hasUnreadMessages) {
        Platform.runLater(() -> {
            Label label = contactLabels.get(contact);
            if (label != null) {
                if (hasUnreadMessages) {
                    label.setStyle("-fx-font-weight: bold;");
                } else {
                    label.setStyle("");
                }
            }
        });
    }
}

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/client/gui/controllers/LoginController.java
// ============================================

package org.example.client.gui.controllers;

import java.io.IOException;

import org.example.dto.Credentials;
import org.example.service.ChatService;
import org.example.service.NotificationService;

import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.stage.Stage;

public class LoginController {

    @FXML
    private TextField emailField;
    
    @FXML
    private PasswordField passwordField;
    
    @FXML
    private Button loginButton;
    
    private final ChatService chatService;
    
    public LoginController() {
        this.chatService = new ChatService();
    }
    
    @FXML
    public void initialize() {
        // Activer le bouton de connexion seulement si des valeurs sont entrées
        loginButton.disableProperty().bind(
            emailField.textProperty().isEmpty().or(
            passwordField.textProperty().isEmpty())
        );
    }
    
    @FXML
    private void handleLogin(final ActionEvent event) {
        final String email = emailField.getText().trim();
        final String password = passwordField.getText();
        
        if (email.isEmpty() || password.isEmpty()) {
            showError("Erreur de connexion", "Veuillez remplir tous les champs");
            return;
        }
        
        // Désactiver temporairement le binding pour pouvoir désactiver le bouton
        loginButton.disableProperty().unbind();
        loginButton.setDisable(true);
        
        // Créer un thread séparé pour la connexion
        new Thread(() -> {
            try {
                final boolean success = chatService.connect(new Credentials(email, password));
                
                Platform.runLater(() -> {
                    if (success) {
                        try {
                            openChatWindow(email);
                        } catch (final IOException e) {
                            showError("Erreur", "Impossible d'ouvrir la fenêtre de chat: " + e.getMessage());
                            rebindLoginButton();
                        }
                    } else {
                        showError("Erreur de connexion", "Email ou mot de passe incorrect");
                        rebindLoginButton();
                    }
                });
            } catch (final IOException e) {
                Platform.runLater(() -> {
                    showError("Erreur de connexion", "Impossible de se connecter au serveur: " + e.getMessage());
                    rebindLoginButton();
                });
            }
        }).start();
    }
    
    private void rebindLoginButton() {
        // Rebinder le bouton avec la condition initiale
        loginButton.disableProperty().bind(
            emailField.textProperty().isEmpty().or(
            passwordField.textProperty().isEmpty())
        );
    }
    
    private void openChatWindow(final String userEmail) throws IOException {
        // Charger la vue de chat
        final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/chat.fxml"));
        final Parent chatView = loader.load();
        
        // Configurer le contrôleur de chat
        final ChatController chatController = loader.getController();
        chatController.setChatService(chatService);
        chatController.setUserEmail(userEmail);
        
        // Créer et afficher la nouvelle scène
        final Scene chatScene = new Scene(chatView, 800, 600);
        final Stage currentStage = (Stage) loginButton.getScene().getWindow();
        
        currentStage.setTitle("Chat - " + userEmail);
        currentStage.setScene(chatScene);
        currentStage.setMinWidth(800);
        currentStage.setMinHeight(600);
        currentStage.centerOnScreen();

        // Initialiser le NotificationService avec le Stage principal
        NotificationService.getInstance().setMainStage(currentStage);
    }
    
    private void showError(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/client/gui/Launcher.java
// ============================================

package org.example.client.gui;



/**
 * Classe de lancement pour l'application JavaFX.
 * Cette classe sert de point d'entrée principal pour éviter les problèmes
 * de modules JavaFX lors de l'exécution à partir d'un JAR.
 */
public class Launcher {
    /**
     * Point d'entrée principal de l'application.
     * @param args Arguments de ligne de commande
     */
    public static void main(final String[] args) {
        // Lance l'application JavaFX
        ChatClientApplication.main(args);
    }
}


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/client/repository/JsonLocalMessageRepository.java
// ============================================

package org.example.client.repository;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

import org.example.model.Message;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

/**
 * Classe de persistance locale pour l'historique des messages d'un utilisateur.
 * L'historique est stocké sous forme de fichier JSON dans le dossier "src/main/client_data".
 */
public class JsonLocalMessageRepository {
    // Utilisation du répertoire de projet pour stocker les données clients
    private static final String LOCAL_FOLDER = System.getProperty("user.dir")
            + File.separator + "src" + File.separator + "main" + File.separator + "client_data";
    private final ObjectMapper objectMapper;

    public JsonLocalMessageRepository() {
        this.objectMapper = new ObjectMapper();
        this.objectMapper.registerModule(new JavaTimeModule());
        this.objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        ensureLocalFolderExists();
    }

    private void ensureLocalFolderExists() {
        final Path folderPath = Paths.get(LOCAL_FOLDER);
        if (!Files.exists(folderPath)) {
            try {
                Files.createDirectories(folderPath);
            } catch (final IOException e) {
                System.err.println("Erreur lors de la création du dossier client_data : " + e.getMessage());
            }
        }
    }

    /**
     * Renvoie le chemin complet du fichier de l'utilisateur.
     */
    private String getUserFilePath(final String userEmail) {
        // Remplacer les caractères spéciaux pour créer un nom de fichier valide
        final String fileName = userEmail.replaceAll("[^a-zA-Z0-9]", "_") + "_messages.json";
        return LOCAL_FOLDER + File.separator + fileName;
    }

    /**
     * Charge la liste des messages locaux pour l'utilisateur.
     */
    public List<Message> loadLocalMessages(final String userEmail) throws IOException {
        final String filePath = getUserFilePath(userEmail);
        final File file = new File(filePath);
        if (!file.exists()) {
            return new ArrayList<>();
        }
        final CollectionType listType = objectMapper.getTypeFactory()
                .constructCollectionType(ArrayList.class, Message.class);
        return objectMapper.readValue(file, listType);
    }

    /**
     * Enregistre la liste des messages locaux pour l'utilisateur.
     */
    public void saveLocalMessages(final String userEmail, final List<Message> messages) throws IOException {
        final String filePath = getUserFilePath(userEmail);
        objectMapper.writeValue(new File(filePath), messages);
    }

    /**
     * Ajoute un nouveau message dans l'historique local pour l'utilisateur.
     */
    public void addLocalMessage(final String userEmail, final Message message) throws IOException {
        final List<Message> messages = loadLocalMessages(userEmail);
        messages.add(message);
        saveLocalMessages(userEmail, messages);
    }

    /**
     * Supprime un message de l'historique local pour l'utilisateur.
     */
    public void removeConversation(final String userEmail, final String contactEmail) throws IOException {
        final List<Message> messages = loadLocalMessages(userEmail);
        messages.removeIf(m ->
                (m.getSenderEmail().equals(userEmail) && m.getReceiverEmail().equals(contactEmail))
             || (m.getSenderEmail().equals(contactEmail) && m.getReceiverEmail().equals(userEmail)));
        saveLocalMessages(userEmail, messages);
    }
}

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/config/NotificationConfig.java
// ============================================

package org.example.config;

import java.util.prefs.Preferences;

public class NotificationConfig {
    private static final String PREF_SOUND_ENABLED = "notification_sound_enabled";
    private static final String PREF_POPUP_ENABLED = "notification_popup_enabled";
    private static final String PREF_TRAY_ENABLED = "notification_tray_enabled";
    
    private static NotificationConfig instance;
    private final Preferences preferences;

    private NotificationConfig() {
        preferences = Preferences.userNodeForPackage(NotificationConfig.class);
    }

    public static synchronized NotificationConfig getInstance() {
        if (instance == null) {
            instance = new NotificationConfig();
        }
        return instance;
    }

    public boolean isSoundEnabled() {
        return preferences.getBoolean(PREF_SOUND_ENABLED, true);
    }

    public void setSoundEnabled(boolean enabled) {
        preferences.putBoolean(PREF_SOUND_ENABLED, enabled);
    }

    public boolean isPopupEnabled() {
        return preferences.getBoolean(PREF_POPUP_ENABLED, true);
    }

    public void setPopupEnabled(boolean enabled) {
        preferences.putBoolean(PREF_POPUP_ENABLED, enabled);
    }

    public boolean isTrayEnabled() {
        return preferences.getBoolean(PREF_TRAY_ENABLED, true);
    }

    public void setTrayEnabled(boolean enabled) {
        preferences.putBoolean(PREF_TRAY_ENABLED, enabled);
    }
} 

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/dto/Credentials.java
// ============================================

package org.example.dto;

/**
 * Classe DTO pour les informations d'authentification.
 */
public class Credentials {
    private String email;
    private String password;
    
    // Constructeur par défaut requis pour Jackson
    public Credentials() {
    }
    
    public Credentials(final String email, final String password) {
        this.email = email;
        this.password = password;
    }
    
    // Getters et Setters
    public String getEmail() {
        return email;
    }
    
    public void setEmail(final String email) {
        this.email = email;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(final String password) {
        this.password = password;
    }
}

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/model/Message.java
// ============================================

package org.example.model;

import java.time.LocalDateTime;
import java.util.Objects;
import java.util.UUID;

import com.fasterxml.jackson.annotation.JsonProperty;

public class Message {
    private String id; // PK
    private String senderEmail; // FK
    private String receiverEmail; // FK
    private String content;
    private LocalDateTime timestamp; // Creation date !!

    @JsonProperty("read")
    private boolean isRead;
    private MessageType type; // CHAT, LOGOUT, TYPING, etc.
    private String status; // PENDING, QUEUED, DELIVERED, ACKNOWLEDGED, EXPIRED

    // Constructeur par défaut pour Jackson
    public Message() {
        this.id = UUID.randomUUID().toString();
        this.timestamp = LocalDateTime.now();
        this.isRead = false;
        this.status = "PENDING";
        this.type = MessageType.CHAT;
    }

    public Message(final String senderEmail, final String receiverEmail, final String content) {
        this();
        this.senderEmail = senderEmail;
        this.receiverEmail = receiverEmail;
        this.content = content;
    }

    // Getters and Setters
    public String getId() {
        return id;
    }

    public void setId(final String id) {
        this.id = id;
    }

    public String getSenderEmail() {
        return senderEmail;
    }

    public void setSenderEmail(final String senderEmail) {
        this.senderEmail = senderEmail;
    }

    public String getReceiverEmail() {
        return receiverEmail;
    }

    public void setReceiverEmail(final String receiverEmail) {
        this.receiverEmail = receiverEmail;
    }

    // Alias pour setReceiverEmail pour plus de clarté
    public void setRecipientEmail(final String recipientEmail) {
        this.receiverEmail = recipientEmail;
    }

    public String getContent() {
        return content;
    }

    public void setContent(final String content) {
        this.content = content;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(final LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public boolean isRead() {
        return isRead;
    }

    public void setRead(final boolean read) {
        this.isRead = read;
    }

    public MessageType getType() {
        return type;
    }

    public void setType(MessageType type) {
        this.type = type;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(final String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Message{" +
                "id='" + id + '\'' +
                ", senderEmail='" + senderEmail + '\'' +
                ", receiverEmail='" + receiverEmail + '\'' +
                ", content='"
                + (content != null ? content.substring(0, Math.min(content.length(), 20)) + "..." : "null") + '\'' +
                ", timestamp=" + timestamp +
                ", isRead=" + isRead +
                ", type='" + type + '\'' +
                ", status='" + status + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (!(o instanceof Message))
            return false;
        Message message = (Message) o;
        return Objects.equals(id, message.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/model/MessageType.java
// ============================================

package org.example.model;

public enum MessageType {
    CHAT,
    TYPING,
    STOP_TYPING,
    LOGOUT,
    LOGOUT_CONFIRM,
    PING,
    STATUS_UPDATE
} 

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/model/User.java
// ============================================

package org.example.model;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonProperty;

public class User {
    private String email;        // PK
    private String displayName;  // user name for display
    private String password;     // hashed password
    private String status;       // user status message
    
    @JsonProperty("online")
    private boolean isOnline;    // user online status
    
    @JsonProperty("contactEmails")
    private List<String> contacts; // sera mappé depuis "contactEmails" du JSON
    
    // Constructeur par défaut pour Jackson
    public User() {
        this.isOnline = false;
        this.contacts = new ArrayList<>();
        this.status = "";  // Valeur par défaut
    }
    
    public User(final String email, final String displayName, final String password) {
        this();
        this.email = email;
        this.displayName = displayName;
        this.password = password;
    }

    // Getters and Setters
    public String getEmail() {
        return email;
    }

    public void setEmail(final String email) {
        this.email = email;
    }

    public String getDisplayName() {
        return displayName;
    }

    public void setDisplayName(final String displayName) {
        this.displayName = displayName;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(final String password) {
        this.password = password;
    }

    public boolean isOnline() {
        return isOnline;
    }

    public void setOnline(final boolean online) {
        isOnline = online;
    }

    public List<String> getContacts() {
        return contacts;
    }

    public void setContacts(final List<String> contacts) {
        this.contacts = contacts;
    }
    
    public void addContact(final String contactEmail) {
        if (!contacts.contains(contactEmail)) {
            contacts.add(contactEmail);
        }
    }
    
    public boolean removeContact(final String contactEmail) {
        return contacts.remove(contactEmail);
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "User{" +
                "email='" + email + '\'' +
                ", displayName='" + displayName + '\'' +
                ", status='" + status + '\'' +
                ", isOnline=" + isOnline +
                ", contactsCount=" + contacts.size() +
                '}';
    }
}


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/repository/JsonMessageRepository.java
// ============================================

package org.example.repository;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.example.model.Message;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

// this class will provide methods that will do the following : 
// - a method to save a list of messages objects to a json file (messages.json), by writing to the json file
// - a method to load all messages from the JSON file (messages.json) and return them as a list of messages objects 
public class JsonMessageRepository {
    // location of the messages.json
    private static final String MESSAGES_FILE = "src/main/data/messages.json";
    private final ObjectMapper objectMapper;
    private final File messagesFile;

    // constructor that creates an instance of ObjectMapper()
    public JsonMessageRepository() {
        // object Mapper is a class provided by the jackson library it serializes and
        // deserialzes JSON strings;
        this.objectMapper = new ObjectMapper();
        // Register JavaTimeModule to handle LocalDateTime serialization
        this.objectMapper.registerModule(new JavaTimeModule());
        // this provides the path for the messages.json file
        this.messagesFile = new File(MESSAGES_FILE);
    }

    // this method uses a jackson method used to serialize any Java value as JSON
    // output, written to File provided.
    public void saveMessages(final List<Message> messages) throws IOException {
        // inputs : a list of messages , a file path
        // effect : serialization and persistance into the provided file path
        objectMapper.writeValue(messagesFile, messages);
    }

    // this method will retrieve data from the JSON file and return a list of
    // messages
    // the issue here is, jackson do not know to what type of objects the list will
    // have
    public List<Message> loadMessages() throws IOException {
        if (!messagesFile.exists()) {
            throw new IOException("messages.json file not found in data directory");
        }
        // this is the key line
        // here we tell jackson that we need an ArrayList containing Message objects
        // !!!!!!!
        // we are telling jackson that the json file is an array (ArrayList) and this
        // array will have objects of type (Message)
        final CollectionType listType = objectMapper.getTypeFactory()
                .constructCollectionType(ArrayList.class, Message.class);
        // this readVale() method needs two informations to function , first the path of
        // the JSON file then an information regarding the types
        // that jackson should use to desirialize
        // its like we are telling jackson to Take this JSON array (messagesFile) and
        // create an ArrayList of Message objects from it.
        final ArrayList<Message> messages = objectMapper.readValue(messagesFile, listType);
        // then we return the messages array
        return messages;
    }

    public void saveMessage(final Message message) throws IOException {
        // we will first load all messages from the messages.json using the Jackson
        // desirializer
        final List<Message> messages = loadMessages();
        // then we will add the new message at the end of the list
        messages.add(message);
        System.out.println("saving message: ");

        // then we serialize and save the new array of messages
        saveMessages(messages);
        System.out.println("Message saved: " + message.getContent());
    }

    /**
     * Met à jour un message existant
     */
    public void updateMessage(final Message updatedMessage) throws IOException {
        final List<Message> messages = loadMessages();
        
        for (int i = 0; i < messages.size(); i++) {
            if (messages.get(i).getId().equals(updatedMessage.getId())) {
                messages.set(i, updatedMessage);
                saveMessages(messages);
                return;
            }
        }
        
        // Si le message n'existe pas, le sauvegarder
        messages.add(updatedMessage);
        saveMessages(messages);
    }
    
    /**
     * Recherche un message par son ID
     */
    public Optional<Message> findById(final String messageId) throws IOException {
        return loadMessages().stream()
                .filter(message -> message.getId().equals(messageId))
                .findFirst();
    }

    // Get all messages for a specific user (both sent and received)
    public List<Message> getUserMessages(final String userEmail) throws IOException {
        return loadMessages().stream()
                .filter(m -> m.getSenderEmail().equals(userEmail) ||
                        m.getReceiverEmail().equals(userEmail))
                .collect(Collectors.toList());
    }

    // Get only messages sent from the user we pass in argument
    public List<Message> getSentMessages(final String userEmail) throws IOException {
        return loadMessages()
                .stream() // here we turn this into a stream
                .filter(m -> m.getSenderEmail().equals(userEmail))
                .collect(Collectors.toList()); // this will gather all sent messages and put them into a List
    }

    // this will get only messages received by a user passed in
    public List<Message> getReceivedMessages(final String userEmail) throws IOException {
        return loadMessages()
                .stream()
                .filter(m -> m.getReceiverEmail().equals(userEmail))
                .collect(Collectors.toList()); // here we tranform a stream back into a usable list
    }

    // Get only unread messages for a user
    public List<Message> getUnreadMessages(final String userEmail) throws IOException {
        return loadMessages()
                .stream()
                .filter(m -> m.getReceiverEmail().equals(userEmail) && !m.isRead())
                .collect(Collectors.toList()); // this will gather all received and unread messages
    }

    // Get conversation between two users
    public List<Message> getConversation(final String user1Email, final String user2Email) throws IOException {
        return loadMessages().stream()
                .filter(m -> (m.getSenderEmail().equals(user1Email) && m.getReceiverEmail().equals(user2Email)) ||
                        (m.getSenderEmail().equals(user2Email) && m.getReceiverEmail().equals(user1Email)))
                .collect(Collectors.toList());
    }

    // Delete a message
    public boolean deleteMessage(final String messageId) throws IOException {
        final List<Message> messages = loadMessages();
        final boolean removed = messages.removeIf(m -> m.getId().equals(messageId));
        if (removed) {
            saveMessages(messages);
            System.out.println("Message " + messageId + " deleted");
        }
        return removed;
    }
}


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/repository/JsonUserRepository.java
// ============================================

package org.example.repository;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.example.model.User;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.CollectionType;

public class JsonUserRepository {
    private static final String USERS_FILE = "src/main/data/utilisateurs.json";
    private final ObjectMapper objectMapper;
    private final File usersFile;

    public JsonUserRepository() {
        // this object will be imported from jackson, it handles JSON serialization/deserialization
        // Jackson's main class for JSON operations (JSON conversion)
        this.objectMapper = new ObjectMapper(); 
        // this is the file representing the user json 
        this.usersFile = new File(USERS_FILE);
        // No need for initializeRepository() since file already exists
    }

    // this method takes in a list of users of type User
    public void saveUsers(final List<User> users) throws IOException {
        // this method WriteValues takes the objects in the array users and writes them in the udersFile
        objectMapper.writeValue(usersFile, users);
    }

    // this method reads Users from the json file and returns them
    public List<User> loadUsers() throws IOException {
        // if the userFIle is deleted we return an empty list
        if (!usersFile.exists()) {
            throw new IOException("utilisateurs.json file not found in data directory");
        }
        // here we Create a type definition for List<User>
        final CollectionType listType = objectMapper.getTypeFactory()
            .constructCollectionType(ArrayList.class, User.class);

        // here we Read and convert JSON back to Java objects
        return objectMapper.readValue(usersFile, listType);
    }

    // this method calls loadUsers() and then uses streams to filter out only the users with a certain email
    // it returns an optional that can have a user or cannot have anything 
    public Optional<User> findByEmail(final String email) throws IOException {
        return loadUsers() // get list of users ArrayList<Users>
            .stream()  // convert to stream
            .filter(user -> user.getEmail().equals(email)) // filter users
            .findFirst(); // triggers the execution and returns an Optional with the first user to pass the filter
            // findFirst returns an Optional of type User
                // - this Optional can either be empty if the stream doesn return anything 
                // - or can contain a user

                // - if the Optional is not empty, optn.isPresent() will return true and optn.get() will return the value stored
                // - if its empty optn.isPresent() will return false
        // - opts.empty() true
        // opts.ifPresent(u -> u.setStatus(true))
    }



    public void saveUser(final User user) throws IOException {
        final List<User> users = loadUsers();
        users.removeIf(u -> u.getEmail().equals(user.getEmail()));
        users.add(user);
        saveUsers(users);
    }

    public void updateUserStatus(final String email, final boolean isOnline) throws IOException {
        final List<User> users = loadUsers();
        users.stream()
            .filter(u -> u.getEmail().equals(email))
            .findFirst()
            .ifPresent(u -> {
                u.setOnline(isOnline);
                System.out.println("User " + email + " status updated to: " + isOnline);
            });
        saveUsers(users);
    }
}


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/server/ChatServer.java
// ============================================

package org.example.server;

import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.example.broker.MessageBroker;
import org.example.service.UserService;

public class ChatServer {
    private static final int PORT = 5000;

    public static void main(final String[] args) throws Exception {
        // Initialiser le broker de messages
        MessageBroker.getInstance();
        
        // Créer un service pour vérifier périodiquement les statuts
        final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        final UserService userService = new UserService();
        
        // Vérifier les statuts toutes les 30 secondes
        scheduler.scheduleAtFixedRate(() -> {
            try {
                userService.synchronizeOnlineStatuses();
            } catch (Exception e) {
                System.err.println("Erreur lors de la synchronisation des statuts: " + e.getMessage());
            }
        }, 20, 30, TimeUnit.SECONDS);

        // Démarrer le serveur
        final ServerSocket server = new ServerSocket(PORT);
        System.out.println("Server started on port " + PORT);
        System.out.println("Waiting for clients...");

        try {
            while (true) {
                final Socket client = server.accept();
                final ClientHandler clientHandler = new ClientHandler(client);
                new Thread(clientHandler).start();
            }
        } finally {
            scheduler.shutdown();
            server.close();
        }
    }
}

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/server/ClientHandler.java
// ============================================

package org.example.server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.List;
import java.util.Optional;

import org.example.broker.MessageBroker;
import org.example.dto.Credentials;
import org.example.model.Message;
import org.example.model.MessageType;
import org.example.model.User;
import org.example.service.UserService;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

public class ClientHandler implements Runnable {
    private static final String AUTH_SUCCESS = "AUTH_SUCCESS";
    private static final String AUTH_FAILED = "AUTH_FAILED";

    private final Socket clientSocket;
    private final MessageBroker broker;
    private final UserService userService;
    private final ObjectMapper mapper;

    private String clientEmail;
    private PrintWriter output;
    private BufferedReader input;
    private volatile boolean isConnected;

    public ClientHandler(final Socket socket) {
        this.clientSocket = socket;
        this.broker = MessageBroker.getInstance();
        this.userService = new UserService();
        this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
    }

    @Override
    public void run() {
        try {
            // Configurer la communication
            output = new PrintWriter(clientSocket.getOutputStream(), true);
            input = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

            // Authentifier l'utilisateur
            if (authenticateUser()) {
                isConnected = true;
                
                // Mettre à jour le statut de l'utilisateur en ligne
                updateUserStatus(true);
                
                // Enregistrer ce client pour les notifications
                broker.registerListener(clientEmail, this);
                
                // Envoyer les statuts de tous les contacts actuellement connectés
                sendAllContactStatuses();
                
                // Commencer à traiter les messages
                processMessages();
            }
        } catch (IOException e) {
            System.err.println("Error in client communication: " + e.getMessage());
        } finally {
            // Nettoyage en cas de déconnexion
            cleanup();
            closeResources();
        }
    }

    private boolean authenticateUser() throws IOException {
        final Credentials credentials = mapper.readValue(input.readLine(), Credentials.class);
        if (userService.authenticate(credentials.getEmail(), credentials.getPassword())) {
            this.clientEmail = credentials.getEmail();
            sendResponse(AUTH_SUCCESS);
            System.out.println("Authentification réussie pour " + clientEmail);
            return true;
        }
        sendResponse(AUTH_FAILED);
        System.out.println("Échec d'authentification pour " + credentials.getEmail());
        return false;
    }

    private void initializeSubscription() throws IOException {
        userService.setUserOnlineStatus(clientEmail, true);
        // broker.unregisterListener(clientEmail);
        broker.registerListener(clientEmail, this);
        isConnected = true;
    }

    private void processMessages() throws IOException {
        String messageJson;
        long lastActivityTime = System.currentTimeMillis();
        long timeoutInterval = 5000; // 5 secondes d'inactivité = déconnexion
        
        // Démarrer un thread de surveillance pour la détection de déconnexion
        Thread watchdog = startWatchdogThread(timeoutInterval);
        
        try {
            while (isConnected && (messageJson = input.readLine()) != null) {
                lastActivityTime = System.currentTimeMillis();
                try {
                    final Message message = mapper.readValue(messageJson, Message.class);
                    
                    if (message.getType() == MessageType.CHAT) {
                        broker.sendMessage(message);
                    } else if (message.getType() == MessageType.LOGOUT) {
                        terminateSession();
                        break;
                    } else if (message.getType() == MessageType.PING) {
                        // Mise à jour du statut actif sur réception de ping
                        updateUserStatus(true);
                    } else if (message.getType() == MessageType.TYPING || 
                             message.getType() == MessageType.STOP_TYPING ||
                             message.getType() == MessageType.STATUS_UPDATE) {
                        // Transmettre directement les événements spéciaux sans les persister
                        broker.sendMessage(message);
                    }
                } catch (final IOException e) {
                    System.out.println("Invalid message format: " + messageJson);
                }
                
                // Vérifier si le socket est toujours connecté
                if (!clientSocket.isConnected() || clientSocket.isClosed()) {
                    System.out.println("Socket déconnecté pour " + clientEmail);
                    isConnected = false;
                    break;
                }
            }
        } finally {
            // Arrêter le thread de surveillance
            watchdog.interrupt();
            
            // Si on sort de la boucle sans terminateSession explicite, c'est une déconnexion inattendue
            if (isConnected) {
                System.out.println("Déconnexion inattendue détectée pour " + clientEmail);
                terminateSession();
            }
        }
    }

    private Thread startWatchdogThread(long timeoutInterval) {
        Thread watchdog = new Thread(() -> {
            long lastCheck = System.currentTimeMillis();
            while (isConnected && !Thread.currentThread().isInterrupted()) {
                try {
                    Thread.sleep(1000); // Vérifier toutes les secondes
                    
                    long now = System.currentTimeMillis();
                    
                    // Si le socket est fermé ou si la connexion est inactive depuis trop longtemps
                    if (!clientSocket.isConnected() || clientSocket.isClosed() ||
                        now - lastCheck > timeoutInterval) {
                        System.out.println("Watchdog: déconnexion détectée pour " + clientEmail);
                        isConnected = false;
                        
                        // S'assurer que l'utilisateur est marqué hors ligne
                        updateUserStatus(false);
                        break;
                    }
                    
                    lastCheck = now;
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        
        watchdog.setDaemon(true);
        watchdog.start();
        return watchdog;
    }

    public void onMessageReceived(final Message message) throws IOException {
        output.println(mapper.writeValueAsString(message));
    }

    private void sendResponse(final String response) {
        output.println(response);
    }

    private void terminateSession() {
        isConnected = false;
        
        try {
            // Envoyer confirmation de déconnexion
            Message confirmMsg = new Message();
            confirmMsg.setType(MessageType.LOGOUT_CONFIRM);
            onMessageReceived(confirmMsg);
        } catch (IOException e) {
            System.err.println("Error sending logout confirmation: " + e.getMessage());
        }
        
        // Mettre à jour le statut de l'utilisateur hors ligne
        updateUserStatus(false);
    }

    private void cleanup() {
        if (clientEmail != null) {
            try {
                broker.unregisterListener(clientEmail);
                updateUserStatus(false);
                System.out.println("Client déconnecté: " + clientEmail);
            } catch (Exception e) {
                System.err.println("Error during cleanup: " + e.getMessage());
            }
        }
    }

    private void sendAllContactStatuses() {
        try {
            // Récupérer tous les utilisateurs en ligne
            List<User> onlineUsers = userService.getOnlineUsers();
            
            // Pour chaque utilisateur en ligne, envoyer son statut à ce client
            for (User user : onlineUsers) {
                if (!user.getEmail().equals(clientEmail)) {
                    Message statusMsg = new Message();
                    statusMsg.setType(MessageType.STATUS_UPDATE);
                    statusMsg.setSenderEmail(user.getEmail());
                    statusMsg.setContent("true");
                    onMessageReceived(statusMsg);
                }
            }
        } catch (IOException e) {
            System.err.println("Erreur lors de l'envoi des statuts des contacts: " + e.getMessage());
        }
    }

    private void updateUserStatus(boolean online) {
        if (clientEmail != null) {
            try {
                // Vérifier d'abord si le statut a changé pour éviter les notifications inutiles
                Optional<User> user = userService.getUserByEmail(clientEmail);
                if (user.isPresent() && user.get().isOnline() != online) {
                    userService.setUserOnlineStatus(clientEmail, online);
                    System.out.println("Statut utilisateur " + clientEmail + " mis à jour: " + (online ? "en ligne" : "hors ligne"));
                    
                    // Notifier les autres utilisateurs du changement de statut
                    Message statusUpdate = new Message();
                    statusUpdate.setType(MessageType.STATUS_UPDATE);
                    statusUpdate.setSenderEmail(clientEmail);
                    statusUpdate.setContent(String.valueOf(online));
                    broker.sendMessage(statusUpdate);
                }
            } catch (IOException e) {
                System.err.println("Error updating user status: " + e.getMessage());
            }
        }
    }

    private void closeResources() {
        try {
            if (input != null) input.close();
            if (output != null) output.close();
            if (clientSocket != null && !clientSocket.isClosed()) clientSocket.close();
        } catch (IOException e) {
            System.err.println("Error closing resources: " + e.getMessage());
        }
    }
}

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/service/ChatService.java
// ============================================

package org.example.service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ConnectException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;

import org.example.dto.Credentials;
import org.example.model.Message;
import org.example.model.MessageType;
import org.example.model.User;
import org.example.repository.JsonMessageRepository;
import org.example.client.repository.JsonLocalMessageRepository;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

public class ChatService {
    private static final String SERVER_ADDRESS = "localhost";
    private static final int SERVER_PORT = 5000;

    private Socket socket;
    private PrintWriter out;
    private BufferedReader in;
    private String userEmail;
    private final ObjectMapper objectMapper;
    private Consumer<Message> messageConsumer;
    private final JsonMessageRepository messageRepository;
    private final UserService userService;
    private final PresenceManager presenceManager;

    private Thread listenerThread;
    private boolean isRunning = false;

    // Ajouter ces champs pour la gestion plus intelligente des statuts
    private final Map<String, Boolean> contactStatusCache = new ConcurrentHashMap<>();
    private long lastStatusRefreshTime = 0;

    public ChatService() {
        this.objectMapper = new ObjectMapper().registerModule(new JavaTimeModule());
        this.messageRepository = new JsonMessageRepository();
        this.userService = new UserService();
        this.presenceManager = new PresenceManager(this, userService);
    }

    public String getUserEmail() {
        return userEmail;
    }

    public boolean connect(final Credentials credentials) throws IOException {
        try {
            // Se connecter au serveur
            System.out.println("Tentative de connexion au serveur " + SERVER_ADDRESS + ":" + SERVER_PORT);
            socket = new Socket(SERVER_ADDRESS, SERVER_PORT);
            out = new PrintWriter(socket.getOutputStream(), true);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            // Envoyer les identifiants
            final String jsonCredentials = objectMapper.writeValueAsString(credentials);
            out.println(jsonCredentials);

            // Attendre la réponse du serveur
            final String response = in.readLine();
            final boolean success = "AUTH_SUCCESS".equals(response);

            if (success) {
                this.userEmail = credentials.getEmail();
                startMessageListener();
                presenceManager.start(); // Démarrer le gestionnaire de présence
                System.out.println("Authentification réussie pour " + userEmail);
            } else {
                System.out.println("Échec de l'authentification");
                disconnect();
            }

            return success;
        } catch (final ConnectException e) {
            throw new IOException("Impossible de se connecter au serveur. Vérifiez qu'il est en cours d'exécution.");
        }
    }

    public void disconnect() throws IOException {
        // Marquer l'utilisateur comme hors ligne via le PresenceManager
        if (presenceManager != null) {
            presenceManager.stop();
        }
        
        // Envoyer un message LOGOUT explicite
        try {
            Message logoutMessage = new Message();
            logoutMessage.setType(MessageType.LOGOUT);
            logoutMessage.setSenderEmail(userEmail);
            sendMessage(logoutMessage);
            System.out.println("Message de déconnexion envoyé pour " + userEmail);
        } catch (IOException e) {
            System.err.println("Erreur lors de l'envoi du message de déconnexion: " + e.getMessage());
        }
        
        // Fermer les connexions
        if (out != null) {
            out.close();
        }
        if (in != null) {
            in.close();
        }
        if (socket != null && !socket.isClosed()) {
            socket.close();
        }
        
        isRunning = false;
        if (listenerThread != null) {
            listenerThread.interrupt();
        }

        // Réinitialiser l'état
        userEmail = null;
        messageConsumer = null;

        System.out.println("Déconnexion complète");
    }

    public boolean sendMessage(final Message message) throws IOException {
        if (socket == null || socket.isClosed() || out == null) {
            throw new IOException("Non connecté au serveur");
        }
        // Ne modifier le type que si c'est un nouveau message sans type spécifié
        if (message.getType() == null) {
            message.setType(MessageType.CHAT);
        }
        final String jsonMessage = objectMapper.writeValueAsString(message);
        out.println(jsonMessage);
        return true;
    }

    public void acknowledgeMessage(final String messageId) throws IOException {
        messageRepository.deleteMessage(messageId);
    }

    public List<String> getContacts(final String userEmail) throws IOException {
        final Optional<User> optionalUser = userService.getUserByEmail(userEmail);
        return optionalUser.map(User::getContacts).orElse(new ArrayList<>());
    }

    public boolean addContact(final String userEmail, final String contactEmail) throws IOException {
        return userService.addContact(userEmail, contactEmail);
    }

    public boolean removeContact(final String userEmail, final String contactEmail) throws IOException {
        return userService.removeContact(userEmail, contactEmail);
    }

    public List<Message> getConversation(final String user1Email, final String user2Email) throws IOException {
        try {
            List<Message> messages = messageRepository.getConversation(user1Email, user2Email);
            
            // Mettre à jour le statut des messages reçus comme DELIVERED
            for (Message message : messages) {
                if (message.getReceiverEmail().equals(userEmail) && 
                    !"DELIVERED".equals(message.getStatus())) {
                    message.setStatus("DELIVERED");
                    messageRepository.updateMessage(message);
                }
            }
            
            // Ajouter les messages locaux
            JsonLocalMessageRepository localRepo = new JsonLocalMessageRepository();
            List<Message> localMessages = localRepo.loadLocalMessages(userEmail);
            
            // Filtrer les messages locaux pour n'inclure que ceux de cette conversation
            List<Message> filteredLocalMessages = localMessages.stream()
                .filter(msg -> (msg.getSenderEmail().equals(user1Email) && msg.getReceiverEmail().equals(user2Email)) ||
                            (msg.getSenderEmail().equals(user2Email) && msg.getReceiverEmail().equals(user1Email)))
                .toList();
            
            // Combiner les deux ensembles de messages en évitant les doublons
            List<Message> combined = new ArrayList<>(messages);
            for (Message localMsg : filteredLocalMessages) {
                if (messages.stream().noneMatch(m -> m.getId() != null && m.getId().equals(localMsg.getId()))) {
                    combined.add(localMsg);
                }
            }
            
            // Trier par timestamp
            combined.sort((m1, m2) -> m1.getTimestamp().compareTo(m2.getTimestamp()));
            
            return combined;
        } catch (Exception e) {
            System.err.println("Erreur lors de la récupération de la conversation: " + e.getMessage());
            e.printStackTrace();
            return new ArrayList<>();
        }
    }

    public void setMessageConsumer(Consumer<Message> consumer) {
        this.messageConsumer = consumer;
        
        // Après avoir configuré le consumer, initialiser les statuts
        refreshOnlineStatuses();
        
        // Programmation d'une tâche pour essayer d'envoyer les messages en attente
        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.scheduleAtFixedRate(this::retryPendingMessages, 10, 30, TimeUnit.SECONDS);
    }

    /**
     * Tente de réenvoyer les messages en attente
     */
    private void retryPendingMessages() {
        if (!isRunning || userEmail == null) {
            return;
        }
        
        try {
            System.out.println("Tentative d'envoi des messages en attente...");
            List<Message> pendingMessages = messageRepository.getUserMessages(userEmail).stream()
                .filter(m -> "PENDING".equals(m.getStatus()) || "QUEUED".equals(m.getStatus()))
                .toList();
            
            if (!pendingMessages.isEmpty()) {
                System.out.println("Envoi de " + pendingMessages.size() + " messages en attente");
                for (Message message : pendingMessages) {
                    try {
                        message.setStatus("DELIVERED");
                        sendMessage(message);
                    } catch (Exception e) {
                        System.err.println("Échec d'envoi du message en attente " + message.getId() + ": " + e.getMessage());
                    }
                }
            }
        } catch (Exception e) {
            System.err.println("Erreur lors de la tentative d'envoi des messages en attente: " + e.getMessage());
        }
    }

    /**
     * Récupère et rafraîchit les statuts en ligne de tous les utilisateurs
     */
    public void refreshOnlineStatuses() {
        try {
            // Vérifier si le rafraîchissement est nécessaire (pas plus d'une fois toutes les 15 secondes)
            long currentTime = System.currentTimeMillis();
            if (currentTime - lastStatusRefreshTime < 15000) {
                return; // Éviter les rafraîchissements trop fréquents
            }
            lastStatusRefreshTime = currentTime;
            
            // Vérifier si notre socket est toujours connecté
            boolean clientConnected = socket != null && !socket.isClosed() && socket.isConnected();
            
            // Si nous ne sommes pas connectés, notre utilisateur doit être hors ligne
            if (!clientConnected && userEmail != null) {
                Optional<User> currentUser = userService.getUserByEmail(userEmail);
                if (currentUser.isPresent() && currentUser.get().isOnline()) {
                    userService.setUserOnlineStatus(userEmail, false);
                    System.out.println("Client local déconnecté, statut mis à jour en conséquence");
                }
                return; // Ne pas continuer si nous sommes déconnectés
            }
            
            // Récupérer les statuts à jour et les envoyer au client, seulement pour nos contacts
            if (userEmail != null && messageConsumer != null) {
                List<String> contacts = getContacts(userEmail);
                for (String contactEmail : contacts) {
                    Optional<User> contactUser = userService.getUserByEmail(contactEmail);
                    if (contactUser.isPresent()) {
                        User user = contactUser.get();
                        boolean isOnline = user.isOnline() && userService.isUserReallyConnected(contactEmail);
                        
                        // Vérifier si le statut a changé depuis la dernière notification
                        Boolean lastKnownStatus = contactStatusCache.get(contactEmail);
                        if (lastKnownStatus == null || lastKnownStatus != isOnline) {
                            contactStatusCache.put(contactEmail, isOnline);
                            System.out.println("Envoi du statut pour " + contactEmail + ": " + (isOnline ? "en ligne" : "hors ligne"));
                            
                            // Envoyer une notification de statut
                            Message statusMsg = new Message();
                            statusMsg.setType(MessageType.STATUS_UPDATE);
                            statusMsg.setSenderEmail(contactEmail);
                            statusMsg.setContent(String.valueOf(isOnline));
                            messageConsumer.accept(statusMsg);
                        }
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Erreur lors du rafraîchissement des statuts: " + e.getMessage());
        }
    }

    private void startMessageListener() {
        isRunning = true;

        listenerThread = new Thread(() -> {
            try {
                String jsonMessage;
                while (isRunning && (jsonMessage = in.readLine()) != null) {
                    try {
                        final Message message = objectMapper.readValue(jsonMessage, Message.class);

                        if (message.getType() == MessageType.LOGOUT_CONFIRM) {
                            break;
                        }

                        // Transmettre tous les types de messages au consommateur
                        if (messageConsumer != null) {
                            // N'acquitter que les messages de type CHAT
                            if (message.getType() == MessageType.CHAT) {
                                acknowledgeMessage(message.getId());
                            }
                            messageConsumer.accept(message);
                        }
                    } catch (final Exception e) {
                        System.err.println("Erreur lors du traitement du message: " + e.getMessage());
                    }
                }
            } catch (final IOException e) {
                if (isRunning) {
                    System.err.println("Connexion perdue: " + e.getMessage());
                }
            } finally {
                isRunning = false;
            }
        });

        listenerThread.setDaemon(true);
        listenerThread.start();
    }

    public User getUser(String email) throws IOException {
        Optional<User> optionalUser = userService.getUserByEmail(email);
        if (optionalUser.isPresent()) {
            return optionalUser.get();
        }
        throw new IOException("Utilisateur non trouvé: " + email);
    }

    public void updateUserStatus(String email, String status) throws IOException {
        Optional<User> optionalUser = userService.getUserByEmail(email);
        if (optionalUser.isPresent()) {
            User user = optionalUser.get();
            user.setStatus(status);
            userService.updateUser(user);
        } else {
            throw new IOException("Utilisateur non trouvé: " + email);
        }
    }
}


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/service/MessageService.java
// ============================================

/* package org.example.service;

import java.io.IOException;
import java.util.List;

import org.example.broker.MessageBroker;
import org.example.model.Message;
import org.example.repository.JsonMessageRepository;
import org.example.repository.JsonUserRepository;

public class MessageService {
    private final JsonMessageRepository messageRepository;
    private final JsonUserRepository userRepository;
    private final MessageBroker messageBroker;

    public MessageService() {
        this.messageRepository = new JsonMessageRepository();
        this.userRepository = new JsonUserRepository();
        this.messageBroker = MessageBroker.getInstance();
    }

    public boolean sendMessage(final Message message) throws IOException {
        // Vérifier que l'expéditeur et le destinataire existent
        if (userRepository.findByEmail(message.getSenderEmail()).isEmpty() || 
            userRepository.findByEmail(message.getReceiverEmail()).isEmpty()) {
            return false;
        }
        
        // Le Message Broker gère la persistance et la mise en file d'attente
        // Nous passons null ici car la décision d'envoyer le message directement
        // est déjà prise au niveau du ClientHandler
        messageBroker.sendMessage(message, null);
        return true;
    }

    public List<Message> getUnreadMessages(final String userEmail) throws IOException {
        return messageRepository.getUnreadMessages(userEmail);
    }
}
 */

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/service/NotificationService.java
// ============================================

package org.example.service;

import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.FloatControl;
import java.awt.*;
import java.net.URL;
import org.example.config.NotificationConfig;

public class NotificationService {
    private static NotificationService instance;
    private final NotificationConfig config;
    private Clip notificationSound;
    private TrayIcon trayIcon;
    private int unreadCount = 0;
    private Stage mainStage;

    private NotificationService() {
        config = NotificationConfig.getInstance();
        initializeSound();
        setupSystemTray();
    }

    public static synchronized NotificationService getInstance() {
        if (instance == null) {
            instance = new NotificationService();
        }
        return instance;
    }

    private void initializeSound() {
        try {
            URL soundUrl = getClass().getResource("/sounds/notification.wav");
            if (soundUrl != null) {
                System.out.println("Chargement du son depuis: " + soundUrl);
                AudioInputStream audioStream = AudioSystem.getAudioInputStream(soundUrl);
                notificationSound = AudioSystem.getClip();
                notificationSound.open(audioStream);
                
                // Ajuster le volume si possible
                if (notificationSound.isControlSupported(FloatControl.Type.MASTER_GAIN)) {
                    FloatControl gainControl = (FloatControl) notificationSound.getControl(FloatControl.Type.MASTER_GAIN);
                    gainControl.setValue(6.0f); // Augmenter le volume de 6 dB
                }
                
                System.out.println("Son chargé avec succès");
            } else {
                System.err.println("Le fichier de son n'a pas été trouvé");
            }
        } catch (Exception e) {
            System.err.println("Erreur lors du chargement du son: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void setupSystemTray() {
        if (SystemTray.isSupported() && config.isTrayEnabled()) {
            try {
                SystemTray tray = SystemTray.getSystemTray();
                URL iconUrl = getClass().getResource("/icons/app_icon.png");
                if (iconUrl != null) {
                    Image icon = Toolkit.getDefaultToolkit().getImage(iconUrl);
                    trayIcon = new TrayIcon(icon, "Chat Application");
                    trayIcon.setImageAutoSize(true);
                    tray.add(trayIcon);
                }
            } catch (Exception e) {
                System.err.println("Erreur lors de l'initialisation du system tray: " + e.getMessage());
            }
        }
    }

    public void setMainStage(Stage stage) {
        this.mainStage = stage;
    }

    public void showNotification(String senderEmail, String message) {
        if (!isApplicationFocused()) {
            Platform.runLater(() -> {
                // Afficher une alerte JavaFX si activée
                if (config.isPopupEnabled()) {
                    Alert alert = new Alert(AlertType.INFORMATION);
                    alert.setTitle("Nouveau message");
                    alert.setHeaderText(senderEmail);
                    alert.setContentText(message);
                    alert.initStyle(StageStyle.UTILITY);
                    alert.show();
                }

                // Jouer le son si activé
                if (config.isSoundEnabled()) {
                    playNotificationSound();
                }

                // Afficher une notification système si activée
                if (config.isTrayEnabled() && trayIcon != null) {
                    trayIcon.displayMessage(
                        "Nouveau message de " + senderEmail,
                        message,
                        TrayIcon.MessageType.INFO
                    );
                }

                // Incrémenter le compteur de messages non lus
                incrementUnreadCount();
            });
        }
    }

    private void incrementUnreadCount() {
        unreadCount++;
        updateTitleBadge();
    }

    public void decrementUnreadCount() {
        if (unreadCount > 0) {
            unreadCount--;
            updateTitleBadge();
        }
    }

    private void updateTitleBadge() {
        if (mainStage != null) {
            Platform.runLater(() -> {
                String baseTitle = "Chat Application";
                if (unreadCount > 0) {
                    mainStage.setTitle(String.format("%s (%d)", baseTitle, unreadCount));
                } else {
                    mainStage.setTitle(baseTitle);
                }
            });
        }
    }

    private void playNotificationSound() {
        if (notificationSound != null) {
            try {
                System.out.println("Lecture du son de notification");
                notificationSound.setFramePosition(0);
                notificationSound.start();
                // Attendre que le son soit terminé avant de le réinitialiser
                Thread.sleep(100); // Petit délai pour s'assurer que le son est lu
            } catch (Exception e) {
                System.err.println("Erreur lors de la lecture du son: " + e.getMessage());
                e.printStackTrace();
            }
        } else {
            System.err.println("Le son de notification n'est pas initialisé");
        }
    }

    private boolean isApplicationFocused() {
        return mainStage != null && mainStage.isFocused();
    }

    public void resetUnreadCount() {
        unreadCount = 0;
        updateTitleBadge();
    }
} 

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/service/PresenceManager.java
// ============================================

package org.example.service;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.example.model.Message;
import org.example.model.MessageType;
import org.example.model.User;

public class PresenceManager {
    private static final int PING_INTERVAL = 20; // 20 secondes entre les pings
    private static final int OFFLINE_THRESHOLD = 60; // 60 secondes pour être marqué hors ligne
    private final ChatService chatService;
    private final UserService userService;
    private final ScheduledExecutorService pingExecutor;
    private final Map<String, Long> lastActivityMap;
    private int failedPings = 0;
    private static final int MAX_FAILED_PINGS = 2;
    
    // Ajouter cette map pour éviter les mises à jour redondantes
    private final Map<String, Boolean> userStatusCache = new ConcurrentHashMap<>();

    public PresenceManager(ChatService chatService, UserService userService) {
        this.chatService = chatService;
        this.userService = userService;
        this.pingExecutor = Executors.newSingleThreadScheduledExecutor();
        this.lastActivityMap = new ConcurrentHashMap<>();
    }

    public void start() {
        try {
            // Mettre à jour et notifier immédiatement le statut en ligne
            String userEmail = chatService.getUserEmail();
            if (userEmail != null) {
                // Forcer le statut en ligne au démarrage
                User user = userService.getUserByEmail(userEmail).orElse(null);
                if (user != null) {
                    user.setOnline(true);
                    userService.updateUser(user);
                    userStatusCache.put(userEmail, true); // Mettre à jour le cache
                    notifyContactsOfStatusChange(userEmail, true);
                }
                updateLastActivity(userEmail);
            }
            
            // Démarrer l'envoi périodique des pings (toutes les 20 secondes)
            pingExecutor.scheduleAtFixedRate(this::sendPing, 0, PING_INTERVAL, TimeUnit.SECONDS);
            
            // Vérifier les inactifs toutes les 20 secondes
            pingExecutor.scheduleAtFixedRate(this::checkInactiveUsers, 0, 20, TimeUnit.SECONDS);
        } catch (IOException e) {
            System.err.println("Erreur lors du démarrage du PresenceManager: " + e.getMessage());
        }
    }

    public void stop() {
        try {
            // Marquer explicitement l'utilisateur comme hors ligne avant de s'arrêter
            String userEmail = chatService.getUserEmail();
            if (userEmail != null) {
                User user = userService.getUserByEmail(userEmail).orElse(null);
                if (user != null && user.isOnline()) {
                    user.setOnline(false);
                    userService.updateUser(user);
                    userStatusCache.put(userEmail, false); // Mettre à jour le cache
                    notifyContactsOfStatusChange(userEmail, false);
                    System.out.println("Utilisateur " + userEmail + " marqué hors ligne lors de la déconnexion");
                }
            }
        } catch (IOException e) {
            System.err.println("Erreur lors de la déconnexion: " + e.getMessage());
        }
        
        // Arrêter l'exécuteur
        pingExecutor.shutdown();
        try {
            if (!pingExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                pingExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            pingExecutor.shutdownNow();
        }
    }

    private void sendPing() {
        try {
            String userEmail = chatService.getUserEmail();
            Message pingMessage = new Message();
            pingMessage.setType(MessageType.PING);
            pingMessage.setSenderEmail(userEmail);
            chatService.sendMessage(pingMessage);
            failedPings = 0; // Réinitialiser le compteur en cas de succès
            
            // Forcer la mise à jour du statut en ligne à chaque ping réussi
            updateLastActivity(userEmail);
        } catch (IOException e) {
            failedPings++;
            if (failedPings >= MAX_FAILED_PINGS) {
                handleConnectionLost();
            }
        }
    }

    private void checkInactiveUsers() {
        long currentTime = System.currentTimeMillis();
        lastActivityMap.forEach((email, lastActivity) -> {
            if (currentTime - lastActivity > OFFLINE_THRESHOLD * 1000) {
                try {
                    // Vérifier si l'utilisateur est déjà marqué comme hors ligne dans le cache
                    Boolean cachedStatus = userStatusCache.get(email);
                    if (cachedStatus == null || cachedStatus) { // null ou true signifie qu'il n'est pas marqué hors ligne
                        User user = userService.getUserByEmail(email).orElse(null);
                        if (user != null && user.isOnline()) {
                            System.out.println("Utilisateur " + email + " marqué hors ligne après " + OFFLINE_THRESHOLD + " secondes d'inactivité");
                            
                            // Marquer comme hors ligne dans la base de données
                            user.setOnline(false);
                            userService.updateUser(user);
                            userStatusCache.put(email, false); // Mettre à jour le cache
                            
                            // Notifier tous les utilisateurs du changement de statut
                            notifyContactsOfStatusChange(email, false);
                            
                            // Supprimer l'entrée pour éviter les notifications répétées
                            lastActivityMap.remove(email);
                        }
                    }
                } catch (IOException e) {
                    System.err.println("Erreur lors de la mise à jour du statut: " + e.getMessage());
                }
            }
        });
    }

    private void handleConnectionLost() {
        try {
            String userEmail = chatService.getUserEmail();
            if (userEmail != null) {
                User user = userService.getUserByEmail(userEmail).orElse(null);
                if (user != null) {
                    user.setOnline(false);
                    userService.updateUser(user);
                    userStatusCache.put(userEmail, false); // Mettre à jour le cache
                    notifyContactsOfStatusChange(userEmail, false);
                }
            }
        } catch (IOException e) {
            System.err.println("Erreur lors de la gestion de la perte de connexion: " + e.getMessage());
        }
    }

    public void updateLastActivity(String userEmail) {
        if (userEmail == null) return;
        
        // Enregistrer le dernier timestamp d'activité
        Long lastTimestamp = lastActivityMap.get(userEmail);
        long currentTime = System.currentTimeMillis();
        lastActivityMap.put(userEmail, currentTime);
        
        // Ne pas envoyer de mise à jour trop fréquemment (au maximum une fois par minute)
        if (lastTimestamp != null && currentTime - lastTimestamp < 60000) {
            return;
        }
        
        try {
            // Vérifier si l'utilisateur est déjà marqué comme en ligne dans le cache
            Boolean cachedStatus = userStatusCache.get(userEmail);
            if (cachedStatus == null || !cachedStatus) { // null ou false signifie qu'il n'est pas marqué en ligne
                User user = userService.getUserByEmail(userEmail).orElse(null);
                if (user != null && !user.isOnline()) {
                    user.setOnline(true);
                    userService.updateUser(user);
                    userStatusCache.put(userEmail, true); // Mettre à jour le cache
                    notifyContactsOfStatusChange(userEmail, true);
                    System.out.println("Utilisateur " + userEmail + " marqué en ligne");
                }
            }
        } catch (IOException e) {
            System.err.println("Erreur lors de la mise à jour de l'activité: " + e.getMessage());
        }
    }

    private void notifyContactsOfStatusChange(String userEmail, boolean isOnline) {
        try {
            Message statusUpdate = new Message();
            statusUpdate.setType(MessageType.STATUS_UPDATE);
            statusUpdate.setSenderEmail(userEmail);
            statusUpdate.setContent(String.valueOf(isOnline));
            chatService.sendMessage(statusUpdate);
            
            System.out.println("Notification de changement de statut envoyée pour " + userEmail + ": " + (isOnline ? "en ligne" : "hors ligne"));
        } catch (IOException e) {
            System.err.println("Erreur lors de l'envoi de la mise à jour de statut: " + e.getMessage());
        }
    }
} 

// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/java/org/example/service/UserService.java
// ============================================

package org.example.service;

import java.io.IOException;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.example.model.User;
import org.example.repository.JsonUserRepository;
import org.example.broker.MessageBroker;

public class UserService {
    private final JsonUserRepository userRepository;
    private final Map<String, Long> lastStatusUpdateTime = new ConcurrentHashMap<>();

    public UserService() {
        this.userRepository = new JsonUserRepository();
    }

    /**
     * Authentifie un utilisateur par email et mot de passe
     */
    public boolean authenticate(final String email, final String password) throws IOException {
        final Optional<User> userOpt = userRepository.findByEmail(email);
        if (userOpt.isPresent()) {
            final User user = userOpt.get();
            // Dans une application réelle, utiliser une méthode sécurisée de comparaison de mot de passe
            return user.getPassword().equals(password);
        }
        return false;
    }

    /**
     * Met à jour le statut en ligne d'un utilisateur
     */
    public void setUserOnlineStatus(final String email, final boolean status) throws IOException {
        final Optional<User> userOpt = userRepository.findByEmail(email);
        if (userOpt.isPresent()) {
            User user = userOpt.get();
            // Ne mettre à jour que si le statut a changé
            if (user.isOnline() != status) {
                user.setOnline(status);
                userRepository.saveUser(user);
                System.out.println("Statut de " + email + " mis à jour dans la base de données: " + (status ? "en ligne" : "hors ligne"));
            }
        } else {
            System.err.println("Tentative de mise à jour du statut pour un utilisateur inexistant: " + email);
        }
    }

    /**
     * Récupère un utilisateur par son email
     */
    public Optional<User> getUserByEmail(final String email) throws IOException {
        return userRepository.findByEmail(email);
    }

    /**
     * Récupère la liste de tous les utilisateurs
     */
    public List<User> getAllUsers() throws IOException {
        return userRepository.loadUsers();
    }

    /**
     * Récupère la liste de tous les utilisateurs en ligne
     */
    public List<User> getOnlineUsers() throws IOException {
        return userRepository.loadUsers().stream()
                .filter(User::isOnline)
                .toList();
    }

    /**
     * Crée un nouvel utilisateur
     */
    public boolean createUser(final User user) throws IOException {
        if (userRepository.findByEmail(user.getEmail()).isPresent()) {
            return false; // Utilisateur existe déjà
        }
        userRepository.saveUser(user);
        return true;
    }

    /**
     * Ajoute un contact à un utilisateur.
     * Vérifie que l'utilisateur et le contact existent, que l'utilisateur n'ajoute pas lui-même
     * et qu'il n'y a pas déjà de doublon.
     */
    public boolean addContact(final String userEmail, final String contactEmail) throws IOException {
        // Vérification si l'utilisateur tente de s'ajouter lui-même
        if (userEmail.equals(contactEmail)) {
            throw new IllegalArgumentException("Vous ne pouvez pas vous ajouter vous-même comme contact");
        }
        
        // Vérification de l'existence du contact
        final Optional<User> contactOpt = userRepository.findByEmail(contactEmail);
        if (contactOpt.isEmpty()) {
            throw new IllegalArgumentException("Cet utilisateur n'existe pas");
        }
        
        final Optional<User> userOpt = userRepository.findByEmail(userEmail);
        if (userOpt.isPresent()) {
            final User user = userOpt.get();
            // Vérification si le contact est déjà présent
            if (user.getContacts().contains(contactEmail)) {
                throw new IllegalArgumentException("Ce contact est déjà dans votre liste");
            }
            user.addContact(contactEmail);
            userRepository.saveUser(user);
            return true;
        }
        throw new IllegalArgumentException("Une erreur est survenue lors de l'ajout du contact");
    }

    /**
     * Supprime un contact de l'utilisateur.
     */
    public boolean removeContact(final String userEmail, final String contactEmail) throws IOException {
        final Optional<User> userOpt = userRepository.findByEmail(userEmail);
        if (userOpt.isPresent()) {
            final User user = userOpt.get();
            if (user.removeContact(contactEmail)) {
                userRepository.saveUser(user);
                return true;
            }
        }
        return false;
    }

    /**
     * Met à jour un utilisateur existant
     */
    public void updateUser(User user) throws IOException {
        if (userRepository.findByEmail(user.getEmail()).isEmpty()) {
            throw new IOException("Utilisateur non trouvé: " + user.getEmail());
        }
        userRepository.saveUser(user);
    }

    /**
     * Vérifie si un utilisateur est vraiment connecté au serveur
     * Cette méthode est utilisée pour vérifier si un utilisateur est actuellement connecté au serveur,
     * pas seulement marqué comme en ligne dans la base de données
     */
    public boolean isUserReallyConnected(final String email) {
        try {
            // Demander au broker quels utilisateurs ont une session active
            return MessageBroker.getInstance().hasActiveClient(email);
        } catch (Exception e) {
            System.err.println("Erreur lors de la vérification de la connexion: " + e.getMessage());
            return false;
        }
    }

    /**
     * Synchronise les statuts des utilisateurs avec l'état réel des connexions
     */
    public void synchronizeOnlineStatuses() throws IOException {
        List<User> users = getAllUsers();
        for (User user : users) {
            // Vérifier si l'utilisateur a une session active auprès du broker
            boolean isReallyConnected = isUserReallyConnected(user.getEmail());
            
            // Ne mettre à jour que s'il y a une différence et éviter les mises à jour trop fréquentes
            if (user.isOnline() != isReallyConnected) {
                // Vérifier le timestamp de la dernière mise à jour pour éviter les oscillations
                Long lastUpdateTime = lastStatusUpdateTime.getOrDefault(user.getEmail(), 0L);
                long currentTime = System.currentTimeMillis();
                
                // N'autoriser les mises à jour qu'après 30 secondes depuis la dernière modification
                if (currentTime - lastUpdateTime > 30000) {
                    System.out.println("Correction du statut de " + user.getEmail() + ": " 
                        + (user.isOnline() ? "en ligne" : "hors ligne") 
                        + " -> " + (isReallyConnected ? "en ligne" : "hors ligne"));
                        
                    setUserOnlineStatus(user.getEmail(), isReallyConnected);
                    lastStatusUpdateTime.put(user.getEmail(), currentTime);
                }
            }
        }
    }
}


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/resources/fxml/chat.fxml
// ============================================

<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<BorderPane xmlns="http://javafx.com/javafx/17" xmlns:fx="http://javafx.com/fxml/1"
            fx:controller="org.example.client.gui.controllers.ChatController">
    
    <!-- En-tête avec le nom de l'utilisateur, le statut et le bouton de déconnexion -->
    <top>
        <HBox alignment="CENTER_LEFT" spacing="10" style="-fx-background-color: #4CAF50; -fx-padding: 10px;">
            <VBox spacing="2">
                <Label fx:id="userEmailLabel" text="Non connecté" style="-fx-text-fill: white; -fx-font-weight: bold;"/>
                <HBox spacing="5" alignment="CENTER_LEFT">
                    <Label fx:id="userStatusLabel" text="👍 Disponible" style="-fx-text-fill: white; -fx-font-size: 12px;"/>
                    <Button fx:id="editStatusButton" text="✏️" onAction="#handleEditStatus" 
                            style="-fx-background-color: transparent; -fx-text-fill: white; -fx-padding: 0;"/>
                </HBox>
            </VBox>
            <Region HBox.hgrow="ALWAYS" />
            <Button text="Déconnexion" onAction="#handleLogout" 
                    style="-fx-background-color: #f44336; -fx-text-fill: white;"/>
        </HBox>
    </top>
    
    <!-- Partie centrale avec la liste des contacts et la zone de chat -->
    <center>
        <SplitPane dividerPositions="0.3">
            <!-- Liste des contacts -->
            <VBox spacing="10" style="-fx-padding: 10px;">
                <Label text="Contacts" style="-fx-font-weight: bold;"/>
                <ListView fx:id="contactListView" VBox.vgrow="ALWAYS"/>
                <HBox spacing="5">
                    <TextField fx:id="newContactField" promptText="Email du contact" HBox.hgrow="ALWAYS"/>
                    <Button text="+" onAction="#handleAddContact"/>
                    <Button text="-" onAction="#handleRemoveContact"/>
                </HBox>
            </VBox>
            
            <!-- Zone de chat -->
            <VBox>
                <!-- Historique des messages -->
                <ScrollPane fitToWidth="true" VBox.vgrow="ALWAYS">
                    <VBox fx:id="chatHistoryContainer" spacing="10" style="-fx-padding: 10px;"/>
                </ScrollPane>
                
                <!-- Indicateur "en train d'écrire" -->
                <Label fx:id="typingIndicatorLabel" style="-fx-text-fill: #666666; -fx-font-style: italic; -fx-padding: 5px;"/>
                
                <!-- Zone de saisie du message -->
                <HBox spacing="5" alignment="CENTER" style="-fx-padding: 10px;">
                    <TextField fx:id="messageField" promptText="Entrez votre message" HBox.hgrow="ALWAYS"/>
                    <Button text="Envoyer" onAction="#handleSendMessage" 
                            style="-fx-background-color: #4CAF50; -fx-text-fill: white;"/>
                </HBox>
            </VBox>
        </SplitPane>
    </center>
    
    <!-- Barre d'état en bas -->
    <bottom>
        <HBox alignment="CENTER_LEFT" style="-fx-padding: 5px; -fx-background-color: #f0f0f0;">
            <Label fx:id="statusLabel" text="Prêt"/>
        </HBox>
    </bottom>
</BorderPane>


// ============================================
// FICHIER: /c/Users/hp/Documents/ABCDEE/reseau-socket/sockets-java-chat-app/src/main/resources/fxml/login.fxml
// ============================================

<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.PasswordField?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<BorderPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="400.0" minWidth="600.0"
    prefHeight="400.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/17"
    xmlns:fx="http://javafx.com/fxml/1" fx:controller="org.example.client.gui.controllers.LoginController">
    <center>
        <VBox alignment="CENTER" maxWidth="400.0" spacing="15.0" BorderPane.alignment="CENTER">
            <children>
                <Label text="Chat Application" textAlignment="CENTER">
                    <font>
                        <Font name="System Bold" size="24.0" />
                    </font>
                </Label>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Email" />
                        <TextField fx:id="emailField" promptText="Entrez votre email" />
                    </children>
                </VBox>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Mot de passe" />
                        <PasswordField fx:id="passwordField" promptText="Entrez votre mot de passe" />
                    </children>
                </VBox>
                <Button fx:id="loginButton" defaultButton="true" maxWidth="1.7976931348623157E308"
                    mnemonicParsing="false" onAction="#handleLogin" text="Se connecter">
                    <VBox.margin>
                        <Insets top="10.0" />
                    </VBox.margin>
                </Button>
            </children>
            <BorderPane.margin>
                <Insets left="20.0" right="20.0" />
            </BorderPane.margin>
            <padding>
                <Insets bottom="20.0" left="20.0" right="20.0" top="20.0" />
            </padding>
        </VBox>
    </center>
    <bottom>
        <HBox alignment="CENTER" prefHeight="50.0" spacing="10.0" BorderPane.alignment="CENTER">
            <children>
                <Label text="© 2025 Chat Application" textFill="#686868" />
            </children>
        </HBox>
    </bottom>
</BorderPane>