


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/dto/Credentials.java
// ============================================

package org.example.dto;

/**
 * Classe DTO pour les informations d'authentification.
 */
public class Credentials {
    private String email;
    private String password;
    
    // Constructeur par défaut requis pour Jackson
    public Credentials() {
    }
    
    public Credentials(final String email, final String password) {
        this.email = email;
        this.password = password;
    }
    
    // Getters et Setters
    public String getEmail() {
        return email;
    }
    
    public void setEmail(final String email) {
        this.email = email;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(final String password) {
        this.password = password;
    }
}

// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/repository/JsonUserRepository.java
// ============================================

package org.example.repository;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.example.model.User;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.CollectionType;

public class JsonUserRepository {
    private static final String USERS_FILE = "src/main/data/utilisateurs.json";
    private final ObjectMapper objectMapper;
    private final File usersFile;

    public JsonUserRepository() {
        // this object will be imported from jackson, it handles JSON serialization/deserialization
        // Jackson's main class for JSON operations (JSON conversion)
        this.objectMapper = new ObjectMapper(); 
        // this is the file representing the user json 
        this.usersFile = new File(USERS_FILE);
        // No need for initializeRepository() since file already exists
    }

    // this method takes in a list of users of type User
    public void saveUsers(final List<User> users) throws IOException {
        // this method WriteValues takes the objects in the array users and writes them in the udersFile
        objectMapper.writeValue(usersFile, users);
    }

    // this method reads Users from the json file and returns them
    public List<User> loadUsers() throws IOException {
        // if the userFIle is deleted we return an empty list
        if (!usersFile.exists()) {
            throw new IOException("utilisateurs.json file not found in data directory");
        }
        // here we Create a type definition for List<User>
        final CollectionType listType = objectMapper.getTypeFactory()
            .constructCollectionType(ArrayList.class, User.class);

        // here we Read and convert JSON back to Java objects
        return objectMapper.readValue(usersFile, listType);
    }

    // this method calls loadUsers() and then uses streams to filter out only the users with a certain email
    // it returns an optional that can have a user or cannot have anything 
    public Optional<User> findByEmail(final String email) throws IOException {
        return loadUsers() // get list of users ArrayList<Users>
            .stream()  // convert to stream
            .filter(user -> user.getEmail().equals(email)) // filter users
            .findFirst(); // triggers the execution and returns an Optional with the first user to pass the filter
            // findFirst returns an Optional of type User
                // - this Optional can either be empty if the stream doesn return anything 
                // - or can contain a user

                // - if the Optional is not empty, optn.isPresent() will return true and optn.get() will return the value stored
                // - if its empty optn.isPresent() will return false
        // - opts.empty() true
        // opts.ifPresent(u -> u.setStatus(true))
    }



    public void saveUser(final User user) throws IOException {
        final List<User> users = loadUsers();
        users.removeIf(u -> u.getEmail().equals(user.getEmail()));
        users.add(user);
        saveUsers(users);
    }

    public void updateUserStatus(final String email, final boolean isOnline) throws IOException {
        final List<User> users = loadUsers();
        users.stream()
            .filter(u -> u.getEmail().equals(email))
            .findFirst()
            .ifPresent(u -> {
                u.setOnline(isOnline);
                System.out.println("User " + email + " status updated to: " + isOnline);
            });
        saveUsers(users);
    }
}


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/repository/JsonMessageRepository.java
// ============================================

package org.example.repository;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.example.model.Message;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

// this class will provide methods that will do the following : 
// - a method to save a list of messages objects to a json file (messages.json), by writing to the json file
// - a method to load all messages from the JSON file (messages.json) and return them as a list of messages objects 
public class JsonMessageRepository {
    // location of the messages.json
    private static final String MESSAGES_FILE = "src/main/data/messages.json";
    private final ObjectMapper objectMapper;
    private final File messagesFile;

    // constructor that creates an instance of ObjectMapper()
    public JsonMessageRepository() {
        // object Mapper is a class provided by the jackson library it serializes and
        // deserialzes JSON strings;
        this.objectMapper = new ObjectMapper();
        // Register JavaTimeModule to handle LocalDateTime serialization
        this.objectMapper.registerModule(new JavaTimeModule());
        // this provides the path for the messages.json file
        this.messagesFile = new File(MESSAGES_FILE);
    }

    // this method uses a jackson method used to serialize any Java value as JSON
    // output, written to File provided.
    public void saveMessages(final List<Message> messages) throws IOException {
        // inputs : a list of messages , a file path
        // effect : serialization and persistance into the provided file path
        objectMapper.writeValue(messagesFile, messages);
    }

    // this method will retrieve data from the JSON file and return a list of
    // messages
    // the issue here is, jackson do not know to what type of objects the list will
    // have
    public List<Message> loadMessages() throws IOException {
        if (!messagesFile.exists()) {
            throw new IOException("messages.json file not found in data directory");
        }
        // this is the key line
        // here we tell jackson that we need an ArrayList containing Message objects
        // !!!!!!!
        // we are telling jackson that the json file is an array (ArrayList) and this
        // array will have objects of type (Message)
        final CollectionType listType = objectMapper.getTypeFactory()
                .constructCollectionType(ArrayList.class, Message.class);
        // this readVale() method needs two informations to function , first the path of
        // the JSON file then an information regarding the types
        // that jackson should use to desirialize
        // its like we are telling jackson to Take this JSON array (messagesFile) and
        // create an ArrayList of Message objects from it.
        final ArrayList<Message> messages = objectMapper.readValue(messagesFile, listType);
        // then we return the messages array
        return messages;
    }

    public void saveMessage(final Message message) throws IOException {
        // we will first load all messages from the messages.json using the Jackson
        // desirializer
        final List<Message> messages = loadMessages();
        // then we will add the new message at the end of the list
        messages.add(message);
        System.out.println("saving message: ");

        // then we serialize and save the new array of messages
        saveMessages(messages);
        System.out.println("Message saved: " + message.getContent());
    }

    /**
     * Met à jour un message existant
     */
    public void updateMessage(final Message updatedMessage) throws IOException {
        final List<Message> messages = loadMessages();
        
        for (int i = 0; i < messages.size(); i++) {
            if (messages.get(i).getId().equals(updatedMessage.getId())) {
                messages.set(i, updatedMessage);
                saveMessages(messages);
                return;
            }
        }
        
        // Si le message n'existe pas, le sauvegarder
        messages.add(updatedMessage);
        saveMessages(messages);
    }
    
    /**
     * Recherche un message par son ID
     */
    public Optional<Message> findById(final String messageId) throws IOException {
        return loadMessages().stream()
                .filter(message -> message.getId().equals(messageId))
                .findFirst();
    }

    // Get all messages for a specific user (both sent and received)
    public List<Message> getUserMessages(final String userEmail) throws IOException {
        return loadMessages().stream()
                .filter(m -> m.getSenderEmail().equals(userEmail) ||
                        m.getReceiverEmail().equals(userEmail))
                .collect(Collectors.toList());
    }

    // Get only messages sent from the user we pass in argument
    public List<Message> getSentMessages(final String userEmail) throws IOException {
        return loadMessages()
                .stream() // here we turn this into a stream
                .filter(m -> m.getSenderEmail().equals(userEmail))
                .collect(Collectors.toList()); // this will gather all sent messages and put them into a List
    }

    // this will get only messages received by a user passed in
    public List<Message> getReceivedMessages(final String userEmail) throws IOException {
        return loadMessages()
                .stream()
                .filter(m -> m.getReceiverEmail().equals(userEmail))
                .collect(Collectors.toList()); // here we tranform a stream back into a usable list
    }

    // Get only unread messages for a user
    public List<Message> getUnreadMessages(final String userEmail) throws IOException {
        return loadMessages()
                .stream()
                .filter(m -> m.getReceiverEmail().equals(userEmail) && !m.isRead())
                .collect(Collectors.toList()); // this will gather all received and unread messages
    }

    // Get conversation between two users
    public List<Message> getConversation(final String user1Email, final String user2Email) throws IOException {
        return loadMessages().stream()
                .filter(m -> (m.getSenderEmail().equals(user1Email) && m.getReceiverEmail().equals(user2Email)) ||
                        (m.getSenderEmail().equals(user2Email) && m.getReceiverEmail().equals(user1Email)))
                .collect(Collectors.toList());
    }

    // Delete a message
    public boolean deleteMessage(final String messageId) throws IOException {
        final List<Message> messages = loadMessages();
        final boolean removed = messages.removeIf(m -> m.getId().equals(messageId));
        if (removed) {
            saveMessages(messages);
            System.out.println("Message " + messageId + " deleted");
        }
        return removed;
    }
}


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/broker/MessageBroker.java
// ============================================

package org.example.broker;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import org.example.model.Message;
import org.example.repository.JsonMessageRepository;

/**
 * Message Broker pour gérer les files d'attente de messages.
 * Seule la file d'attente persiste les messages pour les destinataires
 * hors-ligne.
 */
public class MessageBroker {
    // Instance singleton
    private static MessageBroker instance;

    // Files d'attente par utilisateur (email -> file)
    private final Map<String, MessageQueue> queues;

    // Repository pour persister uniquement les messages non livrés (offline)
    private final JsonMessageRepository messageRepository;

    // Thread de surveillance pour gérer d'éventuels messages expirés
    private final Thread monitorThread;
    private boolean running = true;

    private MessageBroker() {
        this.queues = new ConcurrentHashMap<>();
        this.messageRepository = new JsonMessageRepository();

        // Démarrer le thread de surveillance
        this.monitorThread = new Thread(this::monitorMessages);
        this.monitorThread.setDaemon(true);
        this.monitorThread.start();

        // Charger les messages non lus déjà en file d'attente
        loadUnreadMessages();
    }

    public static synchronized MessageBroker getInstance() {
        if (instance == null) {
            instance = new MessageBroker();
        }
        return instance;
    }

    /**
     * Charge les messages non lus depuis le fichier dans leurs files d'attente
     * respectives.
     */
    private void loadUnreadMessages() {
        try {
            System.out.println("Chargement des messages non lus...");
            final List<Message> allMessages = messageRepository.loadMessages();
            allMessages.stream()
                    .filter(message -> !message.isRead() && "QUEUED".equals(message.getStatus()))
                    .forEach(message -> getOrCreateQueue(message.getReceiverEmail()).addPersistedMessage(message));
            System.out.println("Chargement terminé.");
        } catch (final IOException e) {
            System.err.println("Erreur lors du chargement: " + e.getMessage());
        }
    }

    private MessageQueue getOrCreateQueue(final String userEmail) {
        return queues.computeIfAbsent(userEmail, email -> new MessageQueue(email));
    }

    /**
     * Envoie un message :
     * - Si le destinataire est en ligne, on tente une livraison directe (sans
     * persistance côté serveur).
     * - Sinon, ou en cas d'échec de la livraison directe, on ajoute le message en
     * file d'attente, qui est persistée.
     *
     * @param message                Le message à envoyer
     * @param directDeliveryCallback Callback pour livraison directe, null si
     *                               inexistant.
     * @return true si livré directement, false si mis en file d'attente.
     */
    public boolean sendMessage(final Message message, final Consumer<Message> directDeliveryCallback) {
        // S'assurer que le message possède un ID et timestamp
        if (message.getId() == null || message.getId().isEmpty()) {
            message.setId(java.util.UUID.randomUUID().toString());
        }
        if (message.getTimestamp() == null) {
            message.setTimestamp(LocalDateTime.now());
        }

        // Initialement, le status est "PENDING"
        message.setStatus("PENDING");
        message.setRead(false);

        // Tenter une livraison directe s'il y a un callback
        if (directDeliveryCallback != null) {
            try {
                directDeliveryCallback.accept(message);
                // Si aucun problème, livraison réussie : mettre à jour le status (sans
                // persistance)
                message.setStatus("DELIVERED");
                System.out.println("Message " + message.getId() + " livré directement à " + message.getReceiverEmail());
                return true;
            } catch (final Exception e) {
                System.err.println("Livraison directe échouée: " + e.getMessage());
            }
        }

        // Si la livraison directe n'est pas possible, persister le message avec le
        // statut QUEUED
        message.setStatus("QUEUED");
        try {
            messageRepository.saveMessage(message);
        } catch (final IOException e) {
            System.err.println("Erreur lors de la persistance du message: " + e.getMessage());
            return false;
        }

        // Ajouter le message à la file d'attente après persistance réussie
        final MessageQueue queue = getOrCreateQueue(message.getReceiverEmail());
        queue.addToQueue(message);

        System.out.println("Message " + message.getId() + " mis en file d'attente pour " + message.getReceiverEmail());
        return false;
    }

    /**
     * Enregistre un consommateur pour l'utilisateur et déclenche la livraison des
     * messages en attente.
     */
    public void registerConsumer(final String userEmail, final Consumer<Message> consumer) {
        if (consumer == null) {
            return;
        }
        System.out.println("Enregistrement du consommateur pour " + userEmail);
        final MessageQueue queue = getOrCreateQueue(userEmail);
        queue.clearQueue();
        // Recharger les messages persistés non délivrés pour cet utilisateur
        queue.reloadPersistedMessages();
        // Enregistrer le consommateur et déclencher la livraison
        queue.setConsumer(consumer);
    }

    public void unregisterConsumer(final String userEmail) {
        final MessageQueue queue = queues.get(userEmail);
        if (queue != null) {
            queue.setConsumer(null);
        }
    }

    /**
     * Acquitte un message en le marquant comme lu et en supprimant sa persistance
     * si nécessaire.
     */
    public void acknowledgeMessage(final String messageId) {
        try {
            final var optMsg = messageRepository.findById(messageId);
            if (optMsg.isPresent()) {
                final Message msg = optMsg.get();
                // Si le message n'est pas déjà acquitté, on met à jour son status et on le
                // supprime
                if (!"ACKNOWLEDGED".equals(msg.getStatus())) {
                    msg.setRead(true);
                    msg.setStatus("ACKNOWLEDGED");
                    messageRepository.updateMessage(msg);
                    if (messageRepository.deleteMessage(msg.getId())) {
                        System.out.println("Message " + messageId + " supprimé après acquittement.");
                    }
                }
            } else {
                System.out.println("Message " + messageId + " introuvable (probablement déjà supprimé).");
            }
        } catch (final IOException e) {
            System.err.println("Erreur lors de l'acquittement du message " + messageId + ": " + e.getMessage());
        }
    }

    private void monitorMessages() {
        while (running) {
            try {
                Thread.sleep(5 * 1000);
                queues.values().forEach(MessageQueue::attemptRedelivery);
                checkExpiredMessages();
            } catch (final InterruptedException ie) {
                Thread.currentThread().interrupt();
                break;
            } catch (final Exception e) {
                System.err.println("Erreur dans le moniteur: " + e.getMessage());
            }
        }
    }

    private void checkExpiredMessages() {
        try {
            final List<Message> messages = messageRepository.loadMessages();
            final LocalDateTime threshold = LocalDateTime.now().minusDays(7);
            messages.stream()
                    .filter(m -> ("PENDING".equals(m.getStatus()) || "QUEUED".equals(m.getStatus()))
                            && m.getTimestamp().isBefore(threshold))
                    .forEach(m -> {
                        try {
                            m.setStatus("EXPIRED");
                            messageRepository.updateMessage(m);
                            System.out.println("Message " + m.getId() + " expiré.");
                        } catch (final IOException e) {
                            System.err.println("Erreur lors de l'expiration du message: " + e.getMessage());
                        }
                    });
        } catch (final IOException e) {
            System.err.println("Erreur de vérification des messages expirés: " + e.getMessage());
        }
    }

    public void shutdown() {
        running = false;
        monitorThread.interrupt();
    }

    /**
     * Classe interne gérant la file d'attente d'un utilisateur.
     * Les messages mis en file d'attente sont persistés pour livraison ultérieure.
     */
    private class MessageQueue {
        private final String userEmail;
        private final BlockingQueue<Message> queue;
        private Consumer<Message> consumer;

        public MessageQueue(final String userEmail) {
            this.userEmail = userEmail;
            this.queue = new LinkedBlockingQueue<>();
            System.out.println("File d'attente créée pour " + userEmail);
        }

        public synchronized void setConsumer(final Consumer<Message> consumer) {
            this.consumer = consumer;
            if (consumer != null) {
                deliverQueuedMessages();
            }
        }

        public synchronized void addToQueue(final Message message) {
            queue.offer(message);
            System.out.println("Message " + message.getId() + " ajouté en file pour " + userEmail);
            if (consumer != null) {
                deliverQueuedMessages();
            }
        }

        public synchronized void addPersistedMessage(final Message message) {
            queue.offer(message);
            System.out.println("Message persisté " + message.getId() + " chargé dans la file de " + userEmail);
        }

        /**
         * Vide la file d'attente actuelle
         */
        public synchronized void clearQueue() {
            int size = queue.size();
            if (size > 0) {
                System.out.println("Nettoyage de " + size + " messages en file pour " + userEmail);
                queue.clear();
            }
        }

        public synchronized void reloadPersistedMessages() {
            try {
                final List<Message> pending = messageRepository.loadMessages().stream()
                        .filter(m -> m.getReceiverEmail().equals(userEmail)
                                && "QUEUED".equals(m.getStatus()))
                        .collect(Collectors.toList());
                for (final Message msg : pending) {
                    if (!queue.contains(msg)) {
                        queue.offer(msg);
                        System.out.println("Rechargement du message " + msg.getId() + " pour " + userEmail);
                    }
                }
            } catch (final IOException e) {
                System.err.println("Erreur lors du rechargement des messages pour " + userEmail + ": "
                        + e.getMessage());
            }
        }

        private synchronized void deliverQueuedMessages() {
            if (consumer == null) {
                return;
            }
            while (!queue.isEmpty()) {
                final Message msg = queue.peek();
                try {
                    // Tenter de livrer le message via le callback du consommateur
                    consumer.accept(msg);
                    // Une fois livré, mettre à jour le status
                    msg.setStatus("DELIVERED");
                    messageRepository.updateMessage(msg);
                    // Ne pas supprimer le message ici ; le message sera supprimé lorsqu'il sera
                    // acquitté
                    queue.poll();
                } catch (final Exception e) {
                    System.err.println("Échec de livraison pour " + msg.getId() + ": " + e.getMessage());
                    // Interrompre la boucle afin d'essayer de redélivrer ce message plus tard
                    break;
                }
            }
        }

        public synchronized void attemptRedelivery() {
            if (consumer != null) {
                deliverQueuedMessages();
            }
        }
    }
}

// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/server/ClientHandler.java
// ============================================

package org.example.server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.example.broker.MessageBroker;
import org.example.dto.Credentials;
import org.example.model.Message;
import org.example.service.UserService;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

public class ClientHandler implements Runnable {
    private final Socket clientSocket;
    private String clientEmail;
    private PrintWriter out;
    private BufferedReader in;
    private final ObjectMapper objectMapper;
    private final UserService userService;
    private final MessageBroker messageBroker;
    private boolean isRunning = true;

    // Map to store all online clients (shared between all handlers)
    private static Map<String, ClientHandler> onlineClients = new ConcurrentHashMap<>();

    public ClientHandler(final Socket socket) {
        this.clientSocket = socket;
        this.objectMapper = new ObjectMapper().registerModule(new JavaTimeModule());
        this.userService = new UserService();
        this.messageBroker = MessageBroker.getInstance();

        try {
            this.out = new PrintWriter(socket.getOutputStream(), true);
            this.in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        } catch (final IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        try {
            // Step 1: Handle Authentication
            final String jsonCredentials = in.readLine();
            final Credentials credentials = objectMapper.readValue(jsonCredentials, Credentials.class);

            if (userService.authenticateUser(credentials.getEmail(), credentials.getPassword())) {
                // Authentication successful
                setClientEmail(credentials.getEmail());
                out.println("AUTH_SUCCESS");

                // Enregistrer ce client comme consommateur de messages
                registerAsConsumer();

                // Start handling messages
                handleMessages();
            } else {
                out.println("AUTH_FAILED");
                clientSocket.close();
            }
        } catch (final IOException e) {
            System.out.println("Client disconnected during authentication: " + e.getMessage());
        } finally {
            handleDisconnection();
        }
    }

    private void registerAsConsumer() {
        messageBroker.registerConsumer(clientEmail, message -> {
            try {
                final String jsonMessage = objectMapper.writeValueAsString(message);
                sendMessage(jsonMessage);
                System.out.println("Message envoyé à " + clientEmail + ": " + message.getId());
            } catch (final IOException e) {
                System.err.println("Erreur lors de l'envoi d'un message à " + clientEmail + ": " + e.getMessage());
                throw new RuntimeException("Échec d'envoi du message", e);
            }
        });
    }

    private void handleMessages() {
        try {
            String messageData;
            while (isRunning && (messageData = in.readLine()) != null) {
                try {
                    final Message message = objectMapper.readValue(messageData, Message.class);

                    switch (message.getType()) {
                        case "CHAT":
                            handleChatMessage(message);
                            break;
                        case "ACKNOWLEDGE":
                            handleAcknowledge(message);
                            break;
                        case "LOGOUT":
                            handleLogout();
                            return;
                        default:
                            System.out.println("Unknown message type: " + message.getType());
                    }
                } catch (final IOException e) {
                    System.out.println("Error processing message: " + e.getMessage());
                    sendMessage("{\"type\":\"ERROR\",\"content\":\"Invalid message format\"}");
                }
            }
        } catch (final IOException e) {
            if (isRunning) {
                System.out.println("Client disconnected: " + clientEmail);
            }
        }
    }

    private void handleChatMessage(final Message message) throws IOException {
        // Check if receiver is online
        final ClientHandler receiverHandler = onlineClients.get(message.getReceiverEmail());

        // Utiliser le broker pour envoyer le message
        final boolean delivered = messageBroker.sendMessage(message,
                receiverHandler != null ? msg -> {
                    try {
                        final String jsonMessage = objectMapper.writeValueAsString(msg);
                        receiverHandler.sendMessage(jsonMessage);
                    } catch (final IOException e) {
                        System.err.println("Erreur lors de l'envoi direct du message: " + e.getMessage());
                        throw new RuntimeException("Échec d'envoi du message", e);
                    }
                } : null);

        // Envoyer une confirmation à l'expéditeur
        final Message confirmation = new Message(null, message.getSenderEmail(), null);
        confirmation.setType("CONFIRMATION");
        confirmation.setStatus(delivered ? "DELIVERED" : "QUEUED");
        confirmation.setId(message.getId());
        sendMessage(objectMapper.writeValueAsString(confirmation));
    }

    private void handleAcknowledge(final Message message) {
        // Le client confirme la réception d'un message
        if (message.getId() != null) {
            messageBroker.acknowledgeMessage(message.getId());
        }
    }

    private void handleLogout() {
        try {
            // Envoyer la confirmation de déconnexion
            sendMessage("{\"type\":\"LOGOUT_CONFIRM\"}");
        } catch (final Exception e) {
            System.out.println("Erreur lors de l'envoi du LOGOUT_CONFIRM: " + e.getMessage());
        } finally {
            // Assurer la déconnexion proprement
            handleDisconnection();
        }
    }

    private void handleDisconnection() {
        try {
            if (clientEmail != null) {
                // Désenregistrer ce client comme consommateur de messages et mettre à jour son
                // statut
                messageBroker.unregisterConsumer(clientEmail);
                userService.setUserOnlineStatus(clientEmail, false);
                onlineClients.remove(clientEmail);
                System.out.println("Client déconnecté et retiré: " + clientEmail);
            }
            isRunning = false;
            if (clientSocket != null && !clientSocket.isClosed()) {
                clientSocket.close();
            }
        } catch (final IOException e) {
            System.out.println("Erreur lors de la déconnexion: " + e.getMessage());
        }
    }

    public void sendMessage(final String message) {
        out.println(message);
    }

    public String getClientEmail() {
        return clientEmail;
    }

    public void setClientEmail(final String email) throws IOException {
        this.clientEmail = email;
        onlineClients.put(email, this);
        userService.setUserOnlineStatus(email, true);
        System.out.println("Client registered: " + email);
    }
}

/*
 * ClientHandler Flow Schema:
 * 
 * 1. Client Connection:
 * Client Socket ----connects----> Server Socket
 * │
 * ▼
 * Create ClientHandler
 * │
 * ▼
 * Start Thread
 * 
 * 2. Authentication Flow:
 * Client ----sends credentials----> ClientHandler
 * │
 * ▼
 * Validate User
 * │
 * ┌─────────┴──────────┐
 * ▼ ▼
 * AUTH_SUCCESS AUTH_FAILED
 * │ │
 * ▼ ▼
 * Add to onlineClients Close Connection
 * │
 * ▼
 * Send Offline Messages
 * 
 * 3. Message Handling Flow:
 * a) Sending Message:
 * Client A ----sends message----> ClientHandler A
 * │
 * Save to DB
 * │
 * Check Receiver
 * │
 * ┌─────────────┴────────────┐
 * ▼ ▼
 * Receiver Online Receiver Offline
 * │ │
 * Forward Message Queue Message
 * │ │
 * Send "delivered" Send "queued"
 * to sender to sender
 * 
 * b) Receiving Message:
 * ClientHandler A ----forwards----> ClientHandler B
 * │
 * ▼
 * Send to Client B
 * 
 * 4. Disconnection Flow:
 * Client ----closes/crashes----> ClientHandler
 * │
 * ▼
 * Set User Offline
 * │
 * ▼
 * Remove from onlineClients
 * │
 * ▼
 * Close Socket
 * 
 * Static Data Structure:
 * onlineClients = {
 * "user1@email.com": ClientHandler1,
 * "user2@email.com": ClientHandler2,
 * ...
 * }
 * 
 * Message Types:
 * 1. CHAT: Regular chat message
 * 2. LOGOUT: Client logout request
 * 3. CONFIRMATION: Message delivery status
 * 4. ERROR: Error notifications
 */

// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/server/ChatServer.java
// ============================================

package org.example.server;

import java.net.ServerSocket;
import java.net.Socket;

import org.example.broker.MessageBroker;

public class ChatServer {
    private static final int PORT = 5000;
    public static void main(final String[] args) throws Exception {
        // Initialiser le Message Broker
        MessageBroker.getInstance(); // Précharge les messages non lus
        
        System.out.println("Message Broker initialized");
        
        final ServerSocket server = new ServerSocket(PORT);
        System.out.println("Server started on port " + PORT);
        System.out.println("Waiting for clients...");

        while (true) {
            final Socket client = server.accept();
            // Create a new handler for this client
            final ClientHandler clientHandler = new ClientHandler(client);
            // Start the handler in a new thread
            new Thread(clientHandler).start();
        }
    }
}

// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/model/Message.java
// ============================================

package org.example.model;

import java.time.LocalDateTime;
import java.util.Objects;
import java.util.UUID;

import com.fasterxml.jackson.annotation.JsonProperty;

public class Message {
    private String id; // PK
    private String senderEmail; // FK
    private String receiverEmail; // FK
    private String content;
    private LocalDateTime timestamp; // Creation date !!

    @JsonProperty("read")
    private boolean isRead;
    private String type; // "CHAT", "LOGOUT", etc.
    private String status; // PENDING, QUEUED, DELIVERED, ACKNOWLEDGED, EXPIRED

    // Constructeur par défaut pour Jackson
    public Message() {
        this.id = UUID.randomUUID().toString();
        this.timestamp = LocalDateTime.now();
        this.isRead = false;
        this.status = "PENDING";
    }

    public Message(final String senderEmail, final String receiverEmail, final String content) {
        this();
        this.senderEmail = senderEmail;
        this.receiverEmail = receiverEmail;
        this.content = content;
        this.type = "CHAT";
    }

    // Getters and Setters
    public String getId() {
        return id;
    }

    public void setId(final String id) {
        this.id = id;
    }

    public String getSenderEmail() {
        return senderEmail;
    }

    public void setSenderEmail(final String senderEmail) {
        this.senderEmail = senderEmail;
    }

    public String getReceiverEmail() {
        return receiverEmail;
    }

    public void setReceiverEmail(final String receiverEmail) {
        this.receiverEmail = receiverEmail;
    }

    public String getContent() {
        return content;
    }

    public void setContent(final String content) {
        this.content = content;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(final LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public boolean isRead() {
        return isRead;
    }

    public void setRead(final boolean read) {
        this.isRead = read;
    }

    public String getType() {
        return type;
    }

    public void setType(final String type) {
        this.type = type;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(final String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Message{" +
                "id='" + id + '\'' +
                ", senderEmail='" + senderEmail + '\'' +
                ", receiverEmail='" + receiverEmail + '\'' +
                ", content='"
                + (content != null ? content.substring(0, Math.min(content.length(), 20)) + "..." : "null") + '\'' +
                ", timestamp=" + timestamp +
                ", isRead=" + isRead +
                ", type='" + type + '\'' +
                ", status='" + status + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (!(o instanceof Message))
            return false;
        Message message = (Message) o;
        return Objects.equals(id, message.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/model/User.java
// ============================================

package org.example.model;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonProperty;

public class User {
    private String email;        // PK
    private String displayName;  // user name for display
    private String password;     // hashed password
    
    @JsonProperty("online")
    private boolean isOnline;    // user online status
    
    @JsonProperty("contactEmails")
    private List<String> contacts; // sera mappé depuis "contactEmails" du JSON
    
    // Constructeur par défaut pour Jackson
    public User() {
        this.isOnline = false;
        this.contacts = new ArrayList<>();
    }
    
    public User(final String email, final String displayName, final String password) {
        this();
        this.email = email;
        this.displayName = displayName;
        this.password = password;
    }

    // Getters and Setters
    public String getEmail() {
        return email;
    }

    public void setEmail(final String email) {
        this.email = email;
    }

    public String getDisplayName() {
        return displayName;
    }

    public void setDisplayName(final String displayName) {
        this.displayName = displayName;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(final String password) {
        this.password = password;
    }

    public boolean isOnline() {
        return isOnline;
    }

    public void setOnline(final boolean online) {
        isOnline = online;
    }

    public List<String> getContacts() {
        return contacts;
    }

    public void setContacts(final List<String> contacts) {
        this.contacts = contacts;
    }
    
    public void addContact(final String contactEmail) {
        if (!contacts.contains(contactEmail)) {
            contacts.add(contactEmail);
        }
    }
    
    public boolean removeContact(final String contactEmail) {
        return contacts.remove(contactEmail);
    }

    @Override
    public String toString() {
        return "User{" +
                "email='" + email + '\'' +
                ", displayName='" + displayName + '\'' +
                ", isOnline=" + isOnline +
                ", contactsCount=" + contacts.size() +
                '}';
    }
}


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/service/UserService.java
// ============================================

package org.example.service;

import java.io.IOException;
import java.util.List;
import java.util.Optional;

import org.example.model.User;
import org.example.repository.JsonUserRepository;

public class UserService {
    private final JsonUserRepository userRepository;

    public UserService() {
        this.userRepository = new JsonUserRepository();
    }

    /**
     * Authentifie un utilisateur par email et mot de passe
     */
    public boolean authenticateUser(final String email, final String password) throws IOException {
        final Optional<User> userOpt = userRepository.findByEmail(email);
        if (userOpt.isPresent()) {
            final User user = userOpt.get();
            // Dans une application réelle, utiliser une méthode sécurisée de comparaison de mot de passe
            return user.getPassword().equals(password);
        }
        return false;
    }

    /**
     * Met à jour le statut en ligne d'un utilisateur
     */
    public void setUserOnlineStatus(final String email, final boolean status) throws IOException {
        userRepository.updateUserStatus(email, status);
    }

    /**
     * Récupère un utilisateur par son email
     */
    public Optional<User> getUserByEmail(final String email) throws IOException {
        return userRepository.findByEmail(email);
    }

    /**
     * Récupère la liste de tous les utilisateurs
     */
    public List<User> getAllUsers() throws IOException {
        return userRepository.loadUsers();
    }

    /**
     * Récupère la liste de tous les utilisateurs en ligne
     */
    public List<User> getOnlineUsers() throws IOException {
        return userRepository.loadUsers().stream()
                .filter(User::isOnline)
                .toList();
    }

    /**
     * Crée un nouvel utilisateur
     */
    public boolean createUser(final User user) throws IOException {
        if (userRepository.findByEmail(user.getEmail()).isPresent()) {
            return false; // Utilisateur existe déjà
        }
        userRepository.saveUser(user);
        return true;
    }

    /**
     * Ajoute un contact à un utilisateur
     */
    public boolean addContact(final String userEmail, final String contactEmail) throws IOException {
        final Optional<User> userOpt = userRepository.findByEmail(userEmail);
        final Optional<User> contactOpt = userRepository.findByEmail(contactEmail);
        
        if (userOpt.isPresent() && contactOpt.isPresent()) {
            final User user = userOpt.get();
            user.addContact(contactEmail);
            userRepository.saveUser(user);
            return true;
        }
        return false;
    }
    
    /**
     * Supprime un contact d'un utilisateur
     */
    public boolean removeContact(final String userEmail, final String contactEmail) throws IOException {
        final Optional<User> userOpt = userRepository.findByEmail(userEmail);
        
        if (userOpt.isPresent()) {
            final User user = userOpt.get();
            final boolean removed = user.removeContact(contactEmail);
            if (removed) {
                userRepository.saveUser(user);
                return true;
            }
        }
        return false;
    }
}


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/service/ChatService.java
// ============================================

package org.example.service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ConnectException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

import org.example.dto.Credentials;
import org.example.model.Message;
import org.example.repository.JsonMessageRepository;
import org.example.repository.JsonUserRepository;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

public class ChatService {
    private static final String SERVER_ADDRESS = "localhost";
    private static final int SERVER_PORT = 5000;

    private Socket socket;
    private PrintWriter out;
    private BufferedReader in;
    private String userEmail;
    private final ObjectMapper objectMapper;
    private Consumer<Message> messageConsumer;
    private final JsonMessageRepository messageRepository;

    private Thread listenerThread;
    private boolean isRunning = false;

    public ChatService() {
        this.objectMapper = new ObjectMapper().registerModule(new JavaTimeModule());
        this.messageRepository = new JsonMessageRepository();
    }

    public boolean connect(final Credentials credentials) throws IOException {
        try {
            // Se connecter au serveur
            System.out.println("Tentative de connexion au serveur " + SERVER_ADDRESS + ":" + SERVER_PORT);
            socket = new Socket(SERVER_ADDRESS, SERVER_PORT);
            out = new PrintWriter(socket.getOutputStream(), true);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            // Envoyer les identifiants
            final String jsonCredentials = objectMapper.writeValueAsString(credentials);
            out.println(jsonCredentials);

            // Attendre la réponse du serveur
            final String response = in.readLine();
            final boolean success = "AUTH_SUCCESS".equals(response);

            if (success) {
                this.userEmail = credentials.getEmail();
                startMessageListener();
                System.out.println("Authentification réussie pour " + userEmail);
            } else {
                System.out.println("Échec de l'authentification");
                disconnect();
            }

            return success;
        } catch (final ConnectException e) {
            throw new IOException(
                    "Impossible de se connecter au serveur. Assurez-vous que le serveur est démarré et accessible sur "
                            + SERVER_ADDRESS + ":" + SERVER_PORT,
                    e);
        } catch (final Exception e) {
            throw new IOException("Erreur lors de la connexion au serveur: " + e.getMessage(), e);
        }
    }

    public void disconnect() throws IOException {
        isRunning = false;

        if (out != null)
            out.close();
        if (in != null)
            in.close();
        if (socket != null)
            socket.close();

        userEmail = null;
    }

    public boolean sendMessage(final Message message) throws IOException {
        if (socket == null || socket.isClosed() || out == null) {
            throw new IOException("Non connecté au serveur");
        }

        message.setType("CHAT");
        final String jsonMessage = objectMapper.writeValueAsString(message);
        out.println(jsonMessage);

        // Idéalement, on attendrait une confirmation du serveur ici
        return true;
    }
    
    /**
     * Acquitte la réception d'un message
     */
    public void acknowledgeMessage(final String messageId) throws IOException {
        if (socket == null || socket.isClosed() || out == null) {
            throw new IOException("Non connecté au serveur");
        }
        
        final Message ackMessage = new Message();
        ackMessage.setType("ACKNOWLEDGE");
        ackMessage.setId(messageId);
        ackMessage.setSenderEmail(userEmail);
        
        final String jsonMessage = objectMapper.writeValueAsString(ackMessage);
        out.println(jsonMessage);
    }

    public List<String> getContacts(final String userEmail) throws IOException {
        // Pour cet exemple, on utilisera directement le JsonUserRepository
        final JsonUserRepository userRepo = new JsonUserRepository();
        final List<String> contactEmails = new ArrayList<>();

        userRepo.loadUsers().forEach(user -> {
            // Pour simplifier, on considère que tous les autres utilisateurs sont des
            // contacts
            if (!user.getEmail().equals(userEmail)) {
                contactEmails.add(user.getEmail());
            }
        });

        return contactEmails;
    }

    public boolean addContact(final String userEmail, final String contactEmail) throws IOException {
        // Cette fonctionnalité nécessiterait d'étendre l'API du serveur
        // Pour l'instant, on simule un succès si le contact existe
        final JsonUserRepository userRepo = new JsonUserRepository();
        return userRepo.findByEmail(contactEmail).isPresent();
    }

    public List<Message> getConversation(final String user1Email, final String user2Email) throws IOException {
        // Utiliser la méthode du repository pour récupérer la conversation réelle
        return messageRepository.getConversation(user1Email, user2Email);
    }

    public void setMessageConsumer(final Consumer<Message> consumer) {
        this.messageConsumer = consumer;
    }

    private void startMessageListener() {
        isRunning = true;

        listenerThread = new Thread(() -> {
            try {
                String jsonMessage;
                while (isRunning && (jsonMessage = in.readLine()) != null) {
                    try {
                        final Message message = objectMapper.readValue(jsonMessage, Message.class);

                        if ("LOGOUT_CONFIRM".equals(message.getType())) {
                            break;
                        }

                        if ("CHAT".equals(message.getType())) {
                            // Acquitter automatiquement la réception du message
                            acknowledgeMessage(message.getId());
                            
                            // Transmettre le message au consommateur
                            if (messageConsumer != null) {
                                messageConsumer.accept(message);
                            }
                        }
                    } catch (final Exception e) {
                        System.err.println("Erreur lors du traitement du message: " + e.getMessage());
                    }
                }
            } catch (final IOException e) {
                if (isRunning) {
                    System.err.println("Connexion perdue: " + e.getMessage());
                }
            } finally {
                isRunning = false;
            }
        });

        listenerThread.setDaemon(true);
        listenerThread.start();
    }
}


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/service/MessageService.java
// ============================================

package org.example.service;

import java.io.IOException;
import java.util.List;

import org.example.broker.MessageBroker;
import org.example.model.Message;
import org.example.repository.JsonMessageRepository;
import org.example.repository.JsonUserRepository;

public class MessageService {
    private final JsonMessageRepository messageRepository;
    private final JsonUserRepository userRepository;
    private final MessageBroker messageBroker;

    public MessageService() {
        this.messageRepository = new JsonMessageRepository();
        this.userRepository = new JsonUserRepository();
        this.messageBroker = MessageBroker.getInstance();
    }

    public boolean sendMessage(final Message message) throws IOException {
        // Vérifier que l'expéditeur et le destinataire existent
        if (userRepository.findByEmail(message.getSenderEmail()).isEmpty() || 
            userRepository.findByEmail(message.getReceiverEmail()).isEmpty()) {
            return false;
        }
        
        // Le Message Broker gère la persistance et la mise en file d'attente
        // Nous passons null ici car la décision d'envoyer le message directement
        // est déjà prise au niveau du ClientHandler
        messageBroker.sendMessage(message, null);
        return true;
    }

    public List<Message> getUnreadMessages(final String userEmail) throws IOException {
        return messageRepository.getUnreadMessages(userEmail);
    }
}


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/client/repository/JsonLocalMessageRepository.java
// ============================================

package org.example.client.repository;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

import org.example.model.Message;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

/**
 * Classe de persistance locale pour l'historique des messages d'un utilisateur.
 * L'historique est stocké sous forme de fichier JSON dans le dossier "src/main/client_data".
 */
public class JsonLocalMessageRepository {
    // Utilisation du répertoire de projet pour stocker les données clients
    private static final String LOCAL_FOLDER = System.getProperty("user.dir")
            + File.separator + "src" + File.separator + "main" + File.separator + "client_data";
    private final ObjectMapper objectMapper;

    public JsonLocalMessageRepository() {
        this.objectMapper = new ObjectMapper();
        this.objectMapper.registerModule(new JavaTimeModule());
        this.objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        ensureLocalFolderExists();
    }

    private void ensureLocalFolderExists() {
        final Path folderPath = Paths.get(LOCAL_FOLDER);
        if (!Files.exists(folderPath)) {
            try {
                Files.createDirectories(folderPath);
            } catch (final IOException e) {
                System.err.println("Erreur lors de la création du dossier client_data : " + e.getMessage());
            }
        }
    }

    /**
     * Renvoie le chemin complet du fichier de l'utilisateur.
     */
    private String getUserFilePath(final String userEmail) {
        // Remplacer les caractères spéciaux pour créer un nom de fichier valide
        final String fileName = userEmail.replaceAll("[^a-zA-Z0-9]", "_") + "_messages.json";
        return LOCAL_FOLDER + File.separator + fileName;
    }

    /**
     * Charge la liste des messages locaux pour l'utilisateur.
     */
    public List<Message> loadLocalMessages(final String userEmail) throws IOException {
        final String filePath = getUserFilePath(userEmail);
        final File file = new File(filePath);
        if (!file.exists()) {
            return new ArrayList<>();
        }
        final CollectionType listType = objectMapper.getTypeFactory()
                .constructCollectionType(ArrayList.class, Message.class);
        return objectMapper.readValue(file, listType);
    }

    /**
     * Enregistre la liste des messages locaux pour l'utilisateur.
     */
    public void saveLocalMessages(final String userEmail, final List<Message> messages) throws IOException {
        final String filePath = getUserFilePath(userEmail);
        objectMapper.writeValue(new File(filePath), messages);
    }

    /**
     * Ajoute un nouveau message dans l'historique local pour l'utilisateur.
     */
    public void addLocalMessage(final String userEmail, final Message message) throws IOException {
        final List<Message> messages = loadLocalMessages(userEmail);
        messages.add(message);
        saveLocalMessages(userEmail, messages);
    }
}

// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/client/cli/ClientTCP.java
// ============================================

package org.example.client.cli;

import java.io.*;
import java.net.*;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicBoolean;

import org.example.dto.Credentials;
import org.example.model.Message;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

public class ClientTCP {
    private static final String ADRESSE_SERVEUR = "localhost";
    private static final int PORT = 5000;
    private static final ObjectMapper objectMapper = new ObjectMapper()
        .registerModule(new JavaTimeModule());
    private static Socket socket;
    private static PrintWriter envoyeur;
    private static BufferedReader recepteur;
    private static String currentUserEmail; // Store authenticated user's email
  private static AtomicBoolean isRunning = new AtomicBoolean(true);
    public static void main(String[] args) {
        try {
            // Initialize connection
            socket = new Socket(ADRESSE_SERVEUR, PORT);
            envoyeur = new PrintWriter(socket.getOutputStream(), true);
            recepteur = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            
            // Get user credentials
            Scanner scanner = new Scanner(System.in);
            System.out.println("\n🔐 Login");
            System.out.println("─────────────────");
            System.out.print("Email: ");
            String email = scanner.nextLine();
            System.out.print("Password: ");
            String password = scanner.nextLine();

            // Attempt authentication
            if (authenticate(email, password)) {
                System.out.println("\n✅ Authentication successful!");
                currentUserEmail = email; // Store email for later use

                // Start message listener thread
                startMessageListener();

                // Start main session
                handleUserSession(scanner);
            } else {
                System.out.println("\n❌ Authentication failed!");
            }

        } catch (IOException e) {
            System.out.println("❌ Connection error: " + e.getMessage());
        } finally {
            cleanup();
        }
    }

    private static void startMessageListener() {
        Thread messageListener = new Thread(() -> {
            try {
                String incomingMessage;
                while (isRunning.get() && (incomingMessage = recepteur.readLine()) != null) {
                    handleIncomingMessage(incomingMessage);
                }
            } catch (IOException e) {
                if (isRunning.get()) {
                    System.out.println("\n❌ Lost connection to server!");
                }
            }
        });
        messageListener.setDaemon(true);
        messageListener.start();
    }

    private static void handleIncomingMessage(String jsonMessage) {
        try {
            Message message = objectMapper.readValue(jsonMessage, Message.class);
            switch (message.getType()) {
                case "CHAT":
                    System.out.println("\n📨 Message from " + message.getSenderEmail() + ":");
                    System.out.println("   " + message.getContent());
                    printPrompt();
                    break;
                case "CONFIRMATION":
                    String status = message.getStatus();
                    if ("delivered".equals(status)) {
                        System.out.println("\n✓ Message delivered");
                    } else if ("queued".equals(status)) {
                        System.out.println("\n⏳ Message queued (recipient offline)");
                    }
                    printPrompt();
                    break;
                case "ERROR":
                    System.out.println("\n❌ Error: " + message.getContent());
                    printPrompt();
                    break;
                case "LOGOUT_CONFIRM":
                    isRunning.set(false);
                    break;
            }
        } catch (IOException e) {
            System.out.println("\n❌ Error processing message: " + e.getMessage());
            printPrompt();
        }
    }


    private static void handleUserSession(Scanner scanner) {
        while (isRunning.get()) {
            printMenu();
            String choice = scanner.nextLine();

            switch (choice) {
                case "1":
                    sendMessage(scanner);
                    break;
                case "2":
                    logout();
                    return;
                default:
                    System.out.println("\n❌ Invalid choice. Please try again.");
            }
        }
    }

    private static void sendMessage(Scanner scanner) {
        try {
            System.out.println("\n✍️ New Message");
            System.out.println("─────────────────");
            System.out.print("To (email): ");
            String receiverEmail = scanner.nextLine();
            
            if (receiverEmail.equalsIgnoreCase("back")) return;

            System.out.print("Message: ");
            String content = scanner.nextLine();
            
            if (content.equalsIgnoreCase("back")) return;

            Message message = new Message(currentUserEmail, receiverEmail, content);
            message.setType("CHAT");
            
            String jsonMessage = objectMapper.writeValueAsString(message);
            envoyeur.println(jsonMessage);
            System.out.println("\n📤 Sending message...");
            
        } catch (IOException e) {
            System.out.println("\n❌ Error sending message: " + e.getMessage());
        }
    }

   
    private static boolean authenticate(String email, String password) throws IOException {
        // Create credentials object
        Credentials credentials = new Credentials(email, password);
        
        // Convert to JSON and send
        String jsonCredentials = objectMapper.writeValueAsString(credentials);
        envoyeur.println(jsonCredentials);
        
        // Wait for server response
        String response = recepteur.readLine();
        return "AUTH_SUCCESS".equals(response);
    }

    private static void logout() {
        try {
            Message logoutMsg = new Message(currentUserEmail, null, null);
            logoutMsg.setType("LOGOUT");
            envoyeur.println(objectMapper.writeValueAsString(logoutMsg));
            System.out.println("\n👋 Logging out...");
        } catch (IOException e) {
            System.out.println("\n❌ Error during logout: " + e.getMessage());
        }
    }

    private static void cleanup() {
        try {
            isRunning.set(false);
            if (socket != null && !socket.isClosed()) {
                socket.close();
            }
        } catch (IOException e) {
            System.out.println("Error during cleanup: " + e.getMessage());
        }
    }

    private static void printMenu() {
        System.out.println("\n📱 Chat Menu");
        System.out.println("─────────────────");
        System.out.println("1. Send message");
        System.out.println("2. Logout");
        System.out.print("\nChoice (1-2): ");
    }

    private static void printPrompt() {
        System.out.print("\nChoice (1-2): ");
    }
}


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/client/gui/Launcher.java
// ============================================

package org.example.client.gui;

/**
 * Classe de lancement pour l'application JavaFX.
 * Cette classe sert de point d'entrée principal pour éviter les problèmes
 * de modules JavaFX lors de l'exécution à partir d'un JAR.
 */
public class Launcher {
    /**
     * Point d'entrée principal de l'application.
     * @param args Arguments de ligne de commande
     */
    public static void main(final String[] args) {
        // Lance l'application JavaFX
        ChatClientApplication.main(args);
    }
}


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/client/gui/controllers/ChatController.java
// ============================================

package org.example.client.gui.controllers;

import java.io.IOException;
import java.time.format.DateTimeFormatter;
import java.util.List;

import org.example.client.repository.JsonLocalMessageRepository;
import org.example.model.Message;
import org.example.service.ChatService;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class ChatController {
    @FXML
    private Label userEmailLabel;
    
    @FXML
    private ListView<String> contactListView;
    
    @FXML
    private TextField newContactField;
    
    @FXML
    private VBox chatHistoryContainer;
    
    @FXML
    private TextField messageField;
    
    @FXML
    private Label statusLabel;
    
    private ChatService chatService;
    private String userEmail;
    private String selectedContact;
    
    private final ObservableList<String> contacts = FXCollections.observableArrayList();
    private static final DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm");
    private final JsonLocalMessageRepository localRepo = new JsonLocalMessageRepository();
    
    @FXML
    public void initialize() {
        contactListView.setItems(contacts);
        
        // Configurer le clic sur un contact
        contactListView.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                selectedContact = newVal;
                loadConversation(selectedContact);
                setStatus("Conversation chargée avec " + selectedContact);
            }
        });
        
        // Permettre d'envoyer un message avec la touche Entrée
        messageField.setOnAction(this::handleSendMessage);
    }
    
    public void initData(final ChatService chatService, final String userEmail) {
        this.chatService = chatService;
        this.userEmail = userEmail;
        this.userEmailLabel.setText(userEmail);
        
        // Configurer le Consumer pour recevoir les messages
        chatService.setMessageConsumer(this::handleIncomingMessage);
        
        // Charger les contacts
        loadContacts();
    }
    
    @FXML
    private void handleSendMessage(final ActionEvent event) {
        final String content = messageField.getText().trim();
        
        if (content.isEmpty() || selectedContact == null) {
            return;
        }
        
        try {
            final Message message = new Message(userEmail, selectedContact, content);
            chatService.sendMessage(message);
            messageField.clear();
            
            // Ajouter le message à la conversation
            addMessageToChat(message);
            setStatus("Message envoyé");
            localRepo.addLocalMessage(userEmail, message);
        } catch (final IOException e) {
            setStatus("Erreur lors de l'envoi du message: " + e.getMessage());
        }
    }
    
    @FXML
    private void handleAddContact() {
        final String email = newContactField.getText().trim();
        
        if (email.isEmpty()) {
            setStatus("Veuillez saisir un email");
            return;
        }
        
        try {
            final boolean added = chatService.addContact(userEmail, email);
            if (added) {
                contacts.add(email);
                newContactField.clear();
                setStatus("Contact ajouté: " + email);
            } else {
                setStatus("Impossible d'ajouter ce contact");
            }
        } catch (final IOException e) {
            setStatus("Erreur: " + e.getMessage());
        }
    }
    
    @FXML
    private void handleLogout() {
        try {
            chatService.disconnect();
            
            // Revenir à l'écran de connexion
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            final Parent loginView = loader.load();
            
            final Stage stage = (Stage) userEmailLabel.getScene().getWindow();
            stage.setTitle("Chat Application");
            stage.setScene(new Scene(loginView, 600, 400));
            stage.centerOnScreen();
        } catch (final IOException e) {
            setStatus("Erreur lors de la déconnexion: " + e.getMessage());
        }
    }
    
    private void loadContacts() {
        try {
            final List<String> contactList = chatService.getContacts(userEmail);
            Platform.runLater(() -> {
                contacts.clear();
                contacts.addAll(contactList);
                
                // Sélectionner automatiquement le premier contact
                if (!contacts.isEmpty()) {
                    contactListView.getSelectionModel().select(0);
                }
            });
        } catch (final IOException e) {
            setStatus("Erreur lors du chargement des contacts: " + e.getMessage());
        }
    }
    
    private void loadConversation(final String contactEmail) {
        chatHistoryContainer.getChildren().clear();

        // Charger l'historique local
        try {
            final List<Message> localMessages = localRepo.loadLocalMessages(userEmail);
            // Filtrer uniquement les messages correspondant à la conversation
            localMessages.stream()
                .filter(m -> (m.getSenderEmail().equals(userEmail) && m.getReceiverEmail().equals(contactEmail)) ||
                             (m.getSenderEmail().equals(contactEmail) && m.getReceiverEmail().equals(userEmail)))
                .forEach(this::addMessageToChat);
        } catch (final IOException e) {
            setStatus("Erreur lors du chargement de l'historique local : " + e.getMessage());
        }

        // Optionnel : vous pouvez également synchroniser avec le serveur pour mettre à jour l'historique
    }
    
    private void handleIncomingMessage(final Message message) {
        Platform.runLater(() -> {
            // Si le message concerne la conversation actuelle, l'afficher
            if (selectedContact != null && 
                (message.getSenderEmail().equals(selectedContact) || 
                 message.getReceiverEmail().equals(selectedContact))) {
                addMessageToChat(message);
            }
            
            // Enregistrer localement le message pour avoir un historique hors ligne
            try {
                localRepo.addLocalMessage(userEmail, message);
            } catch (final IOException e) {
                System.err.println("Erreur de sauvegarde locale : " + e.getMessage());
            }
            
            // Mise à jour des contacts si nécessaire
            final String otherUser = message.getSenderEmail().equals(userEmail) ? 
                               message.getReceiverEmail() : message.getSenderEmail();
            if (!contacts.contains(otherUser)) {
                contacts.add(otherUser);
            }
            
            setStatus("Nouveau message reçu");
        });
    }
    
    private void addMessageToChat(final Message message) {
        final boolean isMine = message.getSenderEmail().equals(userEmail);
        
        // Créer une boîte pour le message
        final HBox messageBox = new HBox();
        messageBox.setMaxWidth(chatHistoryContainer.getWidth() * 0.8);
        messageBox.setPadding(new Insets(5));
        messageBox.setAlignment(isMine ? Pos.CENTER_RIGHT : Pos.CENTER_LEFT);
        
        // Contenu du message
        final VBox messageContent = new VBox();
        messageContent.setMaxWidth(chatHistoryContainer.getWidth() * 0.7);
        messageContent.setPadding(new Insets(10));
        messageContent.setStyle("-fx-background-color: " + (isMine ? "#DCF8C6" : "#E1E1E1") + ";" +
                               "-fx-background-radius: 10;");
        
        final Label contentLabel = new Label(message.getContent());
        contentLabel.setWrapText(true);
        
        // Afficher l'heure et le status du message
        final String statusDisplay = message.getTimestamp().format(timeFormatter)
                                + " - " + (message.getStatus() != null ? message.getStatus() : "N/A");
        final Label statusLabel = new Label(statusDisplay);
        statusLabel.setTextFill(Color.GRAY);
        
        messageContent.getChildren().addAll(contentLabel, statusLabel);
        messageBox.getChildren().add(messageContent);
        
        // Ajouter le message à l'historique
        Platform.runLater(() -> {
            chatHistoryContainer.getChildren().add(messageBox);
            // Faire défiler vers le bas pour voir le nouveau message
            chatHistoryContainer.heightProperty().addListener(observable -> 
                chatHistoryContainer.layout());
        });
    }
    
    private void setStatus(final String status) {
        Platform.runLater(() -> statusLabel.setText(status));
    }
}

// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/client/gui/controllers/LoginController.java
// ============================================

package org.example.client.gui.controllers;

import java.io.IOException;

import org.example.dto.Credentials;
import org.example.service.ChatService;

import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.stage.Stage;

public class LoginController {

    @FXML
    private TextField emailField;
    
    @FXML
    private PasswordField passwordField;
    
    @FXML
    private Button loginButton;
    
    private final ChatService chatService;
    
    public LoginController() {
        this.chatService = new ChatService();
    }
    
    @FXML
    public void initialize() {
        // Activer le bouton de connexion seulement si des valeurs sont entrées
        loginButton.disableProperty().bind(
            emailField.textProperty().isEmpty().or(
            passwordField.textProperty().isEmpty())
        );
    }
    
    @FXML
    private void handleLogin(final ActionEvent event) {
        final String email = emailField.getText().trim();
        final String password = passwordField.getText();
        
        // Débinder la propriété disable avant de la modifier
        loginButton.disableProperty().unbind();
        loginButton.setDisable(true); // Désactiver le bouton

        new Thread(() -> {
            try {
                final Credentials credentials = new Credentials(email, password);
                final boolean success = chatService.connect(credentials);
                
                Platform.runLater(() -> {
                    if (success) {
                        try {
                            openChatWindow(email);
                        } catch (final IOException e) {
                            showError("Erreur d'interface", "Impossible d'ouvrir la fenêtre de chat: " + e.getMessage());
                            rebindLoginButton();
                        }
                    } else {
                        showError("Échec de connexion", "Email ou mot de passe incorrect");
                        rebindLoginButton();
                    }
                });
            } catch (final IOException e) {
                Platform.runLater(() -> {
                    showError("Erreur de connexion", "Impossible de se connecter au serveur: " + e.getMessage());
                    rebindLoginButton();
                });
            }
        }).start();
    }
    
    /**
     * Rétablit le binding du bouton de login
     */
    private void rebindLoginButton() {
        loginButton.disableProperty().unbind(); // S'assurer qu'il n'y a pas de binding actif
        loginButton.setDisable(false); // Réactiver le bouton
        // Rebinder le bouton avec la condition initiale
        loginButton.disableProperty().bind(
            emailField.textProperty().isEmpty().or(
            passwordField.textProperty().isEmpty())
        );
    }
    
    private void openChatWindow(final String userEmail) throws IOException {
        // Charger la vue de chat
        final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/chat.fxml"));
        final Parent chatView = loader.load();
        
        // Configurer le contrôleur de chat
        final ChatController chatController = loader.getController();
        chatController.initData(chatService, userEmail);
        
        // Créer et afficher la nouvelle scène
        final Scene chatScene = new Scene(chatView, 800, 600);
        final Stage currentStage = (Stage) loginButton.getScene().getWindow();
        
        currentStage.setTitle("Chat - " + userEmail);
        currentStage.setScene(chatScene);
        currentStage.setMinWidth(800);
        currentStage.setMinHeight(600);
        currentStage.centerOnScreen();
    }
    
    private void showError(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}


// ============================================
// FICHIER: /Users/youns/Desktop/sockets/sockets-java-chat-app/src/main/java/org/example/client/gui/ChatClientApplication.java
// ============================================

package org.example.client.gui;

import java.io.IOException;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.stage.Stage;

public class ChatClientApplication extends Application {

    @Override
    public void start(final Stage primaryStage) {
        try {
            // Vérification que les ressources FXML peuvent être chargées
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            final Parent root = loader.load();
            
            primaryStage.setTitle("Chat Application");
            primaryStage.setScene(new Scene(root, 600, 400));
            primaryStage.setMinWidth(600);
            primaryStage.setMinHeight(400);
            primaryStage.show();
        } catch (final IOException e) {
            showErrorAndExit("Erreur de chargement FXML", 
                    "Impossible de charger l'interface utilisateur: " + e.getMessage());
        } catch (final Exception e) {
            showErrorAndExit("Erreur d'initialisation", 
                    "L'application n'a pas pu démarrer correctement: " + e.getMessage());
        }
    }

    /**
     * Affiche une erreur et quitte l'application
     */
    private void showErrorAndExit(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText("Erreur critique");
        alert.setContentText(message);
        alert.showAndWait();
        Platform.exit();
    }

    public static void main(final String[] args) {
        try {
            launch(args);
        } catch (final Exception e) {
            System.err.println("Erreur lors du lancement de l'application JavaFX:");
            System.err.println("Cette erreur peut être due à l'absence de modules JavaFX.");
            System.err.println("Veuillez lancer l'application avec les arguments VM suivants:");
            System.err.println("--module-path <chemin/vers/javafx-sdk>/lib --add-modules javafx.controls,javafx.fxml");
            e.printStackTrace();
        }
    }
    
    @Override
    public void stop() {
        // Nettoyage des ressources lors de la fermeture de l'application
        System.out.println("Application fermée");
    }
}
