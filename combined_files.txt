// File: src/main/java/org/example/client/exception/PublicKeyNotAvailableException.java
package org.example.client.exception;

/**
 * Exception lev√©e lorsque la cl√© publique d'un destinataire n'est pas
 * disponible localement et qu'une demande a √©t√© envoy√©e au serveur.
 * L'op√©ration (par ex. envoi de message) doit √™tre retent√©e ult√©rieurement.
 */
public class PublicKeyNotAvailableException extends Exception {
    public PublicKeyNotAvailableException(final String message) {
        super(message);
    }
}



// File: src/main/java/org/example/client/gui/ChatClientApplication.java
package org.example.client.gui;

import java.io.IOException;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.stage.Stage;

public class ChatClientApplication extends Application {

    @Override
    public void start(final Stage primaryStage) {
        try {
            // V√©rification que les ressources FXML peuvent √™tre charg√©es
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            final Parent root = loader.load();
            
            primaryStage.setTitle("Chat Application");
            primaryStage.setScene(new Scene(root, 600, 400));
            primaryStage.setMinWidth(600);
            primaryStage.setMinHeight(400);
            primaryStage.show();
        } catch (final IOException e) {
            showErrorAndExit("Erreur de chargement FXML", 
                    "Impossible de charger l'interface utilisateur: " + e.getMessage());
        } catch (final Exception e) {
            showErrorAndExit("Erreur d'initialisation", 
                    "L'application n'a pas pu d√©marrer correctement: " + e.getMessage());
        }
    }

    /**
     * Affiche une erreur et quitte l'application
     */
    private void showErrorAndExit(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText("Erreur critique");
        alert.setContentText(message);
        alert.showAndWait();
        Platform.exit();
    }

    public static void main(final String[] args) {
        try {
            launch(args);
        } catch (final Exception e) {
            System.err.println("Erreur lors du lancement de l'application JavaFX:");
            System.err.println("Cette erreur peut √™tre due √† l'absence de modules JavaFX.");
            System.err.println("Veuillez lancer l'application avec les arguments VM suivants:");
            System.err.println("--module-path <chemin/vers/javafx-sdk>/lib --add-modules javafx.controls,javafx.fxml");
            e.printStackTrace();
        }
    }
    
    @Override
    public void stop() {
        // Nettoyage des ressources lors de la fermeture de l'application
        System.out.println("Application ferm√©e");
    }
}



// File: src/main/java/org/example/client/gui/controllers/CallDialogController.java
package org.example.client.gui.controllers;

import java.net.URL;
import java.util.ResourceBundle;

import org.example.client.gui.service.CallManager;
import org.example.shared.model.CallSession;
import org.example.shared.model.User;

import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.stage.Stage;

/**
 * Contr√¥leur pour la fen√™tre de dialogue d'appel entrant.
 */
public class CallDialogController implements Initializable {
    
    @FXML private Label callerNameLabel;
    @FXML private Label callStatusLabel;
    @FXML private Button acceptButton;
    @FXML private Button rejectButton;
    
    private CallSession callSession;
    private User caller;
    private String callerIp;
    private int callerPort;
    private Runnable onAcceptCallback;
    private Runnable onRejectCallback;
    
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        // Rien √† initialiser ici
    }
    
    /**
     * Initialise le dialogue avec les informations d'appel.
     * 
     * @param session La session d'appel
     * @param caller L'utilisateur qui appelle
     * @param callerIp L'adresse IP de l'appelant
     * @param callerPort Le port UDP de l'appelant
     * @param onAccept Callback √† ex√©cuter si l'appel est accept√©
     * @param onReject Callback √† ex√©cuter si l'appel est rejet√©
     */
    public void initData(CallSession session, User caller, String callerIp, int callerPort, 
                         Runnable onAccept, Runnable onReject) {
        this.callSession = session;
        this.caller = caller;
        this.callerIp = callerIp;
        this.callerPort = callerPort;
        this.onAcceptCallback = onAccept;
        this.onRejectCallback = onReject;
        
        // Mettre √† jour l'interface utilisateur
        Platform.runLater(() -> {
            callerNameLabel.setText("Appel de " + caller.getDisplayNameOrEmail());
        });
    }
    
    /**
     * G√®re l'acceptation de l'appel.
     */
    @FXML
    private void handleAcceptCall(ActionEvent event) {
        // Mettre √† jour l'interface utilisateur
        acceptButton.setDisable(true);
        rejectButton.setDisable(true);
        callStatusLabel.setText("Connexion en cours...");
        
        // Accepter l'appel via le CallManager
        CallManager.getInstance().acceptCall(callSession, callerIp, callerPort);
        
        // Ex√©cuter le callback d'acceptation
        if (onAcceptCallback != null) {
            onAcceptCallback.run();
        }
        
        // Fermer la fen√™tre
        closeDialog();
    }
    
    /**
     * G√®re le rejet de l'appel.
     */
    @FXML
    private void handleRejectCall(ActionEvent event) {
        // Mettre √† jour l'interface utilisateur
        acceptButton.setDisable(true);
        rejectButton.setDisable(true);
        callStatusLabel.setText("Appel refus√©");
        
        // Ex√©cuter le callback de rejet
        if (onRejectCallback != null) {
            onRejectCallback.run();
        }
        
        // Fermer la fen√™tre
        closeDialog();
    }
    
    /**
     * Ferme la fen√™tre de dialogue.
     */
    private void closeDialog() {
        Platform.runLater(() -> {
            Stage stage = (Stage) acceptButton.getScene().getWindow();
            stage.close();
        });
    }
}



// File: src/main/java/org/example/client/gui/controllers/ChatController.java
package org.example.client.gui.controllers;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import javax.sound.sampled.LineUnavailableException;

import org.example.client.exception.PublicKeyNotAvailableException;
import org.example.client.gui.repository.JsonLocalMessageRepository;
import org.example.client.gui.security.KeyManager;
import org.example.client.gui.service.AudioRecorderService;
import org.example.client.gui.service.CallManager;
import org.example.client.gui.service.ChatService;
import org.example.client.gui.service.ContactService;
import org.example.client.gui.service.FileService;
import org.example.client.gui.service.GroupService;
import org.example.client.gui.service.UserService;
import org.example.shared.model.CallSession;
import org.example.shared.model.CallSignal;
import org.example.shared.model.Group;
import org.example.shared.model.Message;
import org.example.shared.model.User;
import org.example.shared.model.enums.MessageType;

import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.MenuItem;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextField;
import javafx.scene.control.ToggleButton;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import javafx.scene.media.MediaView;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.stage.FileChooser;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class ChatController {
    @FXML
    private Label userEmailLabel;
    @FXML
    private ListView<User> contactListView;
    @FXML
    private ListView<Group> groupListView;
    @FXML
    private TextField newContactField, messageField, groupNameField, memberEmailField;
    @FXML
    private VBox chatHistoryContainer;
    @FXML
    private ScrollPane chatScrollPane;
    @FXML
    private Label statusLabel;
    @FXML
    private Button mediaButton;
    @FXML
    private Button audioRecordButton;
    @FXML
    private HBox attachmentPreviewContainer;
    @FXML
    private Label attachmentNameLabel;
    @FXML
    private HBox recordingIndicatorContainer;
    @FXML
    private Label recordingTimeLabel;

    @FXML
    private Button mediaGalleryButton;

    @FXML
    private Label groupMembersLabel;

    // √âl√©ments d'interface pour les appels
    @FXML
    private Button callButton;
    @FXML
    private VBox callControlsBox;
    @FXML
    private Label callStatusLabel;
    @FXML
    private Button acceptCallButton;
    @FXML
    private Button rejectCallButton;
    @FXML
    private Button endCallButton;
    @FXML
    private ToggleButton muteButton;

    private ChatService chatService;
    private String userEmail;
    private User selectedContactUser;
    private Group selectedGroup;

    private final ObservableList<User> contacts = FXCollections.observableArrayList();
    private final ObservableList<Group> groups = FXCollections.observableArrayList();

    private final JsonLocalMessageRepository localRepo = new JsonLocalMessageRepository();
    private final ContactService contactService = new ContactService();
    private final GroupService groupService = new GroupService();
    private final UserService userService = new UserService();
    private final CallManager callManager = CallManager.getInstance();
    private final FileService fileService = new FileService();
    private final AudioRecorderService audioRecorderService = new AudioRecorderService();

    private final Object loadLock = new Object();

    private static final DateTimeFormatter TIME_FMT = DateTimeFormatter.ofPattern("HH:mm");

    // Media attachment state
    private File selectedMediaFile;
    private MessageType selectedMediaType;

    // Audio recording state
    private boolean isRecording = false;
    private Timer recordingTimer;
    private int recordingSeconds = 0;

    // KeyManager for E2EE
    private KeyManager keyManager;

    @FXML
    public void initialize() {
        mediaGalleryButton.setOnAction(this::handleOpenMediaGallery);
        contactListView.setItems(contacts);
        groupListView.setItems(groups);

        contactListView.setCellFactory(list -> createCell(
                user -> user.getDisplayNameOrEmail(),
                user -> {
                    try {
                        return localRepo.getLastContactMessage(userEmail,
                                chatService.getCurrentUserId(),
                                user.getId());
                    } catch (final IOException e) {
                        return Optional.empty();
                    }
                },
                User::getAvatarUrl,
                msg -> msg.map(m -> {
                    try {
                        final String prefix = (m.getSenderUserId() == chatService.getCurrentUserId()) ? "Vous: " : "";
                        if (m.isTextMessage()) {
                            return prefix + truncate(m.getContent(), 30);
                        } else {
                            final String mediaTypeIcon = getMediaTypeIcon(m.getType());
                            return prefix + mediaTypeIcon + " " + (m.getFileName() != null ? m.getFileName() : "M√©dia");
                        }
                    } catch (final Exception e) {
                        return "Erreur chargement";
                    }
                }).orElse("")));

        groupListView.setCellFactory(list -> createCell(
                group -> group.getName(),
                group -> {
                    try {
                        return localRepo.getLastGroupMessage(userEmail, group.getId());
                    } catch (final IOException e) {
                        return Optional.empty();
                    }
                },
                group -> Optional.ofNullable(group.getProfilePictureUrl())
                        .filter(u -> !u.isEmpty())
                        .orElse("/images/default_group.png"),
                msg -> msg.map(m -> {
                    String name = "Inconnu";
                    try {
                        name = userService.getUserById(m.getSenderUserId()).getEmail().split("@")[0];
                    } catch (final IOException e) {
                        /* ignore */ }
                    final String prefix = (m.getSenderUserId() == chatService.getCurrentUserId() ? "Vous: "
                            : name + ": ");
                    if (m.isTextMessage()) {
                        return prefix + truncate(m.getContent(), 30);
                    } else {
                        final String mediaTypeIcon = getMediaTypeIcon(m.getType());
                        return prefix + mediaTypeIcon + " " + (m.getFileName() != null ? m.getFileName() : "M√©dia");
                    }
                }).orElse("")));

        contactListView.getSelectionModel().selectedItemProperty().addListener((obs, old, sel) -> {
            if (sel != null) {
                groupListView.getSelectionModel().clearSelection();
                selectedContactUser = sel;
                selectedGroup = null;
                loadContactConversation(selectedContactUser);

                // Effacer l'affichage des membres pour une conversation individuelle
                groupMembersLabel.setText("");

                setStatus("Conversation charg√©e avec " + selectedContactUser.getDisplayNameOrEmail());

                // Activer le bouton d'appel uniquement pour les conversations de contact (pas
                // de groupe)
                callButton.setDisable(false);
            }
        });

        groupListView.getSelectionModel().selectedItemProperty().addListener((obs, old, sel) -> {
            if (sel != null) {
                contactListView.getSelectionModel().clearSelection();
                selectedGroup = sel;
                selectedContactUser = null;
                loadGroupConversation(sel);

                // Les membres seront affich√©s par la m√©thode loadGroupConversation
                // qui appelle displayGroupMembers

                setStatus("Conversation de groupe charg√©e : " + sel.getName());

                // D√©sactiver le bouton d'appel pour les conversations de groupe
                callButton.setDisable(true);
            }
        });

        messageField.setOnAction(this::handleSendMessage);

        // Initialiser l'interface d'appel
        initCallUI();

        // Initialize media button context menu
        final ContextMenu mediaMenu = new ContextMenu();

        final MenuItem imageItem = new MenuItem("Image");
        imageItem.setOnAction(e -> openMediaFileChooser("Images", "*.png", "*.jpg", "*.jpeg", "*.gif"));

        final MenuItem videoItem = new MenuItem("Vid√©o");
        videoItem.setOnAction(e -> openMediaFileChooser("Vid√©os", "*.mp4", "*.avi", "*.mov", "*.wmv"));

        final MenuItem documentItem = new MenuItem("Document");
        documentItem.setOnAction(e -> openMediaFileChooser("Documents", "*.*"));

        mediaMenu.getItems().addAll(imageItem, videoItem, documentItem);

        mediaButton.setOnMouseClicked(e -> {
            mediaMenu.show(mediaButton, e.getScreenX(), e.getScreenY());
        });

        // Check if audio recording is supported
        if (!audioRecorderService.isAudioRecordingSupported()) {
            audioRecordButton.setDisable(true);
            audioRecordButton.setTooltip(
                    new javafx.scene.control.Tooltip("L'enregistrement audio n'est pas pris en charge sur ce syst√®me"));
        }
    }

    private String getMediaTypeIcon(final MessageType type) {
        switch (type) {
            case IMAGE:
                return "üñºÔ∏è";
            case VIDEO:
                return "üé¨";
            case AUDIO:
                return "üîä";
            case DOCUMENT:
                return "üìÑ";
            default:
                return "";
        }
    }

    public void initData(final ChatService service, final String userEmail, final KeyManager keyManager) {
        this.chatService = service;
        this.userEmail = userEmail;
        this.keyManager = keyManager;
        userEmailLabel.setText(userEmail);

        chatService.setMessageConsumer(this::handleIncomingMessage);
        chatService.setCallSignalConsumer(this::handleCallSignal);
        loadContacts();
        loadGroups();

        // D√©marrer le rafra√Æchissement p√©riodique des statuts
        startContactStatusUpdater();

        // Initialiser l'UI d'appel
        initCallUI();
    }

    /**
     * Initialise l'interface utilisateur pour les appels.
     */
    private void initCallUI() {
        // Lier le label de statut d'appel au CallManager
        callStatusLabel.textProperty().bind(callManager.callStatusProperty());

        // Initialiser les boutons d'appel comme invisibles
        callControlsBox.setVisible(false);
        callControlsBox.setManaged(false);
        acceptCallButton.setVisible(false);
        acceptCallButton.setManaged(false);
        rejectCallButton.setVisible(false);
        rejectCallButton.setManaged(false);
        endCallButton.setVisible(false);
        endCallButton.setManaged(false);
        muteButton.setVisible(false);
        muteButton.setManaged(false);
    }

    /**
     * G√®re une demande d'appel (bouton Appeler).
     */
    @FXML
    private void handleCallRequest(final ActionEvent event) {
        if (selectedContactUser == null) {
            setStatus("Veuillez s√©lectionner un contact pour appeler");
            return;
        }

        try {
            // Cr√©er une nouvelle session d'appel
            final User currentUser = userService.getUserByEmail(userEmail);
            final CallSession callSession = new CallSession(currentUser.getId(), selectedContactUser.getId());

            // Initialiser l'appel dans le CallManager
            if (!callManager.initiateCall(selectedContactUser, callSession)) {
                setStatus("Impossible d'initialiser l'appel. Un appel est peut-√™tre d√©j√† en cours.");
                return;
            }

            // Envoyer le signal d'appel
            final CallSignal callRequest = chatService.createCallRequest(callSession, selectedContactUser.getEmail());
            chatService.sendCallSignal(callRequest);

            // Afficher l'interface d'appel
            showCallUI(false);

            setStatus("Appel en cours vers " + selectedContactUser.getDisplayNameOrEmail());
        } catch (final IOException e) {
            setStatus("Erreur lors de l'appel : " + e.getMessage());
        }
    }

    /**
     * G√®re l'acceptation d'un appel.
     */
    @FXML
    private void handleAcceptCall(final ActionEvent event) {
        try {
            final CallSession currentSession = callManager.getCurrentSession();
            if (currentSession == null) {
                setStatus("Aucun appel √† accepter");
                return;
            }

            // Initialiser le CallManager qui va cr√©er le socket UDP et obtenir un port
            // Le port local sera maintenant g√©r√© par le CallManager

            // R√©cup√©rer le port local attribu√© par le CallManager
            final int localPort = callManager.getLocalPort();
            System.out.println("Acceptation d'appel avec port local: " + localPort);

            // Envoyer le signal d'acceptation avec l'adresse IP et le port local
            final CallSignal acceptSignal = chatService.createCallAccept(
                    currentSession.getSessionId(),
                    currentSession.getCallerUserId(),
                    localPort);
            chatService.sendCallSignal(acceptSignal);

            // Mettre √† jour l'interface d'appel
            updateCallUIForActiveCall();

            setStatus("Appel accept√©");
        } catch (final IOException e) {
            setStatus("Erreur lors de l'acceptation de l'appel : " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * G√®re le rejet d'un appel.
     */
    @FXML
    private void handleRejectCall(final ActionEvent event) {
        try {
            final CallSession currentSession = callManager.getCurrentSession();
            if (currentSession == null) {
                setStatus("Aucun appel √† rejeter");
                return;
            }

            // Envoyer le signal de rejet
            final CallSignal rejectSignal = chatService.createCallReject(
                    currentSession.getSessionId(),
                    currentSession.getCallerUserId());
            chatService.sendCallSignal(rejectSignal);

            // Terminer l'appel localement
            callManager.endCall();

            // Masquer l'interface d'appel
            hideCallUI();

            setStatus("Appel rejet√©");
        } catch (final IOException e) {
            setStatus("Erreur lors du rejet de l'appel : " + e.getMessage());
        }
    }

    /**
     * G√®re la fin d'un appel en cours.
     */
    @FXML
    private void handleEndCall(final ActionEvent event) {
        try {
            final CallSession currentSession = callManager.getCurrentSession();
            if (currentSession == null) {
                setStatus("Aucun appel √† terminer");
                return;
            }

            // D√©terminer l'autre utilisateur dans l'appel
            final long otherUserId = (currentSession.getCallerUserId() == chatService.getCurrentUserId())
                    ? currentSession.getReceiverUserId()
                    : currentSession.getCallerUserId();

            // Envoyer le signal de fin d'appel
            final CallSignal endSignal = chatService.createCallEnd(
                    currentSession.getSessionId(),
                    otherUserId);
            chatService.sendCallSignal(endSignal);

            // Terminer l'appel localement
            callManager.endCall();

            // Masquer l'interface d'appel
            hideCallUI();

            setStatus("Appel termin√©");
        } catch (final IOException e) {
            setStatus("Erreur lors de la fin de l'appel : " + e.getMessage());
        }
    }

    /**
     * G√®re l'activation/d√©sactivation du microphone.
     */
    @FXML
    private void handleToggleMute(final ActionEvent event) {
        final boolean muted = muteButton.isSelected();
        callManager.setMicrophoneMuted(muted);
        muteButton.setText(muted ? "Activer micro" : "Muet");
    }

    /**
     * G√®re les signaux d'appel re√ßus.
     */
    private void handleCallSignal(final CallSignal signal) {
        Platform.runLater(() -> {
            try {
                switch (signal.getType()) {
                    case CALL_REQUEST:
                        handleIncomingCallRequest(signal);
                        break;

                    case CALL_ACCEPT:
                        handleCallAccepted(signal);
                        break;

                    case CALL_REJECT:
                        handleCallRejected(signal);
                        break;

                    case CALL_END:
                        handleCallEnded(signal);
                        break;

                    case CALL_BUSY:
                        handleCallBusy(signal);
                        break;
                }
            } catch (final Exception e) {
                setStatus("Erreur lors du traitement du signal d'appel : " + e.getMessage());
            }
        });
    }

    /**
     * G√®re une demande d'appel entrante.
     */
    private void handleIncomingCallRequest(final CallSignal signal) throws IOException {
        // V√©rifier si un appel est d√©j√† en cours
        if (callManager.isCallActive()) {
            // Envoyer un signal d'occupation
            final CallSignal busySignal = CallSignal.createCallBusy(
                    signal.getSessionId(),
                    signal.getReceiverUserId(),
                    signal.getSenderUserId());
            chatService.sendCallSignal(busySignal);
            return;
        }

        // R√©cup√©rer l'utilisateur appelant
        final User caller = userService.getUserById(signal.getSenderUserId());

        // Cr√©er une session d'appel
        final CallSession callSession = new CallSession(signal.getSenderUserId(), signal.getReceiverUserId());
        callSession.setSessionId(signal.getSessionId());
        callSession.setStatus(CallSession.CallStatus.RINGING);

        // D√©finir l'utilisateur distant dans le CallManager
        callManager.setRemoteUser(caller);

        // Afficher la fen√™tre de dialogue d'appel entrant
        showIncomingCallDialog(callSession, caller);
    }

    /**
     * G√®re l'acceptation d'un appel par le destinataire.
     */
    private void handleCallAccepted(final CallSignal signal) {
        // Configurer la connexion d'appel avec les informations du destinataire
        callManager.setupCallConnection(signal.getIpAddress(), signal.getPort());

        // Mettre √† jour l'interface d'appel
        updateCallUIForActiveCall();
    }

    /**
     * G√®re le rejet d'un appel par le destinataire.
     */
    private void handleCallRejected(final CallSignal signal) {
        // Terminer l'appel localement
        callManager.endCall();

        // Masquer l'interface d'appel
        hideCallUI();

        setStatus("Appel rejet√© par le destinataire");
    }

    /**
     * G√®re la fin d'un appel par l'autre partie.
     */
    private void handleCallEnded(final CallSignal signal) {
        // Terminer l'appel localement
        callManager.endCall();

        // Masquer l'interface d'appel
        hideCallUI();

        setStatus("Appel termin√© par l'autre partie");
    }

    /**
     * G√®re le cas o√π le destinataire est occup√©.
     */
    private void handleCallBusy(final CallSignal signal) {
        // Terminer l'appel localement
        callManager.endCall();

        // Masquer l'interface d'appel
        hideCallUI();

        setStatus("Le destinataire est occup√©");
    }

    /**
     * Affiche la fen√™tre de dialogue pour un appel entrant.
     */
    private void showIncomingCallDialog(final CallSession callSession, final User caller) {
        try {
            // Charger le FXML de la fen√™tre de dialogue
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/call-dialog.fxml"));
            final Parent dialogRoot = loader.load();

            // R√©cup√©rer le contr√¥leur
            final CallDialogController controller = loader.getController();

            // Initialiser le contr√¥leur avec les informations d'appel
            controller.initData(
                    callSession,
                    caller,
                    null, // L'adresse IP sera d√©finie lors de l'acceptation
                    0, // Le port sera d√©fini lors de l'acceptation
                    () -> {
                        // Callback pour l'acceptation
                        showCallUI(true);
                    },
                    () -> {
                        // Callback pour le rejet
                        // Rien √† faire ici, le contr√¥leur envoie d√©j√† le signal de rejet
                    });

            // Cr√©er et afficher la fen√™tre
            final Stage dialogStage = new Stage();
            dialogStage.initModality(Modality.APPLICATION_MODAL);
            dialogStage.initStyle(StageStyle.UNDECORATED);
            dialogStage.setScene(new Scene(dialogRoot));
            dialogStage.setTitle("Appel entrant");
            dialogStage.show();

        } catch (final IOException e) {
            setStatus("Erreur lors de l'affichage de la fen√™tre d'appel : " + e.getMessage());
        }
    }

    /**
     * Affiche l'interface d'appel.
     *
     * @param incoming true si c'est un appel entrant, false si c'est un appel
     *                 sortant
     */
    private void showCallUI(final boolean incoming) {
        callControlsBox.setVisible(true);
        callControlsBox.setManaged(true);

        if (incoming) {
            // Pour un appel entrant, on affiche les boutons Accepter et Refuser
            acceptCallButton.setVisible(true);
            acceptCallButton.setManaged(true);
            rejectCallButton.setVisible(true);
            rejectCallButton.setManaged(true);
            endCallButton.setVisible(false);
            endCallButton.setManaged(false);
            muteButton.setVisible(false);
            muteButton.setManaged(false);
        } else {
            // Pour un appel sortant, on affiche uniquement le bouton Terminer
            acceptCallButton.setVisible(false);
            acceptCallButton.setManaged(false);
            rejectCallButton.setVisible(false);
            rejectCallButton.setManaged(false);
            endCallButton.setVisible(true);
            endCallButton.setManaged(true);
            muteButton.setVisible(false);
            muteButton.setManaged(false);
        }
    }

    /**
     * Met √† jour l'interface d'appel pour un appel actif.
     */
    private void updateCallUIForActiveCall() {
        callControlsBox.setVisible(true);
        callControlsBox.setManaged(true);

        acceptCallButton.setVisible(false);
        acceptCallButton.setManaged(false);
        rejectCallButton.setVisible(false);
        rejectCallButton.setManaged(false);
        endCallButton.setVisible(true);
        endCallButton.setManaged(true);
        muteButton.setVisible(true);
        muteButton.setManaged(true);
    }

    /**
     * Masque l'interface d'appel.
     */
    private void hideCallUI() {
        callControlsBox.setVisible(false);
        callControlsBox.setManaged(false);
    }

    private <T> ListCell<T> createCell(
            final java.util.function.Function<T, String> nameFn,
            final java.util.function.Function<T, Optional<Message>> lastMsgFn,
            final java.util.function.Function<T, String> avatarUrlFn,
            final java.util.function.Function<Optional<Message>, String> msgTextFn) {
        return new ListCell<T>() {
            private User currentUser = null;
            private final ChangeListener<Boolean> onlineListener = (obs, oldVal, newVal) -> {
                updateOnlineIndicator(newVal);
            };

            private final HBox hbox = new HBox(10);
            private final ImageView avatar = new ImageView();
            private final VBox contentBox = new VBox(2);
            private final Label nameLabel = new Label();
            private final Label lastMsgLabel = new Label();
            private final Circle onlineIndicator = new Circle(5);

            {
                hbox.setPadding(new Insets(5));
                hbox.setAlignment(Pos.CENTER_LEFT);
                avatar.setFitHeight(30);
                avatar.setFitWidth(30);
                avatar.setPreserveRatio(true);
                nameLabel.getStyleClass().add("contact-name");
                lastMsgLabel.getStyleClass().add("last-message");
                contentBox.getChildren().addAll(nameLabel, lastMsgLabel);

                onlineIndicator.getStyleClass().add("offline-indicator");

                final StackPane avatarContainer = new StackPane();
                avatarContainer.getChildren().add(avatar);
                StackPane.setAlignment(onlineIndicator, Pos.BOTTOM_RIGHT);
                avatarContainer.getChildren().add(onlineIndicator);

                hbox.getChildren().addAll(avatarContainer, contentBox);
            }

            @Override
            protected void updateItem(final T item, final boolean empty) {
                super.updateItem(item, empty);

                // Remove previous listener
                if (currentUser != null) {
                    currentUser.onlineProperty().removeListener(onlineListener);
                    currentUser = null;
                }

                if (empty || item == null) {
                    setText(null);
                    setGraphic(null);
                    onlineIndicator.setVisible(false);
                    return;
                }

                nameLabel.setText(nameFn.apply(item));
                final String url = avatarUrlFn.apply(item);
                if (url != null) {
                    final Image img = loadImage(url, 30);
                    if (img != null) {
                        avatar.setImage(img);
                    }
                }
                final Optional<Message> msg = lastMsgFn.apply(item);
                lastMsgLabel.setText(msgTextFn.apply(msg));

                if (item instanceof User) {
                    currentUser = (User) item;
                    currentUser.onlineProperty().addListener(onlineListener);
                    updateOnlineIndicator(currentUser.isOnline());
                } else {
                    onlineIndicator.setVisible(false);
                }

                setGraphic(hbox);
            }

            private void updateOnlineIndicator(final boolean isOnline) {
                Platform.runLater(() -> {
                    onlineIndicator.getStyleClass().removeAll("online-indicator", "offline-indicator");
                    onlineIndicator.getStyleClass().add(isOnline ? "online-indicator" : "offline-indicator");
                    onlineIndicator.setVisible(true);
                });
            }
        };
    }

    private Image loadImage(final String imageUrl, final double size) {

        try (InputStream stream = getClass().getResourceAsStream(imageUrl)) {
            if (stream != null) {
                return new Image(stream, size, size, true, true);
            } else {
                final String fallback = imageUrl.contains("group") ? "/images/default_group.png"
                        : "/images/default_avatar.png";
                try (InputStream fallbackStream = getClass().getResourceAsStream(fallback)) {
                    if (fallbackStream != null) {
                        return new Image(fallbackStream, size, size, true, true);
                    }
                }
            }
        } catch (final IOException e) {
            System.err.println("Erreur lors du chargement de l'image " + imageUrl + ": " + e.getMessage());
        }
        return null;
    }

    private ImageView createCircularAvatar(final String imageUrl, final double size) {
        final ImageView imageView = new ImageView();
        imageView.setFitWidth(size);
        imageView.setFitHeight(size);
        imageView.setPreserveRatio(true);
        final javafx.scene.shape.Circle clip = new javafx.scene.shape.Circle(size / 2, size / 2, size / 2);
        imageView.setClip(clip);

        return imageView;
    }

    private void addMessageToChat(final Message message) {
        try {
            final User sender = userService.getUserById(message.getSenderUserId());
            final User currentUser = userService.getUserByEmail(userEmail);
            final boolean isMine = message.getSenderUserId() == currentUser.getId();
            final boolean isGroup = message.getGroupId() != null;

            final HBox messageContainer = new HBox(10);
            messageContainer.getStyleClass().add("message-container");
            messageContainer.setAlignment(isMine ? Pos.CENTER_RIGHT : Pos.CENTER_LEFT);
            messageContainer.setPadding(new Insets(5));
            messageContainer.setMaxWidth(chatHistoryContainer.getWidth() * 0.8);

            // Avatar
            final ImageView avatar = createCircularAvatar(sender.getAvatarUrl(), 35);
            avatar.getStyleClass().add("message-avatar");
            if (!isMine)
                messageContainer.getChildren().add(avatar);

            // Contenu du message
            final VBox contentBox = new VBox(5);
            contentBox.getStyleClass().add("message-content");
            contentBox.getStyleClass().add(isMine ? "my-message" : "other-message");

            if (isGroup && !isMine) {
                final Label nameLabel = new Label(sender.getDisplayNameOrEmail());
                nameLabel.getStyleClass().add("sender-name");
                contentBox.getChildren().add(nameLabel);
            }

            // For text messages, use the existing logic
            if (message.isTextMessage()) {
                // Cr√©er un conteneur horizontal pour le texte et l'horodatage
                final HBox contentTimeContainer = new HBox();
                contentTimeContainer.getStyleClass().add("content-time-container");

                // Texte du message
                final Label contentLabel = new Label(message.getContent());
                contentLabel.setWrapText(true);
                contentLabel.getStyleClass().add("message-text");
                contentLabel.setMaxWidth(chatHistoryContainer.getWidth() * 0.6); // Pour laisser de la place √†
                                                                                 // l'horodatage

                // Horodatage
                final Label timeLabel = new Label(message.getTimestamp().format(TIME_FMT));
                timeLabel.getStyleClass().add("message-time");

                // Assembler le conteneur de message
                contentTimeContainer.getChildren().addAll(contentLabel, timeLabel);
                contentBox.getChildren().add(contentTimeContainer);
            }
            // For media messages, create appropriate media preview
            else {
                // Add media content based on the type
                switch (message.getType()) {
                    case IMAGE:
                        addImageContent(contentBox, message);
                        break;
                    case VIDEO:
                        addVideoContent(contentBox, message);
                        break;
                    case AUDIO:
                        addAudioContent(contentBox, message);
                        break;
                    case DOCUMENT:
                        addDocumentContent(contentBox, message);
                        break;
                    default:
                        // Fallback to text representation
                        final Label fallbackLabel = new Label("Type de m√©dia non pris en charge");
                        contentBox.getChildren().add(fallbackLabel);
                }

                // Add timestamp below the media
                final HBox timeContainer = new HBox();
                timeContainer.setAlignment(Pos.CENTER_RIGHT);
                final Label timeLabel = new Label(message.getTimestamp().format(TIME_FMT));
                timeLabel.getStyleClass().add("message-time");
                timeContainer.getChildren().add(timeLabel);
                contentBox.getChildren().add(timeContainer);
            }

            messageContainer.getChildren().add(contentBox);

            if (isMine)
                messageContainer.getChildren().add(avatar);

            Platform.runLater(() -> {
                chatHistoryContainer.getChildren().add(messageContainer);
                scrollToBottom();
            });
        } catch (final IOException e) {
            setStatus("Erreur d'affichage du message : " + e.getMessage());
        }
    }

    private void addImageContent(final VBox contentBox, final Message message) {
        try {
            System.out.println();
            final File imageFile = chatService.getMediaFile(message);
            if (imageFile.exists()) {
                final Image image = new Image(imageFile.toURI().toString());
                final ImageView imageView = new ImageView(image);

                // Limit image size
                final double maxWidth = 250;
                final double maxHeight = 250;

                if (image.getWidth() > maxWidth || image.getHeight() > maxHeight) {
                    final double widthRatio = maxWidth / image.getWidth();
                    final double heightRatio = maxHeight / image.getHeight();
                    final double ratio = Math.min(widthRatio, heightRatio);

                    imageView.setFitWidth(image.getWidth() * ratio);
                    imageView.setFitHeight(image.getHeight() * ratio);
                } else {
                    imageView.setFitWidth(image.getWidth());
                    imageView.setFitHeight(image.getHeight());
                }

                imageView.getStyleClass().add("image-preview");

                // Add click handler to open the image in a new window
                imageView.setOnMouseClicked(e -> openImageViewer(image));

                contentBox.getChildren().add(imageView);

                // Add filename if available
                if (message.getFileName() != null) {
                    final Label filenameLabel = new Label(message.getFileName());
                    filenameLabel.setTextFill(Color.GRAY);
                    filenameLabel.setFont(Font.font("System", FontWeight.NORMAL, 10));
                    contentBox.getChildren().add(filenameLabel);
                }
            } else {
                final Label errorLabel = new Label("Image non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (final Exception e) {
            final Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    private void addVideoContent(final VBox contentBox, final Message message) {
        try {
            final File videoFile = chatService.getMediaFile(message);
            if (videoFile.exists()) {
                final HBox videoContainer = new HBox();
                videoContainer.setAlignment(Pos.CENTER);
                videoContainer.getStyleClass().add("video-preview");

                // Create a thumbnail or play button
                final Button playButton = new Button("‚ñ∂");
                playButton.getStyleClass().add("audio-play-button");
                playButton.setOnAction(e -> openVideoPlayer(videoFile));

                final Label videoLabel = new Label(message.getFileName() != null ? message.getFileName() : "Vid√©o");

                videoContainer.getChildren().addAll(playButton, videoLabel);
                contentBox.getChildren().add(videoContainer);
            } else {
                final Label errorLabel = new Label("Vid√©o non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (final Exception e) {
            final Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    private void addAudioContent(final VBox contentBox, final Message message) {
        try {
            final File audioFile = chatService.getMediaFile(message);
            if (audioFile.exists()) {
                final HBox audioPlayer = new HBox(10);
                audioPlayer.setAlignment(Pos.CENTER_LEFT);
                audioPlayer.getStyleClass().add("audio-player");

                final Button playButton = new Button("‚ñ∂");
                playButton.getStyleClass().add("audio-play-button");

                final ProgressBar progressBar = new ProgressBar(0);
                progressBar.getStyleClass().add("audio-progress");
                progressBar.setPrefWidth(150);

                final Label durationLabel = new Label("00:00");

                // Create the media player
                final Media media = new Media(audioFile.toURI().toString());
                final MediaPlayer mediaPlayer = new MediaPlayer(media);

                // Configure the progress bar and duration label
                mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
                    final double progress = newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds();
                    Platform.runLater(() -> {
                        progressBar.setProgress(progress);
                        durationLabel.setText(formatDuration(newVal));
                    });
                });

                mediaPlayer.setOnEndOfMedia(() -> {
                    mediaPlayer.stop();
                    mediaPlayer.seek(javafx.util.Duration.ZERO);
                    playButton.setText("‚ñ∂");
                });

                // Configure the play button
                playButton.setOnAction(e -> {
                    if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                        mediaPlayer.pause();
                        playButton.setText("‚ñ∂");
                    } else {
                        mediaPlayer.play();
                        playButton.setText("‚è∏");
                    }
                });

                audioPlayer.getChildren().addAll(playButton, progressBar, durationLabel);
                contentBox.getChildren().add(audioPlayer);
            } else {
                final Label errorLabel = new Label("Audio non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (final Exception e) {
            final Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    private void addDocumentContent(final VBox contentBox, final Message message) {
        try {
            final File documentFile = chatService.getMediaFile(message);
            if (documentFile.exists()) {
                final HBox documentContainer = new HBox(10);
                documentContainer.getStyleClass().add("document-preview");

                final Label iconLabel = new Label("üìÑ");
                iconLabel.getStyleClass().add("document-icon");

                final VBox documentInfo = new VBox(5);

                final Label nameLabel = new Label(message.getFileName() != null ? message.getFileName() : "Document");
                nameLabel.getStyleClass().add("document-name");

                final Label sizeLabel = new Label(formatFileSize(message.getFileSize()));
                sizeLabel.getStyleClass().add("document-size");

                documentInfo.getChildren().addAll(nameLabel, sizeLabel);
                documentContainer.getChildren().addAll(iconLabel, documentInfo);

                // Add click handler to open the document
                documentContainer.setOnMouseClicked(e -> openDocument(documentFile));

                contentBox.getChildren().add(documentContainer);
            } else {
                final Label errorLabel = new Label("Document non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (final Exception e) {
            final Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    // Helper method to format file size
    private String formatFileSize(final Long size) {
        if (size == null) {
            return "Taille inconnue";
        }

        if (size < 1024) {
            return size + " octets";
        } else if (size < 1024 * 1024) {
            return String.format("%.1f KB", size / 1024.0);
        } else if (size < 1024 * 1024 * 1024) {
            return String.format("%.1f MB", size / (1024.0 * 1024));
        } else {
            return String.format("%.1f GB", size / (1024.0 * 1024 * 1024));
        }
    }

    // Helper method to format duration
    private String formatDuration(final javafx.util.Duration duration) {
        int seconds = (int) Math.floor(duration.toSeconds());
        final int minutes = seconds / 60;
        seconds = seconds % 60;
        return String.format("%02d:%02d", minutes, seconds);
    }

    // Open image in a larger viewer
    private void openImageViewer(final Image image) {
        final Stage imageStage = new Stage();
        imageStage.initModality(Modality.APPLICATION_MODAL);
        imageStage.setTitle("Visionneuse d'image");

        final ImageView imageView = new ImageView(image);
        imageView.setPreserveRatio(true);

        // Limit size to fit screen
        imageView.setFitWidth(Math.min(image.getWidth(), 800));
        imageView.setFitHeight(Math.min(image.getHeight(), 600));

        final ScrollPane scrollPane = new ScrollPane(imageView);
        scrollPane.setPannable(true);
        scrollPane.setFitToWidth(true);
        scrollPane.setFitToHeight(true);

        final Scene scene = new Scene(scrollPane);
        imageStage.setScene(scene);
        imageStage.show();
    }

    // Open video player
    private void openVideoPlayer(final File videoFile) {
        final Stage videoStage = new Stage();
        videoStage.initModality(Modality.APPLICATION_MODAL);
        videoStage.setTitle("Lecteur vid√©o");

        final Media media = new Media(videoFile.toURI().toString());
        final MediaPlayer mediaPlayer = new MediaPlayer(media);
        final MediaView mediaView = new MediaView(mediaPlayer);

        // Set up controls
        final Button playButton = new Button("‚è∏");
        playButton.setOnAction(e -> {
            if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                mediaPlayer.pause();
                playButton.setText("‚ñ∂");
            } else {
                mediaPlayer.play();
                playButton.setText("‚è∏");
            }
        });

        final ProgressBar progressBar = new ProgressBar(0);
        progressBar.setPrefWidth(300);

        mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
            final double progress = newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds();
            Platform.runLater(() -> progressBar.setProgress(progress));
        });

        // Add seek functionality
        progressBar.setOnMouseClicked(e -> {
            final double percent = e.getX() / progressBar.getWidth();
            mediaPlayer.seek(mediaPlayer.getTotalDuration().multiply(percent));
        });

        final HBox controls = new HBox(10, playButton, progressBar);
        controls.setAlignment(Pos.CENTER);
        controls.setPadding(new Insets(10));

        final VBox root = new VBox(10, mediaView, controls);
        root.setAlignment(Pos.CENTER);

        final Scene scene = new Scene(root, 640, 480);
        videoStage.setScene(scene);

        videoStage.setOnCloseRequest(e -> mediaPlayer.stop());

        videoStage.show();
        mediaPlayer.play();
    }

    // Open document with system default application
    private void openDocument(final File documentFile) {
        try {
            java.awt.Desktop.getDesktop().open(documentFile);
        } catch (final Exception e) {
            setStatus("Erreur lors de l'ouverture du document: " + e.getMessage());
        }
    }

    private void scrollToBottom() {
        Platform.runLater(() -> {
            chatScrollPane.setVvalue(1.0);
        });
    }

    private void setStatus(final String status) {
        Platform.runLater(() -> {
            if (status != null && (status.startsWith("Erreur") || status.startsWith("√âchec"))) {
                statusLabel.setStyle("-fx-text-fill: red;");
            } else {
                statusLabel.setStyle("");
            }
            statusLabel.setText(status);
        });
    }

    private String truncate(final String text, final int maxLength) {
        return text.length() > maxLength ? text.substring(0, maxLength) + "..." : text;
    }

    private void loadContacts() {
        try {
            final List<User> contactList = contactService.getContactUsers(userEmail);
            Platform.runLater(() -> {
                contacts.clear();
                contacts.addAll(contactList);
            });
        } catch (final IOException e) {
            setStatus("Erreur lors du chargement des contacts : " + e.getMessage());
        }
    }

    private void loadGroups() {
        try {
            final long userId = userService.getUserByEmail(userEmail).getId();
            final List<Group> groupList = groupService.getGroupsForUser(userId);
            Platform.runLater(() -> {
                groups.clear();
                groups.addAll(groupList);
            });
        } catch (final IOException e) {
            setStatus("Erreur lors du chargement des groupes : " + e.getMessage());
        }
    }

    private void loadContactConversation(final User contactUser) {
        Platform.runLater(() -> {
            synchronized (loadLock) {
                chatHistoryContainer.getChildren().clear();
                try {
                    // Effacer l'affichage des membres car on est dans une conversation individuelle
                    groupMembersLabel.setText("");

                    final long myId = userService.getUserByEmail(userEmail).getId();
                    final long contactId = contactUser.getId();
                    final List<Message> contactMessages = localRepo.loadContactMessages(userEmail, myId, contactId);
                    contactMessages.forEach(this::addMessageToChat);
                    scrollToBottom();

                    // Activer le bouton d'appel pour les conversations individuelles
                    callButton.setDisable(false);
                } catch (final IOException e) {
                    setStatus("Erreur lors du chargement de la conversation avec " + contactUser.getDisplayNameOrEmail()
                            + " : "
                            + e.getMessage());
                }
            }
        });
    }

    private void loadGroupConversation(final Group group) {
        Platform.runLater(() -> {
            synchronized (loadLock) {
                chatHistoryContainer.getChildren().clear();
                try {
                    // Afficher les membres du groupe dans l'en-t√™te
                    displayGroupMembers(group);
                    final List<Message> groupMessages = localRepo.loadGroupMessages(userEmail, group.getId());
                    groupMessages.forEach(this::addMessageToChat);
                    scrollToBottom();
                } catch (final IOException e) {
                    setStatus("Erreur lors du chargement de l'historique de groupe : " + e.getMessage());
                }
            }
        });
    }

    /**
     * Affiche les membres du groupe dans l'en-t√™te de la conversation
     */
    private void displayGroupMembers(final Group group) {
        if (group == null) {
            groupMembersLabel.setText("");
            return;
        }
        try {
            // R√©cup√©rer les IDs des membres du groupe
            final List<Long> memberIds = groupService.getMembersForGroup(group.getId());
            // Construire la liste des noms des membres
            final List<String> memberNames = new ArrayList<>();
            for (final Long memberId : memberIds) {
                try {
                    final User user = userService.getUserById(memberId);
                    final String displayName = user.getDisplayNameOrEmail().split("@")[0];
                    memberNames.add(displayName);
                } catch (final IOException e) {
                    memberNames.add("Inconnu");
                }
            }
            // Joindre les noms avec des virgules
            final String membersText = "Membres : " + String.join(", ", memberNames);
            groupMembersLabel.setText(membersText);
        } catch (final Exception e) {
            groupMembersLabel.setText("Erreur lors du chargement des membres");
            setStatus("Erreur lors du chargement des membres : " + e.getMessage());
        }
    }

    @FXML
    private void handleSendMessage(final ActionEvent event) {
        if (selectedMediaFile != null) {
            System.out.println("Avertissement: L'envoi de m√©dia E2EE n'est pas encore impl√©ment√©.");
            // sendMediaMessage();
            return;
        }

        final String content = messageField.getText().trim();
        if (content.isEmpty()) {
            return;
        }

        long recipientUserId = -1;
        long recipientGroupId = -1;

        if (selectedContactUser != null) {
            recipientUserId = selectedContactUser.getId();
        } else if (selectedGroup != null) {
            System.out.println("Avertissement: L'envoi de messages E2EE aux groupes n'est pas support√©. Envoi en clair.");
            recipientGroupId = selectedGroup.getId();
            try {
                final User sender = userService.getUserByEmail(userEmail);
                final Message message = Message.newGroupMessage(sender.getId(), recipientGroupId, content);
                chatService.sendMessage(message);
                messageField.clear();
                addMessageToChat(message);
                localRepo.addLocalMessage(userEmail, message);
                groupListView.refresh();
                setStatus("Message de groupe envoy√© (non chiffr√©)");
            } catch (final IOException e) {
                setStatus("Erreur lors de l'envoi du message de groupe : " + e.getMessage());
            }
            return;
        } else {
            setStatus("Veuillez s√©lectionner un contact ou un groupe.");
            return;
        }

        if (recipientUserId > 0) {
            try {
                final Message localDisplayMessage = Message.newDirectMessage(chatService.getCurrentUserId(), recipientUserId, content);
                addMessageToChat(localDisplayMessage);
                localRepo.addLocalMessage(userEmail, localDisplayMessage);

                chatService.sendEncryptedTextMessage(recipientUserId, content);

                messageField.clear();
                contactListView.refresh();
                setStatus("Message chiffr√© envoy√©");

            } catch (final PublicKeyNotAvailableException e) {
                setStatus("Pr√©paration de la connexion s√©curis√©e... R√©essayez d'envoyer.");
                System.err.println("Avertissement UI: " + e.getMessage());
            } catch (final Exception e) {
                setStatus("Erreur d'envoi E2EE : " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    private void handleIncomingMessage(final Message message) {
        Platform.runLater(() -> {
            try {
                localRepo.addLocalMessage(userEmail, message);

                if (message.getGroupId() != null) {
                    final boolean groupExists = groups.stream()
                            .anyMatch(g -> g.getId() == message.getGroupId());
                    if (!groupExists) {
                        loadGroups();
                    } else {
                        groupListView.refresh();
                    }

                    if (selectedGroup != null && selectedGroup.getId() == message.getGroupId()) {
                        addMessageToChat(message);
                    }
                    setStatus("Nouveau message de groupe re√ßu");
                } else {
                    final User sender = userService.getUserById(message.getSenderUserId());

                    if (sender != null && !contacts.contains(sender)) {
                        contacts.add(sender);
                    }
                    contactListView.refresh();

                    if (selectedContactUser != null &&
                            sender.getId() == selectedContactUser.getId()) {
                        addMessageToChat(message);
                    }

                    if (message.getType() == MessageType.TEXT) {
                        setStatus("Nouveau message re√ßu de " + (sender != null ? sender.getDisplayNameOrEmail() : "Inconnu"));
                    } else if (message.getType() == MessageType.SYSTEM) {
                        setStatus("Info syst√®me: " + message.getContent());
                    } else if (message.isMediaMessage()) {
                        setStatus("Nouveau m√©dia re√ßu de " + (sender != null ? sender.getDisplayNameOrEmail() : "Inconnu"));
                    } else {
                        setStatus("Notification re√ßue");
                    }
                }

                scrollToBottom();
            } catch (final IOException e) {
                setStatus("Erreur lors du traitement du message re√ßu : " + e.getMessage());
            }
        });
    }

    @FXML
    private void handleAddContact() {
        final String email = newContactField.getText().trim();

        if (email.isEmpty()) {
            setStatus("Veuillez saisir un email");
            return;
        }

        final boolean contactExists = contacts.stream()
                .anyMatch(user -> user.getEmail().equalsIgnoreCase(email));

        if (contactExists) {
            setStatus("Ce contact existe d√©j√†.");
            newContactField.clear();
            return;
        }

        try {
            final User addedUser = contactService.addContactUser(userEmail, email);
            if (addedUser != null) {
                contacts.add(addedUser);
                newContactField.clear();
                setStatus("Contact ajout√©: " + addedUser.getDisplayNameOrEmail());
            }
        } catch (final IllegalArgumentException e) {
            setStatus("Erreur: " + e.getMessage());
        } catch (final IOException e) {
            setStatus("Erreur de connexion: " + e.getMessage());
        }
    }

    @FXML
    private void handleRemoveContact() {
        if (selectedContactUser == null) {
            setStatus("Aucun contact s√©lectionn√© pour la suppression");
            return;
        }
        try {
            final boolean removed = contactService.removeContact(userEmail, selectedContactUser.getEmail());
            if (removed) {
                contacts.remove(selectedContactUser);
                chatHistoryContainer.getChildren().clear();
                final long myId = chatService.getCurrentUserId();
                localRepo.removeConversation(userEmail, myId, selectedContactUser.getId());
                setStatus("Contact et conversation supprim√©s: " + selectedContactUser.getDisplayNameOrEmail());
                selectedContactUser = null;
            } else {
                setStatus("La suppression du contact a √©chou√©");
            }
        } catch (final IOException e) {
            setStatus("Erreur: " + e.getMessage());
        }
    }

    @FXML
    private void handleCreateGroup(final ActionEvent event) {
        final String groupName = groupNameField.getText().trim();
        if (groupName.isEmpty()) {
            setStatus("Le nom du groupe est obligatoire");
            return;
        }
        final long ownerId = chatService.getCurrentUserId();
        final Group createdGroup = groupService.createGroup(groupName, ownerId);
        if (createdGroup.getId() > 0) {
            setStatus("Groupe cr√©√© : " + createdGroup.getName());
            groups.add(createdGroup);
            groupNameField.clear();
        } else {
            setStatus("Erreur lors de la cr√©ation du groupe");
        }
    }

    @FXML
    private void handleAddMemberToGroup(final ActionEvent event) {
        final String memberEmail = memberEmailField.getText().trim();
        if (memberEmail.isEmpty()) {
            setStatus("Veuillez entrer l'email du membre √† ajouter");
            return;
        }
        final Group selectedGroup = groupListView.getSelectionModel().getSelectedItem();
        if (selectedGroup == null) {
            setStatus("Veuillez s√©lectionner un groupe");
            return;
        }
        try {
            final long memberId = userService.getUserByEmail(memberEmail).getId();
            final boolean success = groupService.addMemberToGroup(selectedGroup.getId(), memberId);
            if (success) {
                setStatus("Membre ajout√© avec succ√®s");
                memberEmailField.clear();
            } else {
                setStatus("Le membre est d√©j√† pr√©sent ou l'ajout a √©chou√©");
            }
        } catch (final IOException e) {
            setStatus("Erreur lors de l'ajout du membre : " + e.getMessage());
        }
    }

    @FXML
    private void handleRemoveMemberFromGroup(final ActionEvent event) {
        final Group selectedGroup = groupListView.getSelectionModel().getSelectedItem();
        if (selectedGroup == null) {
            setStatus("Veuillez s√©lectionner un groupe");
            return;
        }

        final String memberEmail = memberEmailField.getText().trim();
        if (memberEmail.isEmpty()) {
            setStatus("Veuillez entrer l'email du membre √† supprimer");
            return;
        }

        try {
            final User memberUser = userService.getUserByEmail(memberEmail);
            if (memberUser == null) {
                setStatus("Utilisateur non trouv√©: " + memberEmail);
                return;
            }

            if (memberUser.getId() == selectedGroup.getOwnerUserId()) {
                setStatus("Impossible de supprimer le propri√©taire du groupe");
                return;
            }

            final boolean removed = groupService.removeMemberFromGroup(selectedGroup.getId(), memberUser.getId());
            if (removed) {
                setStatus("Membre supprim√© avec succ√®s");
                memberEmailField.clear();

                if (selectedGroup.equals(this.selectedGroup)) {
                    displayGroupMembers(selectedGroup);
                }
            } else {
                setStatus("La suppression du membre a √©chou√© ou l'utilisateur n'√©tait pas membre du groupe");
            }
        } catch (final IOException e) {
            setStatus("Erreur lors de la suppression du membre: " + e.getMessage());
        }
    }

    @FXML
    private void handleLogout() {
        try {
            chatService.disconnect();
            chatHistoryContainer.getChildren().clear();

            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            final Parent loginView = loader.load();

            final Stage stage = (Stage) userEmailLabel.getScene().getWindow();
            stage.setTitle("Chat Application");
            stage.setScene(new Scene(loginView, 600, 400));
            stage.centerOnScreen();
        } catch (final IOException e) {
            setStatus("Erreur lors de la d√©connexion: " + e.getMessage());
        }
    }

    private void openMediaFileChooser(final String description, final String... extensions) {
        final FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("S√©lectionner un fichier");
        fileChooser.getExtensionFilters().add(
                new FileChooser.ExtensionFilter(description, extensions));

        final File selectedFile = fileChooser.showOpenDialog(mediaButton.getScene().getWindow());
        if (selectedFile != null) {
            selectedMediaFile = selectedFile;
            selectedMediaType = fileService.detectMessageType(selectedFile.getName());

            attachmentNameLabel.setText(selectedFile.getName());
            attachmentPreviewContainer.setManaged(true);
            attachmentPreviewContainer.setVisible(true);

            messageField.clear();
            messageField.setPromptText("Appuyez sur Envoyer pour envoyer le fichier");
        }
    }

    @FXML
    private void handleRemoveAttachment() {
        clearMediaSelection();
    }

    private void clearMediaSelection() {
        selectedMediaFile = null;
        selectedMediaType = null;
        attachmentPreviewContainer.setManaged(false);
        attachmentPreviewContainer.setVisible(false);
        messageField.setPromptText("√âcrire un message...");
    }

    @FXML
    private void handleAudioRecordButtonClick() {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    }

    private void startRecording() {
        try {
            audioRecorderService.startRecording();
            isRecording = true;

            audioRecordButton.setText("‚ñ†");
            audioRecordButton.getStyleClass().add("recording");
            recordingIndicatorContainer.setManaged(true);
            recordingIndicatorContainer.setVisible(true);

            messageField.setDisable(true);
            mediaButton.setDisable(true);

            recordingSeconds = 0;
            recordingTimeLabel.setText("00:00");
            recordingTimer = new Timer();
            recordingTimer.scheduleAtFixedRate(new TimerTask() {
                @Override
                public void run() {
                    recordingSeconds++;
                    Platform.runLater(() -> {
                        final int minutes = recordingSeconds / 60;
                        final int seconds = recordingSeconds % 60;
                        recordingTimeLabel.setText(String.format("%02d:%02d", minutes, seconds));
                    });
                }
            }, 1000, 1000);

            setStatus("Enregistrement audio d√©marr√©");
        } catch (final LineUnavailableException e) {
            setStatus("Erreur lors du d√©marrage de l'enregistrement: " + e.getMessage());
        }
    }

    private void stopRecording() {
        try {
            if (recordingTimer != null) {
                recordingTimer.cancel();
                recordingTimer = null;
            }

            final File audioFile = audioRecorderService.stopRecording();
            isRecording = false;

            audioRecordButton.setText("üé§");
            audioRecordButton.getStyleClass().remove("recording");
            recordingIndicatorContainer.setManaged(false);
            recordingIndicatorContainer.setVisible(false);

            messageField.setDisable(false);
            mediaButton.setDisable(false);

            if (audioFile != null && audioFile.exists()) {
                selectedMediaFile = audioFile;
                selectedMediaType = MessageType.AUDIO;

                attachmentNameLabel.setText("Enregistrement audio (" + formatDuration(recordingSeconds) + ")");
                attachmentPreviewContainer.setManaged(true);
                attachmentPreviewContainer.setVisible(true);

                setStatus("Enregistrement audio termin√©");
            } else {
                setStatus("L'enregistrement audio a √©chou√©");
            }
        } catch (final IOException e) {
            setStatus("Erreur lors de l'arr√™t de l'enregistrement: " + e.getMessage());
        }
    }

    private String formatDuration(int seconds) {
        final int minutes = seconds / 60;
        seconds = seconds % 60;
        return String.format("%02d:%02d", minutes, seconds);
    }

    @FXML
    private void handleOpenMediaGallery(final ActionEvent event) {
        try {
            if (selectedContactUser == null && selectedGroup == null) {
                setStatus("Veuillez s√©lectionner un contact ou un groupe pour voir la galerie m√©dia");
                return;
            }

            List<Message> mediaMessages;
            String conversationName;
            boolean isGroup;

            if (selectedContactUser != null) {
                final long myId = userService.getUserByEmail(userEmail).getId();
                final long contactId = selectedContactUser.getId();
                mediaMessages = localRepo.loadContactMessages(userEmail, myId, contactId)
                        .stream()
                        .filter(Message::isMediaMessage)
                        .collect(Collectors.toList());
                conversationName = selectedContactUser.getDisplayNameOrEmail();
                isGroup = false;
            } else {
                mediaMessages = localRepo.loadGroupMessages(userEmail, selectedGroup.getId())
                        .stream()
                        .filter(Message::isMediaMessage)
                        .collect(Collectors.toList());
                conversationName = selectedGroup.getName();
                isGroup = true;
            }

            if (mediaMessages.isEmpty()) {
                setStatus("Aucun m√©dia trouv√© dans cette conversation");
                return;
            }

            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/media_gallery.fxml"));
            final Parent root = loader.load();

            final MediaGalleryController galleryController = loader.getController();
            galleryController.setData(chatService, userService, mediaMessages, conversationName, isGroup);

            final Stage galleryStage = new Stage();
            galleryStage.setTitle("Galerie m√©dia - " + conversationName);
            galleryStage.initModality(Modality.WINDOW_MODAL);
            galleryStage.initOwner(mediaGalleryButton.getScene().getWindow());
            galleryStage.setScene(new Scene(root));
            galleryStage.show();

        } catch (final IOException e) {
            setStatus("Erreur lors de l'ouverture de la galerie m√©dia: " + e.getMessage());
        }
    }

    @FXML
    private void handleMediaButtonClick(final ActionEvent event) {
        try {
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/media_dialog.fxml"));
            final Parent root = loader.load();

            final MediaDialogController dialogController = loader.getController();
            dialogController.setSendHandler((file, type) -> {
                selectedMediaFile = file;
                selectedMediaType = type;

                attachmentNameLabel.setText(file.getName());
                attachmentPreviewContainer.setManaged(true);
                attachmentPreviewContainer.setVisible(true);

                messageField.clear();
                messageField.setPromptText("Appuyez sur Envoyer pour envoyer le fichier");
                // this.sendMediaMessage();
            });

            final Stage dialogStage = new Stage();
            dialogStage.setTitle("Envoyer un m√©dia");
            dialogStage.initModality(Modality.WINDOW_MODAL);
            dialogStage.initOwner(mediaButton.getScene().getWindow());
            dialogStage.setScene(new Scene(root));
            dialogStage.showAndWait();

        } catch (final IOException e) {
            setStatus("Erreur lors de l'ouverture du dialogue m√©dia: " + e.getMessage());
        }
    }

    private void startContactStatusUpdater() {
        final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.scheduleAtFixedRate(() -> {
            try {
                for (final User user : contacts) {
                    final boolean isOnline = contactService.isUserOnline(user.getId());
                    Platform.runLater(() -> user.setOnline(isOnline));
                }
            } catch (final IOException e) {
                Platform.runLater(() -> setStatus("Erreur mise √† jour des statuts: " + e.getMessage()));
            }
        }, 0, 5, TimeUnit.SECONDS);

        Platform.runLater(() -> {
            final Stage stage = (Stage) userEmailLabel.getScene().getWindow();
            stage.setOnCloseRequest(event -> scheduler.shutdown());
        });
    }
}



// File: src/main/java/org/example/client/gui/controllers/LoginController.java
package org.example.client.gui.controllers;

import java.io.IOException;

import org.example.client.gui.security.KeyManager;
import org.example.client.gui.service.ChatService;
import org.example.shared.dto.Credentials;

import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.stage.Stage;

public class LoginController {

    @FXML
    private TextField emailField;

    @FXML
    private PasswordField passwordField;

    @FXML
    private Button loginButton;

    private KeyManager keyManager;

    private ChatService chatService;

    @FXML
    public void initialize() {
        // --- AJOUT POUR E2EE ---
        // Initialiser KeyManager en passant l'email saisi dans emailField (m√™me s'il est initialement vide)
        this.keyManager = new KeyManager(emailField.getText().trim());

        // --- FIN AJOUT ---

        // Instancier ChatService EN PASSANT KeyManager
        this.chatService = new ChatService(this.keyManager);
        // Activer le bouton de connexion seulement si des valeurs sont entr√©es
        loginButton.disableProperty().bind(
                emailField.textProperty().isEmpty().or(
                        passwordField.textProperty().isEmpty()));
    }

    // this function takes in the login event from the view extracts credentials and
    // calls connect from chat service
    @FXML
    private void handleLogin(final ActionEvent event) {
        // here we get credentials
        final String email = emailField.getText().trim();
        final String password = passwordField.getText();

        // D√©binder la propri√©t√© disable avant de la modifier
        loginButton.disableProperty().unbind();
        loginButton.setDisable(true); // D√©sactiver le bouton

        new Thread(() -> {
            try {
                final Credentials credentials = new Credentials(email, password);
                // here we call connect() in chat service
                // connect does the following :
                // - establishes connection with server socket (a client socket is created in
                // server side for further communication)
                // - it send credentials using the output stream and waits for response the
                // server creates a client handler and checks authenticates client
                // - if authenticated we run code in a thread (to load messages sent to the
                // client offline using loadMessages() ), and we return "true".
                final boolean success = chatService.connect(credentials);

                Platform.runLater(() -> {
                    if (success) {
                        try {
                            // if authentication is successful we open the chat view
                            openChatWindow(email);
                        } catch (final IOException e) {
                            showError("Erreur d'interface",
                                    "Impossible d'ouvrir la fen√™tre de chat: " + e.getMessage());
                            rebindLoginButton();
                        }
                    } else {
                        showError("√âchec de connexion", "Email ou mot de passe incorrect");
                        rebindLoginButton();
                    }
                });
            } catch (final IOException e) {
                Platform.runLater(() -> {
                    showError("Erreur de connexion", "Impossible de se connecter au serveur: " + e.getMessage());
                    rebindLoginButton();
                });
            }
        }).start();
    }

    /**
     * R√©tablit le binding du bouton de login
     */
    private void rebindLoginButton() {
        loginButton.disableProperty().unbind(); // S'assurer qu'il n'y a pas de binding actif
        loginButton.setDisable(false); // R√©activer le bouton
        // Rebinder le bouton avec la condition initiale
        loginButton.disableProperty().bind(
                emailField.textProperty().isEmpty().or(
                        passwordField.textProperty().isEmpty()));
    }

    /**
     * G√®re le clic sur le lien "Cr√©er un compte" pour naviguer vers la page
     * d'inscription
     */
    @FXML
    private void handleRegisterLink(final ActionEvent event) {
        try {
            // Charger la vue d'inscription
            final FXMLLoader loader = new FXMLLoader(LoginController.class.getResource("/fxml/register.fxml"));
            final Parent registerView = loader.load();

            // Cr√©er et afficher la nouvelle sc√®ne
            final Scene registerScene = new Scene(registerView, 600, 500);
            final Stage currentStage = (Stage) loginButton.getScene().getWindow();

            currentStage.setTitle("Inscription");
            currentStage.setScene(registerScene);
            currentStage.centerOnScreen();
        } catch (final IOException e) {
            showError("Erreur d'interface", "Impossible d'ouvrir la fen√™tre d'inscription: " + e.getMessage());
        }
    }

    // this function loads chat.fxml and configures it with a controller
    // chatController
    private void openChatWindow(final String userEmail) throws IOException {
        // Charger la vue de chat
        final FXMLLoader loader = new FXMLLoader(LoginController.class.getResource("/fxml/chat.fxml"));
        final Parent chatView = loader.load();

        // Configurer le contr√¥leur de chat
        final ChatController chatController = loader.getController();
        chatController.initData(chatService, userEmail, keyManager);

        // Cr√©er et afficher la nouvelle sc√®ne
        final Scene chatScene = new Scene(chatView, 800, 600);
        final Stage currentStage = (Stage) loginButton.getScene().getWindow();

        currentStage.setTitle("Chat - " + userEmail);
        currentStage.setScene(chatScene);
        currentStage.setMinWidth(800);
        currentStage.setMinHeight(600);
        currentStage.centerOnScreen();
    }

    private void showError(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}



// File: src/main/java/org/example/client/gui/controllers/MediaDialogController.java
package org.example.client.gui.controllers;

import java.io.File;
import java.io.IOException;
import java.util.Timer;
import java.util.TimerTask;

import org.example.client.gui.service.AudioRecorderService;
import org.example.shared.model.enums.MessageType;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import javafx.scene.media.MediaView;
import javafx.stage.FileChooser;
import javafx.stage.Stage;

import javax.sound.sampled.LineUnavailableException;

public class MediaDialogController {

    @FXML
    private ComboBox<String> mediaTypeComboBox;

    @FXML
    private TextField filePathField;

    @FXML
    private VBox previewContainer;

    @FXML
    private HBox recordAudioContainer;

    @FXML
    private Button recordButton;

    @FXML
    private Label recordingTimeLabel;

    @FXML
    private ProgressBar audioLevelIndicator;

    @FXML
    private Button sendButton;

    private File selectedFile;
    private MessageType selectedType;
    private boolean isRecording = false;
    private Timer recordingTimer;
    private int recordingSeconds = 0;

    private final AudioRecorderService audioRecorderService = new AudioRecorderService();

    // Interface for handling send action
    public interface MediaSendHandler {
        void onMediaSelected(File file, MessageType type);
    }

    private MediaSendHandler sendHandler;

    @FXML
    public void initialize() {
        // Initialize media type combo box
        mediaTypeComboBox.setItems(FXCollections.observableArrayList(
                "Image", "Vid√©o", "Document", "Audio"
        ));

        // Add listener to the combo box
        mediaTypeComboBox.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                switch (newVal) {
                    case "Image":
                        selectedType = MessageType.IMAGE;
                        recordAudioContainer.setVisible(false);
                        recordAudioContainer.setManaged(false);
                        break;
                    case "Vid√©o":
                        selectedType = MessageType.VIDEO;
                        recordAudioContainer.setVisible(false);
                        recordAudioContainer.setManaged(false);
                        break;
                    case "Document":
                        selectedType = MessageType.DOCUMENT;
                        recordAudioContainer.setVisible(false);
                        recordAudioContainer.setManaged(false);
                        break;
                    case "Audio":
                        selectedType = MessageType.AUDIO;
                        recordAudioContainer.setVisible(true);
                        recordAudioContainer.setManaged(true);
                        break;
                }

                // Clear the file selection when changing type
                selectedFile = null;
                filePathField.clear();
                updatePreview();
            }
        });

        // Set default selected type
        mediaTypeComboBox.getSelectionModel().select(0);

        // Disable send button initially
        sendButton.setDisable(true);
    }

    /**
     * Sets the handler for send actions.
     *
     * @param handler The handler
     */
    public void setSendHandler(MediaSendHandler handler) {
        this.sendHandler = handler;
    }

    @FXML
    private void handleBrowseFile(ActionEvent event) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("S√©lectionner un fichier");

        // Set extension filters based on selected type
        switch (selectedType) {
            case IMAGE:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Images", "*.png", "*.jpg", "*.jpeg", "*.gif", "*.bmp"));
                break;
            case VIDEO:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Vid√©os", "*.mp4", "*.avi", "*.mov", "*.wmv", "*.flv", "*.mkv"));
                break;
            case AUDIO:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Fichiers audio", "*.mp3", "*.wav", "*.ogg", "*.aac", "*.wma", "*.flac"));
                break;
            case DOCUMENT:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Tous les fichiers", "*.*"));
                break;
        }

        // Show file chooser dialog
        File file = fileChooser.showOpenDialog(filePathField.getScene().getWindow());
        if (file != null) {
            selectedFile = file;
            filePathField.setText(file.getAbsolutePath());
            sendButton.setDisable(false);
            updatePreview();
        }
    }

    @FXML
    private void handleRecordAudio(ActionEvent event) {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    }

    private void startRecording() {
        try {
            // Start recording
            audioRecorderService.startRecording();
            isRecording = true;

            // Update UI
            recordButton.setText("‚ñ† Arr√™ter");
            recordingTimeLabel.setText("00:00");

            // Start timer
            recordingSeconds = 0;
            recordingTimer = new Timer();
            recordingTimer.scheduleAtFixedRate(new TimerTask() {
                @Override
                public void run() {
                    recordingSeconds++;
                    Platform.runLater(() -> {
                        int minutes = recordingSeconds / 60;
                        int seconds = recordingSeconds % 60;
                        recordingTimeLabel.setText(String.format("%02d:%02d", minutes, seconds));
                    });
                }
            }, 1000, 1000);

        } catch (LineUnavailableException e) {
            System.err.println("Error starting recording: " + e.getMessage());
        }
    }

    private void stopRecording() {
        try {
            // Stop the timer
            if (recordingTimer != null) {
                recordingTimer.cancel();
                recordingTimer = null;
            }

            // Stop recording and get the recorded file
            File audioFile = audioRecorderService.stopRecording();
            isRecording = false;

            // Update UI
            recordButton.setText("üé§ Enregistrer");

            // If we have a valid audio file, set it as the selected file
            if (audioFile != null && audioFile.exists()) {
                selectedFile = audioFile;
                filePathField.setText("Enregistrement audio (" + formatDuration(recordingSeconds) + ")");
                sendButton.setDisable(false);
                updatePreview();
            }
        } catch (IOException e) {
            System.err.println("Error stopping recording: " + e.getMessage());
        }
    }

    private String formatDuration(int seconds) {
        int minutes = seconds / 60;
        seconds = seconds % 60;
        return String.format("%02d:%02d", minutes, seconds);
    }

    private void updatePreview() {
        previewContainer.getChildren().clear();

        if (selectedFile == null) {
            return;
        }

        switch (selectedType) {
            case IMAGE:
                try {
                    Image image = new Image(selectedFile.toURI().toString());
                    ImageView imageView = new ImageView(image);

                    // Limit preview size
                    imageView.setFitWidth(300);
                    imageView.setFitHeight(200);
                    imageView.setPreserveRatio(true);

                    previewContainer.getChildren().add(imageView);
                } catch (Exception e) {
                    previewContainer.getChildren().add(new Label("Erreur de chargement de l'image"));
                }
                break;

            case VIDEO:
                try {
                    Media media = new Media(selectedFile.toURI().toString());
                    MediaPlayer mediaPlayer = new MediaPlayer(media);
                    MediaView mediaView = new MediaView(mediaPlayer);

                    // Limit preview size
                    mediaView.setFitWidth(300);
                    mediaView.setFitHeight(200);
                    mediaView.setPreserveRatio(true);

                    // Add play/pause button
                    Button playButton = new Button("‚ñ∂ Play");
                    playButton.setOnAction(e -> {
                        if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                            mediaPlayer.pause();
                            playButton.setText("‚ñ∂ Play");
                        } else {
                            mediaPlayer.play();
                            playButton.setText("‚è∏ Pause");
                        }
                    });

                    VBox videoBox = new VBox(10, mediaView, playButton);
                    previewContainer.getChildren().add(videoBox);
                } catch (Exception e) {
                    previewContainer.getChildren().add(new Label("Erreur de chargement de la vid√©o"));
                }
                break;

            case AUDIO:
                try {
                    HBox audioPlayer = new HBox(10);
                    audioPlayer.setAlignment(javafx.geometry.Pos.CENTER_LEFT);

                    Button playButton = new Button("‚ñ∂");

                    if (selectedFile.exists() && selectedFile.getName().toLowerCase().endsWith(".wav")) {
                        Media media = new Media(selectedFile.toURI().toString());
                        MediaPlayer mediaPlayer = new MediaPlayer(media);

                        playButton.setOnAction(e -> {
                            if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                                mediaPlayer.pause();
                                playButton.setText("‚ñ∂");
                            } else {
                                mediaPlayer.play();
                                playButton.setText("‚è∏");
                            }
                        });
                    } else {
                        // For non-playable files, just show a placeholder
                        playButton.setDisable(true);
                    }

                    Label audioLabel = new Label(selectedFile.getName());

                    audioPlayer.getChildren().addAll(playButton, audioLabel);
                    previewContainer.getChildren().add(audioPlayer);
                } catch (Exception e) {
                    previewContainer.getChildren().add(new Label("Erreur de chargement de l'audio"));
                }
                break;

            case DOCUMENT:
                Label docIcon = new Label("üìÑ");
                docIcon.setStyle("-fx-font-size: 32px;");

                Label docName = new Label(selectedFile.getName());

                Label docSize = new Label(formatFileSize(selectedFile.length()));
                docSize.setStyle("-fx-text-fill: #888;");

                VBox docBox = new VBox(5, docIcon, docName, docSize);
                docBox.setAlignment(javafx.geometry.Pos.CENTER);

                previewContainer.getChildren().add(docBox);
                break;
        }
    }

    private String formatFileSize(long size) {
        if (size < 1024) {
            return size + " octets";
        } else if (size < 1024 * 1024) {
            return String.format("%.1f KB", size / 1024.0);
        } else if (size < 1024 * 1024 * 1024) {
            return String.format("%.1f MB", size / (1024.0 * 1024));
        } else {
            return String.format("%.1f GB", size / (1024.0 * 1024 * 1024));
        }
    }

    @FXML
    private void handleSend(ActionEvent event) {
        if (selectedFile != null && sendHandler != null) {
            sendHandler.onMediaSelected(selectedFile, selectedType);
        }
        closeDialog(); // Ensures the dialog is closed regardless
    }

    @FXML
    private void handleCancel(ActionEvent event) {
        // Stop recording if in progress
        if (isRecording) {
            try {
                audioRecorderService.stopRecording();
                if (recordingTimer != null) {
                    recordingTimer.cancel();
                }
            } catch (IOException e) {
                // Ignore
            }
        }

        closeDialog();
    }

    private void closeDialog() {
        Stage stage = (Stage) sendButton.getScene().getWindow();
        stage.close();
    }
}


// File: src/main/java/org/example/client/gui/controllers/MediaGalleryController.java
package org.example.client.gui.controllers;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.example.client.gui.service.ChatService;
import org.example.client.gui.service.UserService;
import org.example.shared.model.Message;
import org.example.shared.model.User;
import org.example.shared.model.enums.MessageType;

import javafx.collections.FXCollections;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.geometry.Pos;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class MediaGalleryController {

    @FXML
    private Label titleLabel;

    @FXML
    private ComboBox<String> mediaTypeFilter;

    @FXML
    private FlowPane mediaContainer;

    @FXML
    private Label statsLabel;

    private ChatService chatService;
    private UserService userService;
    private List<Message> mediaMessages;
    private String conversationName;
    private boolean isGroup;

    /**
     * Initializes the controller.
     */
    @FXML
    public void initialize() {
        // Initialize media type filter
        mediaTypeFilter.setItems(FXCollections.observableArrayList(
                "Tous", "Images", "Vid√©os", "Documents", "Audio"
        ));

        // Add listener to filter media by type
        mediaTypeFilter.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                filterMediaByType(newVal);
            }
        });

        // Set default selection
        mediaTypeFilter.getSelectionModel().select(0);
    }

    /**
     * Sets the data for the gallery.
     *
     * @param chatService The chat service
     * @param userService The user service
     * @param mediaMessages The list of media messages
     * @param conversationName The name of the conversation
     * @param isGroup Whether the conversation is a group
     */
    public void setData(ChatService chatService, UserService userService, List<Message> mediaMessages,
                        String conversationName, boolean isGroup) {
        this.chatService = chatService;
        this.userService = userService;
        this.mediaMessages = new ArrayList<>(mediaMessages);
        this.conversationName = conversationName;
        this.isGroup = isGroup;

        // Update title
        titleLabel.setText("Galerie m√©dia - " + conversationName);

        // Load all media initially
        filterMediaByType("Tous");
    }

    /**
     * Filters the media by type.
     *
     * @param filterType The filter type
     */
    private void filterMediaByType(String filterType) {
        List<Message> filteredMessages;

        switch (filterType) {
            case "Images":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isImageMessage)
                        .collect(Collectors.toList());
                break;
            case "Vid√©os":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isVideoMessage)
                        .collect(Collectors.toList());
                break;
            case "Documents":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isDocumentMessage)
                        .collect(Collectors.toList());
                break;
            case "Audio":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isAudioMessage)
                        .collect(Collectors.toList());
                break;
            default:
                filteredMessages = mediaMessages;
                break;
        }

        displayMedia(filteredMessages);
        updateStats(filteredMessages.size());
    }

    /**
     * Displays the media in the gallery.
     *
     * @param messages The messages to display
     */
    private void displayMedia(List<Message> messages) {
        mediaContainer.getChildren().clear();

        for (Message message : messages) {
            try {
                // Get the file
                File mediaFile = chatService.getMediaFile(message);

                // Create the media item based on type
                VBox mediaItem = createMediaItem(message, mediaFile);

                mediaContainer.getChildren().add(mediaItem);
            } catch (Exception e) {
                System.err.println("Error displaying media: " + e.getMessage());
            }
        }
    }

    /**
     * Creates a media item for the gallery.
     *
     * @param message The message
     * @param mediaFile The media file
     * @return The media item
     */
    private VBox createMediaItem(Message message, File mediaFile) throws IOException {
        VBox item = new VBox(5);
        item.setAlignment(Pos.CENTER);
        item.setStyle("-fx-background-color: #f5f5f5; -fx-padding: 10px; -fx-border-radius: 5px; " +
                "-fx-background-radius: 5px; -fx-border-color: #ddd;");
        item.setPrefWidth(150);
        item.setPrefHeight(180);

        // Create the preview based on media type
        switch (message.getType()) {
            case IMAGE:
                createImagePreview(item, mediaFile);
                break;
            case VIDEO:
                createVideoPreview(item);
                break;
            case AUDIO:
                createAudioPreview(item);
                break;
            case DOCUMENT:
                createDocumentPreview(item, message);
                break;
            default:
                item.getChildren().add(new Label("Type non pris en charge"));
                break;
        }

        // Add sender name
        try {
            User sender = userService.getUserById(message.getSenderUserId());
            Label senderLabel = new Label(sender.getDisplayNameOrEmail());
            senderLabel.setStyle("-fx-font-size: 10px; -fx-text-fill: #888;");
            item.getChildren().add(senderLabel);
        } catch (IOException e) {
            // Ignore
        }

        // Make the item clickable to open the media
        item.setOnMouseClicked(e -> openMedia(message, mediaFile));

        return item;
    }

    private void createImagePreview(VBox item, File mediaFile) {
        try {
            Image image = new Image(mediaFile.toURI().toString(), 130, 130, true, true);
            ImageView imageView = new ImageView(image);
            imageView.setFitWidth(130);
            imageView.setFitHeight(130);
            imageView.setPreserveRatio(true);

            item.getChildren().add(imageView);
        } catch (Exception e) {
            Label errorLabel = new Label("Erreur image");
            item.getChildren().add(errorLabel);
        }
    }

    private void createVideoPreview(VBox item) {
        Label videoIcon = new Label("üé¨");
        videoIcon.setStyle("-fx-font-size: 48px;");

        Label videoLabel = new Label("Vid√©o");

        item.getChildren().addAll(videoIcon, videoLabel);
    }

    private void createAudioPreview(VBox item) {
        Label audioIcon = new Label("üîä");
        audioIcon.setStyle("-fx-font-size: 48px;");

        Label audioLabel = new Label("Audio");

        item.getChildren().addAll(audioIcon, audioLabel);
    }

    private void createDocumentPreview(VBox item, Message message) {
        Label docIcon = new Label("üìÑ");
        docIcon.setStyle("-fx-font-size: 48px;");

        Label docName = new Label(message.getFileName() != null ?
                truncateText(message.getFileName(), 15) : "Document");

        item.getChildren().addAll(docIcon, docName);
    }

    /**
     * Opens the media in an appropriate viewer.
     *
     * @param message The message
     * @param mediaFile The media file
     */
    private void openMedia(Message message, File mediaFile) {
        if (!mediaFile.exists()) {
            return;
        }

        switch (message.getType()) {
            case IMAGE:
                openImageViewer(mediaFile);
                break;
            case VIDEO:
                openVideoPlayer(mediaFile);
                break;
            case AUDIO:
                openAudioPlayer(mediaFile);
                break;
            case DOCUMENT:
                openDocument(mediaFile);
                break;
        }
    }

    private void openImageViewer(File imageFile) {
        try {
            // Create a new stage with an image viewer
            Stage imageStage = new Stage();
            imageStage.setTitle("Visionneuse d'image");

            Image image = new Image(imageFile.toURI().toString());
            ImageView imageView = new ImageView(image);
            imageView.setPreserveRatio(true);

            // Limit size to fit screen
            imageView.setFitWidth(Math.min(image.getWidth(), 800));
            imageView.setFitHeight(Math.min(image.getHeight(), 600));

            javafx.scene.control.ScrollPane scrollPane = new javafx.scene.control.ScrollPane(imageView);
            scrollPane.setPannable(true);
            scrollPane.setFitToWidth(true);
            scrollPane.setFitToHeight(true);

            javafx.scene.Scene scene = new javafx.scene.Scene(scrollPane);
            imageStage.setScene(scene);
            imageStage.show();
        } catch (Exception e) {
            System.err.println("Error opening image: " + e.getMessage());
        }
    }

    private void openVideoPlayer(File videoFile) {
        try {
            // Create a new stage with a video player
            Stage videoStage = new Stage();
            videoStage.setTitle("Lecteur vid√©o");

            javafx.scene.media.Media media = new javafx.scene.media.Media(videoFile.toURI().toString());
            javafx.scene.media.MediaPlayer mediaPlayer = new javafx.scene.media.MediaPlayer(media);
            javafx.scene.media.MediaView mediaView = new javafx.scene.media.MediaView(mediaPlayer);

            // Set up controls
            javafx.scene.control.Button playButton = new javafx.scene.control.Button("‚ñ∂ Play");
            playButton.setOnAction(e -> {
                if (mediaPlayer.getStatus() == javafx.scene.media.MediaPlayer.Status.PLAYING) {
                    mediaPlayer.pause();
                    playButton.setText("‚ñ∂ Play");
                } else {
                    mediaPlayer.play();
                    playButton.setText("‚è∏ Pause");
                }
            });

            javafx.scene.control.ProgressBar progressBar = new javafx.scene.control.ProgressBar(0);
            progressBar.setPrefWidth(300);

            mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
                double progress = newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds();
                javafx.application.Platform.runLater(() -> progressBar.setProgress(progress));
            });

            // Add seek functionality
            progressBar.setOnMouseClicked(e -> {
                double percent = e.getX() / progressBar.getWidth();
                mediaPlayer.seek(mediaPlayer.getTotalDuration().multiply(percent));
            });

            HBox controls = new HBox(10, playButton, progressBar);
            controls.setAlignment(Pos.CENTER);
            controls.setPadding(new javafx.geometry.Insets(10));

            VBox root = new VBox(10, mediaView, controls);
            root.setAlignment(Pos.CENTER);

            javafx.scene.Scene scene = new javafx.scene.Scene(root, 640, 480);
            videoStage.setScene(scene);

            videoStage.setOnCloseRequest(e -> mediaPlayer.stop());

            videoStage.show();
            mediaPlayer.play();
        } catch (Exception e) {
            System.err.println("Error opening video: " + e.getMessage());
        }
    }

    private void openAudioPlayer(File audioFile) {
        try {
            // Create a new stage with an audio player
            Stage audioStage = new Stage();
            audioStage.setTitle("Lecteur audio");

            javafx.scene.media.Media media = new javafx.scene.media.Media(audioFile.toURI().toString());
            javafx.scene.media.MediaPlayer mediaPlayer = new javafx.scene.media.MediaPlayer(media);

            // Create controls
            javafx.scene.control.Button playButton = new javafx.scene.control.Button("‚ñ∂ Play");
            javafx.scene.control.Slider timeSlider = new javafx.scene.control.Slider();
            javafx.scene.control.Label timeLabel = new javafx.scene.control.Label("00:00 / 00:00");

            // Configure play button
            playButton.setOnAction(e -> {
                if (mediaPlayer.getStatus() == javafx.scene.media.MediaPlayer.Status.PLAYING) {
                    mediaPlayer.pause();
                    playButton.setText("‚ñ∂ Play");
                } else {
                    mediaPlayer.play();
                    playButton.setText("‚è∏ Pause");
                }
            });

            // Configure time slider
            timeSlider.setMin(0);
            timeSlider.setMax(1);
            timeSlider.setValue(0);
            timeSlider.setPrefWidth(300);

            timeSlider.valueProperty().addListener((obs, oldVal, newVal) -> {
                if (timeSlider.isValueChanging()) {
                    mediaPlayer.seek(mediaPlayer.getTotalDuration().multiply(newVal.doubleValue()));
                }
            });

            // Update time label and slider
            mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
                if (!timeSlider.isValueChanging()) {
                    timeSlider.setValue(newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds());

                    int currentMinutes = (int) newVal.toMinutes();
                    int currentSeconds = (int) newVal.toSeconds() % 60;

                    int totalMinutes = (int) mediaPlayer.getTotalDuration().toMinutes();
                    int totalSeconds = (int) mediaPlayer.getTotalDuration().toSeconds() % 60;

                    timeLabel.setText(String.format("%02d:%02d / %02d:%02d",
                            currentMinutes, currentSeconds, totalMinutes, totalSeconds));
                }
            });

            // Layout
            HBox controls = new HBox(10, playButton, timeSlider, timeLabel);
            controls.setAlignment(Pos.CENTER);
            controls.setPadding(new javafx.geometry.Insets(20));

            audioStage.setScene(new javafx.scene.Scene(controls, 500, 100));
            audioStage.setOnCloseRequest(e -> mediaPlayer.stop());
            audioStage.show();
        } catch (Exception e) {
            System.err.println("Error opening audio: " + e.getMessage());
        }
    }

    private void openDocument(File documentFile) {
        try {
            java.awt.Desktop.getDesktop().open(documentFile);
        } catch (Exception e) {
            System.err.println("Error opening document: " + e.getMessage());
        }
    }

    /**
     * Updates the statistics label.
     *
     * @param count The number of media items
     */
    private void updateStats(int count) {
        statsLabel.setText("Total: " + count + " m√©dia" + (count > 1 ? "s" : ""));
    }

    /**
     * Truncates a text to a maximum length.
     *
     * @param text The text to truncate
     * @param maxLength The maximum length
     * @return The truncated text
     */
    private String truncateText(String text, int maxLength) {
        if (text.length() <= maxLength) {
            return text;
        }
        return text.substring(0, maxLength - 3) + "...";
    }

    /**
     * Handles the close button action.
     *
     * @param event The action event
     */
    @FXML
    private void handleClose(ActionEvent event) {
        Stage stage = (Stage) mediaContainer.getScene().getWindow();
        stage.close();
    }
}


// File: src/main/java/org/example/client/gui/controllers/RegisterController.java
package org.example.client.gui.controllers;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;
import java.util.concurrent.CompletableFuture;

import org.example.shared.dto.RegistrationDTO;
import org.example.shared.util.ValidationUtils;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.stage.Stage;

public class RegisterController {

    private static final String SERVER_ADDRESS = "localhost";
    private static final int SERVER_PORT = 5000;

    @FXML
    private TextField emailField;
    
    @FXML
    private PasswordField passwordField;
    
    @FXML
    private PasswordField confirmPasswordField;
    
    @FXML
    private Button registerButton;
    
    @FXML
    private Label emailErrorLabel;
    
    @FXML
    private Label passwordErrorLabel;
    
    @FXML
    private Label confirmPasswordErrorLabel;
    
    private final ObjectMapper mapper;
    
    public RegisterController() {
        this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
    }
    
    @FXML
    public void initialize() {
        // Activer le bouton d'inscription seulement si tous les champs sont remplis
        registerButton.disableProperty().bind(
            emailField.textProperty().isEmpty().or(
            passwordField.textProperty().isEmpty().or(
            confirmPasswordField.textProperty().isEmpty()))
        );
        
        // R√©initialiser les messages d'erreur lorsque l'utilisateur modifie les champs
        emailField.textProperty().addListener((observable, oldValue, newValue) -> {
            emailErrorLabel.setVisible(false);
        });
        
        passwordField.textProperty().addListener((observable, oldValue, newValue) -> {
            passwordErrorLabel.setVisible(false);
        });
        
        confirmPasswordField.textProperty().addListener((observable, oldValue, newValue) -> {
            confirmPasswordErrorLabel.setVisible(false);
        });
    }
    
    @FXML
    private void handleRegister(final ActionEvent event) {
        // R√©initialiser les messages d'erreur
        emailErrorLabel.setVisible(false);
        passwordErrorLabel.setVisible(false);
        confirmPasswordErrorLabel.setVisible(false);
        
        // R√©cup√©rer les valeurs des champs
        final String email = emailField.getText().trim();
        final String password = passwordField.getText();
        final String confirmPassword = confirmPasswordField.getText();
        
        // Valider l'email
        if (!ValidationUtils.isValidEmail(email)) {
            emailErrorLabel.setText("Format d'email invalide");
            emailErrorLabel.setVisible(true);
            return;
        }
        
        // Valider le mot de passe
        if (!ValidationUtils.isStrongPassword(password)) {
            passwordErrorLabel.setText("Le mot de passe ne respecte pas les crit√®res de s√©curit√©");
            passwordErrorLabel.setVisible(true);
            return;
        }
        
        // V√©rifier que les mots de passe correspondent
        if (!ValidationUtils.doPasswordsMatch(password, confirmPassword)) {
            confirmPasswordErrorLabel.setText("Les mots de passe ne correspondent pas");
            confirmPasswordErrorLabel.setVisible(true);
            return;
        }
        
        // D√©binder la propri√©t√© disable avant de la modifier
        registerButton.disableProperty().unbind();
        registerButton.setDisable(true);
        
        // Cr√©er le DTO d'inscription
        final RegistrationDTO registrationDTO = new RegistrationDTO(email, password, confirmPassword);
        
        // Envoyer la requ√™te d'inscription au serveur
        CompletableFuture.runAsync(() -> {
            Socket socket = null;
            PrintWriter out = null;
            Scanner scanner = null;
            
            try {
                socket = new Socket(SERVER_ADDRESS, SERVER_PORT);
                out = new PrintWriter(socket.getOutputStream(), true);
                scanner = new Scanner(socket.getInputStream());
                
                // Envoyer une commande sp√©cifique pour indiquer qu'il s'agit d'une inscription
                out.println("REGISTER");
                
                // Envoyer les donn√©es d'inscription
                out.println(mapper.writeValueAsString(registrationDTO));
                
                // Lire la r√©ponse du serveur
                final String response = scanner.nextLine();
                
                Platform.runLater(() -> {
                    if ("REGISTER_SUCCESS".equals(response)) {
                        showSuccess("Inscription r√©ussie", "Votre compte a √©t√© cr√©√© avec succ√®s. Vous pouvez maintenant vous connecter.");
                        try {
                            openLoginWindow();
                        } catch (final IOException e) {
                            showError("Erreur d'interface", "Impossible d'ouvrir la fen√™tre de connexion: " + e.getMessage());
                            rebindRegisterButton();
                        }
                    } else {
                        showError("√âchec de l'inscription", response);
                        rebindRegisterButton();
                    }
                });
            } catch (final IOException e) {
                Platform.runLater(() -> {
                    showError("Erreur de connexion", "Impossible de se connecter au serveur: " + e.getMessage());
                    rebindRegisterButton();
                });
            } finally {
                if (scanner != null) scanner.close();
                if (out != null) out.close();
                if (socket != null) {
                    try {
                        socket.close();
                    } catch (IOException e) {
                        // Ignorer l'exception lors de la fermeture
                    }
                }
            }
        });
    }
    
    @FXML
    private void handleLoginLink(final ActionEvent event) {
        try {
            openLoginWindow();
        } catch (final IOException e) {
            showError("Erreur d'interface", "Impossible d'ouvrir la fen√™tre de connexion: " + e.getMessage());
        }
    }
    
    private void openLoginWindow() throws IOException {
        // Charger la vue de connexion
        final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
        final Parent loginView = loader.load();
        
        // Cr√©er et afficher la nouvelle sc√®ne
        final Scene loginScene = new Scene(loginView, 600, 400);
        final Stage currentStage = (Stage) registerButton.getScene().getWindow();
        
        currentStage.setTitle("Connexion");
        currentStage.setScene(loginScene);
        currentStage.centerOnScreen();
    }
    
    private void rebindRegisterButton() {
        registerButton.disableProperty().unbind(); // S'assurer qu'il n'y a pas de binding actif
        registerButton.setDisable(false); // R√©activer le bouton
        // Rebinder le bouton avec la condition initiale
        registerButton.disableProperty().bind(
            emailField.textProperty().isEmpty().or(
            passwordField.textProperty().isEmpty().or(
            confirmPasswordField.textProperty().isEmpty()))
        );
    }
    
    private void showError(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
    
    private void showSuccess(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}



// File: src/main/java/org/example/client/gui/Launcher.java
package org.example.client.gui;

/**
 * Classe de lancement pour l'application JavaFX.
 * Cette classe sert de point d'entr√©e principal pour √©viter les probl√®mes
 * de modules JavaFX lors de l'ex√©cution √† partir d'un JAR.
 */
public class Launcher {
    /**
     * Point d'entr√©e principal de l'application.
     * @param args Arguments de ligne de commande
     */
    public static void main(final String[] args) {
        // Lance l'application JavaFX
        ChatClientApplication.main(args);
    }
}




// File: src/main/java/org/example/client/gui/repository/JsonLocalMessageRepository.java
package org.example.client.gui.repository;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.example.shared.model.Message;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

/**
 * Classe de persistance locale pour l'historique des messages d'un utilisateur.
 * L'historique est stock√© sous forme de fichier JSON dans le dossier
 * "src/main/resources/client_data".
 */
public class JsonLocalMessageRepository {
    // Utilisation du r√©pertoire de projet pour stocker les donn√©es clients
    private static final String LOCAL_FOLDER = System.getProperty("user.dir") + File.separator + "client_messages";
    private final ObjectMapper objectMapper;

    public JsonLocalMessageRepository() {
        this.objectMapper = new ObjectMapper();
        // Register the JavaTimeModule for date-time support
        this.objectMapper.registerModule(new JavaTimeModule());
        // Pretty-print output
        this.objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        ensureLocalFolderExists();
    }

    private void ensureLocalFolderExists() {
        final Path folderPath = Paths.get(LOCAL_FOLDER);
        if (!folderPath.toFile().exists()) {
            try {
                folderPath.toFile().mkdirs();
            } catch (final Exception e) {
                System.err.println("Erreur lors de la cr√©ation du dossier client_data : " + e.getMessage());
            }
        }
    }

    /**
     * Renvoie le chemin complet du fichier de l'utilisateur.
     */
    private String getUserFilePath(final String userEmail) {
        // Remplacer les caract√®res sp√©ciaux pour cr√©er un nom de fichier valide
        return LOCAL_FOLDER + File.separator + userEmail.replace("@", "_at_") + "_messages.json";
    }

    /**
     * Charge la liste des messages locaux pour l'utilisateur.
     */
    public List<Message> loadLocalMessages(final String userEmail) throws IOException {
        final String filePath = getUserFilePath(userEmail);
        final File file = new File(filePath);
        if (!file.exists()) {
            return new ArrayList<>();
        }
        final CollectionType listType = objectMapper.getTypeFactory()
                .constructCollectionType(ArrayList.class, Message.class);
        return objectMapper.readValue(file, listType);
    }

    /**
     * Enregistre la liste des messages locaux pour l'utilisateur.
     */
    public void saveLocalMessages(final String userEmail, final List<Message> messages) throws IOException {
        final String filePath = getUserFilePath(userEmail);
        objectMapper.writeValue(new File(filePath), messages);
    }

    /**
     * Ajoute un nouveau message dans l'historique local pour l'utilisateur.
     * message envoy√© et recue
     */
    public void addLocalMessage(final String userEmail, final Message message) throws IOException {
        final List<Message> messages = loadLocalMessages(userEmail);
        messages.add(message);
        saveLocalMessages(userEmail, messages);
    }

    /**
     * Retourne la conversation entre deux utilisateurs en filtrant les messages
     * directs (sans groupId).
     */
    public List<Message> loadContactMessages(final String userEmail, final long myId, final long contactId)
            throws IOException {
        final List<Message> allMessages = loadLocalMessages(userEmail);
        final List<Message> contactMessages = allMessages.stream()
                .filter(msg -> msg.getGroupId() == null
                        && ((msg.getSenderUserId() == myId && msg.getReceiverUserId() != null
                                && msg.getReceiverUserId() == contactId)
                                || (msg.getSenderUserId() == contactId && msg.getReceiverUserId() != null
                                        && msg.getReceiverUserId() == myId)))
                .distinct()
                .collect(Collectors.toList());
        return contactMessages;
    }

    /**
     * Retourne la conversation de groupe en filtrant les messages dont le groupId
     * correspond
     * au groupe pass√©.
     */
    public List<Message> loadGroupMessages(final String userEmail, final long groupId) throws IOException {
        final List<Message> allMessages = loadLocalMessages(userEmail);
        final List<Message> groupMessages = new ArrayList<>();
        for (final Message msg : allMessages) {
            if (msg.getGroupId() != null && msg.getGroupId() == groupId) {
                groupMessages.add(msg);
            }
        }
        return groupMessages;
    }

    /**
     * Supprime un message de l'historique local pour l'utilisateur.
     */
    public void removeConversation(final String userEmail, final long myId, final long contactId) throws IOException {
        final List<Message> messages = loadLocalMessages(userEmail);
        messages.removeIf(m -> (m.getSenderUserId() == myId && m.getReceiverUserId() != null
                && m.getReceiverUserId() == contactId)
                || (m.getSenderUserId() == contactId && m.getReceiverUserId() != null
                        && m.getReceiverUserId() == myId));
        saveLocalMessages(userEmail, messages);
    }

    /**
     * R√©cup√®re le dernier message √©chang√© avec un contact sp√©cifique.
     */
    public Optional<Message> getLastContactMessage(final String userEmail, final long myId, final long contactId) throws IOException {
        return loadContactMessages(userEmail, myId, contactId).stream()
                .max(Comparator.comparing(Message::getTimestamp));
    }

    /**
     * R√©cup√®re le dernier message d'un groupe sp√©cifique.
     */
    public Optional<Message> getLastGroupMessage(final String userEmail, final long groupId) throws IOException {
        return loadGroupMessages(userEmail, groupId).stream()
                .max(Comparator.comparing(Message::getTimestamp));
    }
}


// File: src/main/java/org/example/client/gui/security/EncryptionUtils.java
package org.example.client.gui.security;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class EncryptionUtils {

    private static final String RSA_ALGORITHM = "RSA";
    private static final String RC4_ALGORITHM = "RC4"; // !! Utiliser "AES" en production !!
    private static final int RSA_KEY_SIZE = 2048;
    private static final int RC4_KEY_SIZE = 128; // Pour AES, utiliser 128, 192 ou 256

    // G√©n√®re une paire de cl√©s RSA
    public static KeyPair generateRsaKeyPair() throws NoSuchAlgorithmException {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(RSA_ALGORITHM);
        generator.initialize(RSA_KEY_SIZE);
        return generator.generateKeyPair();
    }

    // G√©n√®re une cl√© secr√®te RC4 (ou AES)
    public static SecretKey generateRc4SessionKey() throws NoSuchAlgorithmException {
         // Pour RC4, on peut cr√©er directement depuis des bytes, mais utilisons KeyGenerator pour la forme
         // KeyGenerator keyGen = KeyGenerator.getInstance(RC4_ALGORITHM);
         // keyGen.init(RC4_KEY_SIZE);
         // return keyGen.generateKey();

         // Alternative simple pour RC4 (taille variable, ici 128 bits / 16 bytes)
         SecureRandom random = new SecureRandom();
         byte[] keyBytes = new byte[RC4_KEY_SIZE / 8];
         random.nextBytes(keyBytes);
         return new SecretKeySpec(keyBytes, RC4_ALGORITHM);

        /* Pour AES:
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(256); // Ou 128, 192
        return keyGen.generateKey();
        */
    }

    // Chiffre des donn√©es avec une cl√© publique RSA
    public static byte[] encryptWithRsaPublicKey(byte[] data, PublicKey publicKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RSA_ALGORITHM); // Utiliser "RSA/ECB/PKCS1Padding" est souvent plus explicite
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        return cipher.doFinal(data);
    }

    // D√©chiffre des donn√©es avec une cl√© priv√©e RSA
    public static byte[] decryptWithRsaPrivateKey(byte[] data, PrivateKey privateKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RSA_ALGORITHM); // Utiliser "RSA/ECB/PKCS1Padding"
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        return cipher.doFinal(data);
    }

     // Chiffre des donn√©es avec une cl√© RC4 (ou AES)
    public static byte[] encryptWithRc4(byte[] data, SecretKey sessionKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RC4_ALGORITHM); // Pour AES: "AES/GCM/NoPadding" (n√©cessite IvParameterSpec) ou "AES/ECB/PKCS5Padding" (plus simple mais moins s√ªr)
        cipher.init(Cipher.ENCRYPT_MODE, sessionKey);
        return cipher.doFinal(data);
        // Pour AES/GCM, il faudrait g√©rer l'IV (Initialization Vector)
    }

    // D√©chiffre des donn√©es avec une cl√© RC4 (ou AES)
    public static byte[] decryptWithRc4(byte[] encryptedData, SecretKey sessionKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RC4_ALGORITHM); // Pour AES: "AES/GCM/NoPadding" ou "AES/ECB/PKCS5Padding"
        cipher.init(Cipher.DECRYPT_MODE, sessionKey);
        return cipher.doFinal(encryptedData);
         // Pour AES/GCM, il faudrait fournir l'IV utilis√© lors du chiffrement
    }

    // --- M√©thodes utilitaires pour convertir les cl√©s en String (Base64) pour stockage/transmission ---

    public static String keyToString(Key key) {
        return Base64.getEncoder().encodeToString(key.getEncoded());
    }

    public static PublicKey stringToPublicKey(String keyString) throws Exception {
        byte[] keyBytes = Base64.getDecoder().decode(keyString);
        X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(RSA_ALGORITHM);
        return keyFactory.generatePublic(spec);
    }

     public static PrivateKey stringToPrivateKey(String keyString) throws Exception {
        byte[] keyBytes = Base64.getDecoder().decode(keyString);
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(RSA_ALGORITHM);
        return keyFactory.generatePrivate(spec);
    }

     public static SecretKey stringToRc4SecretKey(String keyString) {
         byte[] keyBytes = Base64.getDecoder().decode(keyString);
         return new SecretKeySpec(keyBytes, RC4_ALGORITHM);
     }

      /* Pour AES:
     public static SecretKey stringToAesSecretKey(String keyString) {
         byte[] keyBytes = Base64.getDecoder().decode(keyString);
         return new SecretKeySpec(keyBytes, "AES");
     }
     */
}


// File: src/main/java/org/example/client/gui/security/KeyManager.java
package org.example.client.gui.security;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

import javax.crypto.SecretKey;

// G√®re les cl√©s RSA du client, les cl√©s publiques des contacts et les cl√©s de session
public class KeyManager {

    private static final String KEYS_DIR = System.getProperty("user.dir")
            + File.separator + "keys";
    private String KEY_PAIR_FILE = KEYS_DIR + File.separator + "rsa_keys.properties";
    private static final String PUBLIC_KEYS_FILE = KEYS_DIR + File.separator + "public_keys.properties";
    private static final String SESSION_KEYS_FILE = KEYS_DIR + File.separator + "session_keys.properties";

    private KeyPair userKeyPair;
    private Map<String, PublicKey> contactPublicKeys = new ConcurrentHashMap<>(); // userId -> PublicKey
    private Map<String, SecretKey> sessionKeys = new ConcurrentHashMap<>(); // userId -> SessionKey (RC4/AES)

    public KeyManager() {
        init();
        loadKeys();
    }
    
    // Nouveau constructeur acceptant l'email de l'utilisateur
    public KeyManager(String currentUserEmail) {
        if (currentUserEmail == null || currentUserEmail.trim().isEmpty()) {
            currentUserEmail = "default";
        }
        // Construire le nom de fichier de la paire de cl√©s avec l'identifiant utilisateur
        this.KEY_PAIR_FILE = KEYS_DIR + File.separator + "rsa_keys_" 
                + currentUserEmail.replace("@", "_at_") + ".properties";
        init();
        loadKeys();
    }
    
    private void init() {
        try {
            Files.createDirectories(Paths.get(KEYS_DIR));
        } catch (IOException ioEx) {
            System.err.println("Erreur cr√©ation dossier cl√©s: " + ioEx.getMessage());
        }
    }
    
    private void loadKeys() {
        try {
            File keyPairFile = new File(KEY_PAIR_FILE);
            if (!keyPairFile.exists()) {
                System.out.println("Aucune paire de cl√©s trouv√©e, g√©n√©ration...");
                generateAndSaveKeyPair();
            } else {
                loadKeyPair();
            }
            loadContactPublicKeys();
            loadSessionKeys();
        } catch (final Exception e) {
            System.err.println("Erreur lors du chargement des cl√©s: " + e.getMessage());
            if (userKeyPair == null) {
                generateAndSaveKeyPair();
            }
        }
    }

    private void loadKeyPair() throws Exception {
        File f = new File(KEY_PAIR_FILE);
        if (!f.exists())
            return;

        Properties props = new Properties();
        try (InputStream input = new FileInputStream(f)) {
            props.load(input);
            String pubKeyStr = props.getProperty("publicKey");
            String privKeyStr = props.getProperty("privateKey");
            if (pubKeyStr != null && privKeyStr != null) {
                PublicKey publicKey = EncryptionUtils.stringToPublicKey(pubKeyStr);
                PrivateKey privateKey = EncryptionUtils.stringToPrivateKey(privKeyStr);
                userKeyPair = new KeyPair(publicKey, privateKey);
                System.out.println("Paire de cl√©s RSA charg√©e.");
            }
        }
    }

    private void loadContactPublicKeys() {
        File f = new File(PUBLIC_KEYS_FILE);
        if (!f.exists())
            return;
        Properties props = new Properties();
        try (InputStream input = new FileInputStream(f)) {
            props.load(input);
            for (String userId : props.stringPropertyNames()) {
                try {
                    PublicKey pubKey = EncryptionUtils.stringToPublicKey(props.getProperty(userId));
                    contactPublicKeys.put(userId, pubKey);
                } catch (Exception e) {
                    System.err.println("Erreur chargement cl√© publique pour " + userId + ": " + e.getMessage());
                }
            }
            System.out.println("Cl√©s publiques des contacts charg√©es.");
        } catch (IOException e) {
            System.err.println("Erreur lecture fichier cl√©s publiques: " + e.getMessage());
        }
    }

    private void loadSessionKeys() {
        File f = new File(SESSION_KEYS_FILE);
        if (!f.exists())
            return;
        Properties props = new Properties();
        try (InputStream input = new FileInputStream(f)) {
            props.load(input);
            for (String userId : props.stringPropertyNames()) {
                try {
                    // !! Attention: Stocker les cl√©s de session n'est pas id√©al pour la Perfect
                    // Forward Secrecy
                    // Il vaut mieux les reg√©n√©rer √† chaque session. Ceci est un exemple simple.
                    SecretKey sessionKey = EncryptionUtils.stringToRc4SecretKey(props.getProperty(userId)); // Adapter
                                                                                                            // pour AES
                                                                                                            // si besoin
                    sessionKeys.put(userId, sessionKey);
                } catch (Exception e) {
                    System.err.println("Erreur chargement cl√© session pour " + userId + ": " + e.getMessage());
                }
            }
            System.out.println("Cl√©s de session (persist√©es) charg√©es.");
        } catch (IOException e) {
            System.err.println("Erreur lecture fichier cl√©s session: " + e.getMessage());
        }
    }

    private void generateAndSaveKeyPair() {
        try {
            userKeyPair = EncryptionUtils.generateRsaKeyPair();
            saveKeyPair();
            System.out.println("Nouvelle paire de cl√©s RSA g√©n√©r√©e et sauvegard√©e.");
        } catch (Exception e) {
            System.err.println("Impossible de g√©n√©rer/sauvegarder la paire de cl√©s RSA: " + e.getMessage());
            // G√©rer l'erreur critique - l'application ne peut pas fonctionner sans cl√©s
        }
    }

    private void saveKeyPair() throws IOException {
        if (userKeyPair == null)
            return;
        Properties props = new Properties();
        props.setProperty("publicKey", EncryptionUtils.keyToString(userKeyPair.getPublic()));
        props.setProperty("privateKey", EncryptionUtils.keyToString(userKeyPair.getPrivate())); // !! S√©curit√©: Stockage
                                                                                                // non chiffr√© !!

        try (OutputStream output = new FileOutputStream(KEY_PAIR_FILE)) {
            props.store(output, "RSA Key Pair - NE PAS MODIFIER");
        }
    }

    private void saveContactPublicKeys() {
        Properties props = new Properties();
        contactPublicKeys.forEach((userId, key) -> {
            props.setProperty(userId, EncryptionUtils.keyToString(key));
        });
        try (OutputStream output = new FileOutputStream(PUBLIC_KEYS_FILE)) {
            props.store(output, "Contact Public Keys");
        } catch (IOException e) {
            System.err.println("Erreur sauvegarde cl√©s publiques contacts: " + e.getMessage());
        }
    }

    private void saveSessionKeys() {
        Properties props = new Properties();
        sessionKeys.forEach((userId, key) -> {
            props.setProperty(userId, EncryptionUtils.keyToString(key));
        });
        try (OutputStream output = new FileOutputStream(SESSION_KEYS_FILE)) {
            props.store(output, "Session Keys (RC4/AES) - Pour d√©bogage/persistance simple");
        } catch (IOException e) {
            System.err.println("Erreur sauvegarde cl√©s session: " + e.getMessage());
        }
    }

    public PublicKey getUserPublicKey() {
        return (userKeyPair != null) ? userKeyPair.getPublic() : null;
    }

    public PrivateKey getUserPrivateKey() {
        return (userKeyPair != null) ? userKeyPair.getPrivate() : null;
    }

    public String getUserPublicKeyString() {
        PublicKey key = getUserPublicKey();
        return (key != null) ? EncryptionUtils.keyToString(key) : null;
    }

    public void storeContactPublicKey(String userId, PublicKey key) {
        contactPublicKeys.put(userId, key);
        saveContactPublicKeys(); // Sauvegarder imm√©diatement
    }

    public PublicKey getContactPublicKey(String userId) {
        return contactPublicKeys.get(userId);
    }

    public void storeSessionKey(String userId, SecretKey key) {
        sessionKeys.put(userId, key);
        // saveSessionKeys(); // D√©cider si on persiste les cl√©s de session
    }

    public SecretKey getSessionKey(String userId) {
        return sessionKeys.get(userId);
    }

    public void clearSessionKey(String userId) {
        sessionKeys.remove(userId);
        // saveSessionKeys();
    }

    public void clearAllSessionKeys() {
        sessionKeys.clear();
        // saveSessionKeys();
    }
}


// File: src/main/java/org/example/client/gui/service/AudioRecorderService.java
package org.example.client.gui.service;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.UUID;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.TargetDataLine;

/**
 * Service for recording audio messages.
 */
public class AudioRecorderService {

    private TargetDataLine targetLine;
    private boolean isRecording = false;
    private Thread recordingThread;
    private ByteArrayOutputStream byteOutputStream;

    // Audio format settings
    private static final float SAMPLE_RATE = 44100;
    private static final int SAMPLE_SIZE_BITS = 16;
    private static final int CHANNELS = 1;
    private static final boolean SIGNED = true;
    private static final boolean BIG_ENDIAN = false;
    private static final AudioFormat.Encoding ENCODING = AudioFormat.Encoding.PCM_SIGNED;

    /**
     * Starts recording audio.
     *
     * @throws LineUnavailableException If the audio line is unavailable
     */
    public void startRecording() throws LineUnavailableException {
        if (isRecording) {
            return;
        }

        // Create audio format
        AudioFormat format = new AudioFormat(
                ENCODING,
                SAMPLE_RATE,
                SAMPLE_SIZE_BITS,
                CHANNELS,
                (SAMPLE_SIZE_BITS / 8) * CHANNELS,
                SAMPLE_RATE,
                BIG_ENDIAN);

        // Get the target data line
        DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);
        if (!AudioSystem.isLineSupported(info)) {
            throw new LineUnavailableException("The system does not support the specified audio format");
        }

        targetLine = (TargetDataLine) AudioSystem.getLine(info);
        targetLine.open(format);
        targetLine.start();

        byteOutputStream = new ByteArrayOutputStream();
        isRecording = true;

        // Create a thread to read audio data
        recordingThread = new Thread(() -> {
            byte[] buffer = new byte[4096];
            int bytesRead;

            while (isRecording) {
                bytesRead = targetLine.read(buffer, 0, buffer.length);
                if (bytesRead > 0) {
                    byteOutputStream.write(buffer, 0, bytesRead);
                }
            }
        });

        recordingThread.start();
    }

    /**
     * Stops recording and returns the recorded audio file.
     *
     * @return The recorded audio file
     * @throws IOException If an I/O error occurs
     */
    public File stopRecording() throws IOException {
        if (!isRecording) {
            return null;
        }

        isRecording = false;

        try {
            // Wait for the recording thread to finish
            recordingThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        targetLine.stop();
        targetLine.close();

        // Create a WAV file from the recorded bytes
        byte[] audioBytes = byteOutputStream.toByteArray();
        AudioFormat format = new AudioFormat(
                ENCODING,
                SAMPLE_RATE,
                SAMPLE_SIZE_BITS,
                CHANNELS,
                (SAMPLE_SIZE_BITS / 8) * CHANNELS,
                SAMPLE_RATE,
                BIG_ENDIAN);

        ByteArrayInputStream byteInputStream = new ByteArrayInputStream(audioBytes);
        AudioInputStream audioInputStream = new AudioInputStream(byteInputStream, format, audioBytes.length / format.getFrameSize());

        // Create a temporary file
        File tempFile = File.createTempFile("audio_" + UUID.randomUUID().toString(), ".wav");
        try (FileOutputStream fos = new FileOutputStream(tempFile)) {
            AudioSystem.write(audioInputStream, AudioFileFormat.Type.WAVE, tempFile);
        } catch (IOException e) {
            throw new IOException("Failed to save audio file: " + e.getMessage(), e);
        }

        return tempFile;
    }

    /**
     * Checks if the system supports audio recording.
     *
     * @return true if audio recording is supported, false otherwise
     */
    public boolean isAudioRecordingSupported() {
        try {
            AudioFormat format = new AudioFormat(
                    ENCODING,
                    SAMPLE_RATE,
                    SAMPLE_SIZE_BITS,
                    CHANNELS,
                    (SAMPLE_SIZE_BITS / 8) * CHANNELS,
                    SAMPLE_RATE,
                    BIG_ENDIAN);

            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);
            return AudioSystem.isLineSupported(info);
        } catch (Exception e) {
            return false;
        }
    }
}


// File: src/main/java/org/example/client/gui/service/CallManager.java
package org.example.client.gui.service;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import javax.sound.sampled.TargetDataLine;

import org.example.shared.model.CallSession;
import org.example.shared.model.User;

import javafx.application.Platform;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;

/**
 * G√®re les appels audio via UDP pour l'application de chat.
 */
public class CallManager {
    // Param√®tres audio
    private static final float SAMPLE_RATE = 44100.0f;
    private static final int SAMPLE_SIZE_BITS = 16;
    private static final int CHANNELS = 1;
    private static final boolean SIGNED = true;
    private static final boolean BIG_ENDIAN = false;
    private static final AudioFormat AUDIO_FORMAT = new AudioFormat(
            SAMPLE_RATE, SAMPLE_SIZE_BITS, CHANNELS, SIGNED, BIG_ENDIAN);
    private static final int BUFFER_SIZE = 4096;

    // √âtat de l'appel
    private final AtomicBoolean isCallActive = new AtomicBoolean(false);
    private final AtomicBoolean isMicrophoneMuted = new AtomicBoolean(false);
    private final StringProperty callStatus = new SimpleStringProperty("Aucun appel en cours");
    
    // Informations sur l'appel en cours
    private CallSession currentSession;
    private User remoteUser;
    private InetAddress remoteAddress;
    private int remotePort;
    
    // Sockets et threads pour la communication UDP
    private DatagramSocket audioSocket;
    private Thread audioSenderThread;
    private Thread audioReceiverThread;
    private int localPort;
    
    // Lignes audio pour la capture et la lecture
    private TargetDataLine microphoneLine;
    private SourceDataLine speakerLine;
    
    // Singleton
    private static CallManager instance;
    
    private CallManager() {
        // Constructeur priv√© pour le singleton
    }
    
    public static synchronized CallManager getInstance() {
        if (instance == null) {
            instance = new CallManager();
        }
        return instance;
    }
    
    /**
     * Initialise un appel sortant vers un utilisateur.
     * 
     * @param targetUser L'utilisateur √† appeler
     * @param session Les informations de session d'appel
     * @return true si l'initialisation a r√©ussi
     */
    public boolean initiateCall(User targetUser, CallSession session) {
        if (isCallActive.get()) {
            return false; // Un appel est d√©j√† en cours
        }
        
        try {
            this.remoteUser = targetUser;
            this.currentSession = session;
            
            // Initialiser le socket UDP pour √™tre pr√™t √† envoyer/recevoir
            initializeUdpSocket();
            
            // Le port et l'adresse seront d√©finis lors de l'acceptation de l'appel
            updateCallStatus("Appel en cours vers " + targetUser.getDisplayNameOrEmail());
            return true;
        } catch (Exception e) {
            updateCallStatus("Erreur lors de l'initialisation de l'appel: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Initialise le socket UDP et r√©cup√®re le port local.
     */
    private void initializeUdpSocket() {
        try {
            // Fermer l'ancien socket s'il existe
            if (audioSocket != null && !audioSocket.isClosed()) {
                audioSocket.close();
            }
            
            // Cr√©er un nouveau socket avec un port sp√©cifique
            audioSocket = new DatagramSocket(0); // 0 = port al√©atoire attribu√© par le syst√®me
            localPort = audioSocket.getLocalPort();
            
            System.out.println("Socket UDP initialis√© sur le port local: " + localPort);
        } catch (SocketException e) {
            System.err.println("Erreur lors de l'initialisation du socket UDP: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Obtient le port local utilis√© par le socket UDP.
     * 
     * @return le port local
     */
    public int getLocalPort() {
        return localPort;
    }
    
    /**
     * Accepte un appel entrant et d√©marre la communication audio.
     * 
     * @param session Les informations de session d'appel
     * @param callerIp L'adresse IP de l'appelant
     * @param callerPort Le port UDP de l'appelant
     * @return true si l'acceptation a r√©ussi
     */
    public boolean acceptCall(CallSession session, String callerIp, int callerPort) {
        if (isCallActive.get()) {
            return false; // Un appel est d√©j√† en cours
        }
        
        try {
            this.currentSession = session;
            
            // Initialiser le socket UDP
            initializeUdpSocket();
            
            // Configurer l'adresse et le port distant
            this.remoteAddress = InetAddress.getByName(callerIp);
            this.remotePort = callerPort;
            
            System.out.println("Acceptation d'appel de " + callerIp + ":" + callerPort + 
                               " avec socket local sur port " + localPort);
            
            // D√©marrer la communication audio
            startAudioCommunication();
            isCallActive.set(true);
            updateCallStatus("En appel avec " + remoteUser.getDisplayNameOrEmail());
            return true;
        } catch (Exception e) {
            updateCallStatus("Erreur lors de l'acceptation de l'appel: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Configure la connexion apr√®s que l'autre partie a accept√© l'appel.
     * 
     * @param remoteIp L'adresse IP distante
     * @param remotePort Le port UDP distant
     * @return true si la configuration a r√©ussi
     */
    public boolean setupCallConnection(String remoteIp, int remotePort) {
        try {
            if (remotePort <= 0) {
                updateCallStatus("Erreur: Port distant invalide (" + remotePort + ")");
                return false;
            }
            
            this.remoteAddress = InetAddress.getByName(remoteIp);
            this.remotePort = remotePort;
            
            System.out.println("Configuration de la connexion d'appel avec " + remoteIp + ":" + remotePort + 
                               " depuis le port local " + localPort);
            
            // D√©marrer la communication audio
            startAudioCommunication();
            isCallActive.set(true);
            updateCallStatus("En appel avec " + remoteUser.getDisplayNameOrEmail());
            return true;
        } catch (UnknownHostException e) {
            updateCallStatus("Adresse IP invalide: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Termine l'appel en cours.
     */
    public void endCall() {
        if (!isCallActive.get()) {
            return;
        }
        
        isCallActive.set(false);
        
        // Arr√™ter les threads audio
        if (audioSenderThread != null) {
            audioSenderThread.interrupt();
        }
        if (audioReceiverThread != null) {
            audioReceiverThread.interrupt();
        }
        
        // Fermer les lignes audio
        if (microphoneLine != null && microphoneLine.isOpen()) {
            microphoneLine.stop();
            microphoneLine.close();
        }
        if (speakerLine != null && speakerLine.isOpen()) {
            speakerLine.stop();
            speakerLine.close();
        }
        
        // Fermer le socket
        if (audioSocket != null && !audioSocket.isClosed()) {
            audioSocket.close();
        }
        
        // R√©initialiser les variables
        currentSession = null;
        remoteUser = null;
        remoteAddress = null;
        remotePort = 0;
        
        updateCallStatus("Appel termin√©");
    }
    
    /**
     * Active/d√©sactive le microphone pendant l'appel.
     * 
     * @param muted true pour couper le micro, false pour l'activer
     */
    public void setMicrophoneMuted(boolean muted) {
        isMicrophoneMuted.set(muted);
        if (microphoneLine != null && microphoneLine.isOpen()) {
            if (muted) {
                microphoneLine.stop();
            } else {
                microphoneLine.start();
            }
        }
    }
    
    /**
     * D√©marre la communication audio (envoi et r√©ception).
     */
    private void startAudioCommunication() {
        try {
            // V√©rifier que le socket est initialis√©
            if (audioSocket == null || audioSocket.isClosed()) {
                initializeUdpSocket();
            }
            
            // Initialiser les lignes audio
            initAudioLines();
            
            // D√©marrer les threads d'envoi et de r√©ception
            startAudioSender();
            startAudioReceiver();
        } catch (LineUnavailableException e) {
            updateCallStatus("Erreur lors de l'initialisation des lignes audio: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Initialise les lignes audio pour la capture et la lecture.
     */
    private void initAudioLines() throws LineUnavailableException {
        // Ligne pour capturer l'audio du microphone
        DataLine.Info micInfo = new DataLine.Info(TargetDataLine.class, AUDIO_FORMAT);
        if (!AudioSystem.isLineSupported(micInfo)) {
            throw new LineUnavailableException("Le format audio n'est pas support√© pour la capture");
        }
        microphoneLine = (TargetDataLine) AudioSystem.getLine(micInfo);
        microphoneLine.open(AUDIO_FORMAT, BUFFER_SIZE);
        microphoneLine.start();
        
        // Ligne pour jouer l'audio re√ßu
        DataLine.Info speakerInfo = new DataLine.Info(SourceDataLine.class, AUDIO_FORMAT);
        if (!AudioSystem.isLineSupported(speakerInfo)) {
            throw new LineUnavailableException("Le format audio n'est pas support√© pour la lecture");
        }
        speakerLine = (SourceDataLine) AudioSystem.getLine(speakerInfo);
        speakerLine.open(AUDIO_FORMAT, BUFFER_SIZE);
        speakerLine.start();
    }
    
    /**
     * D√©marre le thread d'envoi audio.
     */
    private void startAudioSender() {
        audioSenderThread = new Thread(() -> {
            try {
                byte[] buffer = new byte[BUFFER_SIZE];
                
                while (isCallActive.get()) {
                    if (microphoneLine != null && microphoneLine.isOpen()) {
                        int bytesRead = microphoneLine.read(buffer, 0, buffer.length);
                        if (bytesRead > 0) {
                            // Envoyer les donn√©es audio
                            sendAudioPacket(buffer);
                        }
                    }
                    Thread.sleep(5); // Petite pause pour √©viter de surcharger le CPU
                }
            } catch (InterruptedException e) {
                // L'interruption est normale lors de la fin de l'appel
                if (isCallActive.get()) {
                    updateCallStatus("Erreur d'envoi audio: " + e.getMessage());
                }
            }
        });
        audioSenderThread.setDaemon(true);
        audioSenderThread.start();
    }
    
    /**
     * D√©marre le thread de r√©ception audio.
     */
    private void startAudioReceiver() {
        audioReceiverThread = new Thread(() -> {
            byte[] buffer = new byte[BUFFER_SIZE];
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
            
            try {
                while (isCallActive.get() && !Thread.currentThread().isInterrupted()) {
                    // Recevoir les donn√©es audio
                    audioSocket.receive(packet);
                    
                    // Jouer les donn√©es audio re√ßues
                    speakerLine.write(packet.getData(), 0, packet.getLength());
                }
            } catch (IOException e) {
                // L'interruption est normale lors de la fin de l'appel
                if (isCallActive.get()) {
                    updateCallStatus("Erreur de r√©ception audio: " + e.getMessage());
                }
            }
        });
        audioReceiverThread.setDaemon(true);
        audioReceiverThread.start();
    }
    
    /**
     * Envoie un paquet audio √† l'adresse distante.
     * 
     * @param audioData Les donn√©es audio √† envoyer
     */
    private void sendAudioPacket(byte[] audioData) {
        if (audioSocket == null || audioSocket.isClosed()) {
            updateCallStatus("Erreur: Socket UDP non initialis√©");
            return;
        }
        
        if (remoteAddress == null) {
            updateCallStatus("Erreur: Adresse distante non d√©finie");
            return;
        }
        
        if (remotePort <= 0) {
            updateCallStatus("Erreur d'envoi audio: Can't send to port " + remotePort);
            return;
        }
        
        try {
            DatagramPacket packet = new DatagramPacket(
                    audioData, audioData.length, remoteAddress, remotePort);
            
            audioSocket.send(packet);
            
            // D√©bogage - Afficher p√©riodiquement des informations sur l'envoi
            if (Math.random() < 0.01) { // ~1% des paquets pour √©viter de spammer la console
                System.out.println("Envoi d'un paquet audio de " + audioData.length + 
                                  " octets vers " + remoteAddress + ":" + remotePort + 
                                  " depuis le port local " + localPort);
            }
        } catch (IOException e) {
            // Afficher l'erreur compl√®te pour le d√©bogage
            System.err.println("Erreur lors de l'envoi du paquet audio: " + e.getMessage());
            e.printStackTrace();
            
            // Mettre √† jour le statut de l'appel avec un message d'erreur plus pr√©cis
            updateCallStatus("Erreur d'envoi audio: " + e.getMessage());
        }
    }
    
    /**
     * Met √† jour le statut de l'appel.
     */
    private void updateCallStatus(String status) {
        Platform.runLater(() -> callStatus.set(status));
    }
    
    /**
     * V√©rifie si un appel est en cours.
     */
    public boolean isCallActive() {
        return isCallActive.get();
    }
    
    /**
     * Obtient la propri√©t√© de statut d'appel pour la liaison UI.
     */
    public StringProperty callStatusProperty() {
        return callStatus;
    }
    
    /**
     * Obtient la session d'appel en cours.
     */
    public CallSession getCurrentSession() {
        return currentSession;
    }
    
    /**
     * Obtient l'utilisateur distant de l'appel en cours.
     */
    public User getRemoteUser() {
        return remoteUser;
    }
    
    /**
     * D√©finit l'utilisateur distant pour l'appel en cours.
     */
    public void setRemoteUser(User remoteUser) {
        this.remoteUser = remoteUser;
    }
}



// File: src/main/java/org/example/client/gui/service/ChatService.java
// filepath: src/main/java/org/example/client/gui/service/ChatService.java
package org.example.client.gui.service;

// ... autres imports ...
import org.example.client.gui.security.EncryptionUtils;
import org.example.client.gui.security.KeyManager;
import org.example.shared.model.Message;
import org.example.shared.model.User;
import org.example.shared.dto.Credentials;
import org.example.shared.model.CallSession;
import org.example.shared.model.CallSignal;
import org.example.shared.model.enums.MessageType;
import org.example.shared.dao.UserDAO; // Importer UserDAO
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.DeserializationFeature; // Pour ignorer props inconnues
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import javafx.application.Platform;

import java.io.*;
import java.net.Socket;
import java.net.ConnectException;
import java.net.SocketException;
import java.nio.charset.StandardCharsets;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.function.Consumer;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class ChatService {
    private static final String SERVER_ADDRESS = "localhost";
    private static final int SERVER_PORT = 5000;

    private Socket socket;
    private PrintWriter out;
    private BufferedReader in;
    private String userEmail;
    private long currentUserId = -1; // ID de l'utilisateur connect√©
    private final ObjectMapper objectMapper;
    private Consumer<Message> messageConsumer;
    private Consumer<CallSignal> callSignalConsumer;
    private Thread listenerThread;
    private volatile boolean isRunning = false; // Remplacer 'running' par 'isRunning'

    // Instances DAO pour la persistance locale (si n√©cessaire c√¥t√© client)
    // private final MessageDAO messageDAO;
    // private final GroupDAO groupDAO;
    private final UserDAO userDAO; // Pour obtenir l'ID utilisateur

    // New file service for handling multimedia
    private final FileService fileService;

    // --- AJOUTS POUR E2EE ---
    private final KeyManager keyManager;
    // --- FIN AJOUTS POUR E2EE ---

    // Constructeur modifi√©
    public ChatService(KeyManager keyManager) { // Accepter KeyManager
        this.keyManager = keyManager; // Stocker KeyManager
        this.objectMapper = new ObjectMapper()
            .registerModule(new JavaTimeModule())
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // Important
        // this.messageDAO = new MessageDAO(); // Si besoin c√¥t√© client
        // this.groupDAO = new GroupDAO(); // Si besoin c√¥t√© client
        this.userDAO = new UserDAO(); // Initialiser UserDAO
        this.fileService = new FileService();
    }

    public void setMessageConsumer(Consumer<Message> consumer) {
        this.messageConsumer = consumer;
    }

    public void setCallSignalConsumer(Consumer<CallSignal> consumer) {
        this.callSignalConsumer = consumer;
    }

    public long getCurrentUserId() {
        // Assurer que l'ID est charg√© apr√®s la connexion
        if (currentUserId == -1 && userEmail != null) {
            try {
                User user = userDAO.findUserByEmail(userEmail);
                if (user != null) {
                    currentUserId = user.getId();
                }
            } catch (Exception e) {
                System.err.println("Erreur r√©cup√©ration ID utilisateur: " + e.getMessage());
            }
        }
        return currentUserId;
    }

    // resp : initie la connexion avec le serveur / l'authentification
    public boolean connect(final Credentials credentials) throws IOException {
        try {
            // resp 1 : etablissement de la connexion avec le serveur (creation de la socket cot√© serveur)
            System.out.println("Connexion au serveur " + SERVER_ADDRESS + ":" + SERVER_PORT);
            socket = new Socket(SERVER_ADDRESS, SERVER_PORT);
            out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8), true);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));

            // Envoyer la commande de connexion pour diff√©rencier des requ√™tes d'inscription
            out.println("LOGIN"); // Commande texte simple

            // Envoyer les identifiants en JSON
            final String jsonCredentials = objectMapper.writeValueAsString(credentials);
            out.println(jsonCredentials);

            // Attendre la r√©ponse du serveur
            final String response = in.readLine();
            final boolean success = "AUTH_SUCCESS".equals(response);

            if (success) {
                this.userEmail = credentials.getEmail();
                this.currentUserId = getCurrentUserId(); // Charger l'ID utilisateur
                if (this.currentUserId == -1) {
                     throw new IOException("Impossible de r√©cup√©rer l'ID utilisateur pour " + this.userEmail);
                }
                isRunning = true; // Mettre √† jour isRunning
                startMessageListener();
                System.out.println("Authentification r√©ussie pour " + userEmail + " (ID: " + currentUserId + ")");
                // Envoyer la cl√© publique APR√àS succ√®s de l'authentification
                sendPublicKeyToServer();
            } else {
                System.out.println("√âchec de l'authentification: " + (response != null ? response : "R√©ponse nulle"));
                disconnect(); // Utiliser la m√©thode disconnect existante
            }

            return success;
        } catch (final ConnectException e) {
            throw new IOException(
                    "Impossible de se connecter au serveur. Assurez-vous que le serveur est d√©marr√© et accessible sur "
                            + SERVER_ADDRESS + ":" + SERVER_PORT,
                    e);
        } catch (final Exception e) {
             System.err.println("Erreur d√©taill√©e connexion: " + e);
             e.printStackTrace();
            throw new IOException("Erreur lors de la connexion ou authentification: " + e.getMessage(), e);
        }
    }

    // --- GESTION E2EE ---

    /** Envoie la cl√© publique de l'utilisateur actuel au serveur. */
    public void sendPublicKeyToServer() {
        if (!isConnected() || getCurrentUserId() == -1 || keyManager.getUserPublicKeyString() == null) {
            System.err.println("Impossible d'envoyer la cl√© publique: non connect√©, ID utilisateur ou cl√© manquante.");
            return;
        }
        try {
            System.out.println("Envoi de la cl√© publique au serveur...");
            // Utiliser un objet Message pour la cl√© publique pour une meilleure structure
            Message pubKeyMsg = new Message();
            pubKeyMsg.setSenderUserId(getCurrentUserId());
            pubKeyMsg.setType(MessageType.PUBLIC_KEY_RESPONSE); // On utilise ce type pour envoyer notre cl√©
            pubKeyMsg.setContent(keyManager.getUserPublicKeyString());

            sendMessage(pubKeyMsg); // Utiliser la m√©thode existante pour envoyer l'objet Message

            // Alternative avec commande texte simple (si ClientHandler est adapt√©)
            // String command = "PUB_KEY " + getCurrentUserId() + " " + keyManager.getUserPublicKeyString();
            // out.println(command);

        } catch (Exception e) {
            System.err.println("Erreur lors de l'envoi de la cl√© publique: " + e.getMessage());
        }
    }

    /** Demande la cl√© publique d'un autre utilisateur au serveur. */
    public void requestPublicKey(long targetUserId) {
         if (!isConnected()) return;
         try {
             System.out.println("Demande de la cl√© publique pour l'utilisateur ID: " + targetUserId);
             // Utiliser la factory pour cr√©er le message de requ√™te
             Message request = Message.newPublicKeyRequestMessage(getCurrentUserId(), targetUserId);
             sendMessage(request); // Envoyer l'objet Message
         } catch (IOException e) {
             System.err.println("Erreur demande cl√© publique pour ID " + targetUserId + ": " + e.getMessage());
         }
     }

    /**
     * Assure qu'une session E2EE est √©tablie avec le destinataire.
     * Demande la cl√© publique si n√©cessaire et envoie la cl√© de session RC4/AES.
     * @param recipientUserId L'ID du destinataire.
     * @throws IllegalStateException si la cl√© publique n'est pas disponible imm√©diatement.
     * @throws Exception pour toute autre erreur de chiffrement ou r√©seau.
     */
    private void ensureSession(long recipientUserId) throws Exception {
        // Si on n'a pas de cl√© de session pour ce contact, il faut l'√©tablir
        if (keyManager.getSessionKey(String.valueOf(recipientUserId)) == null) { // Utiliser l'ID comme cl√© de map
            System.out.println("Pas de cl√© de session pour ID " + recipientUserId + ". Tentative d'√©tablissement...");

            // 1. A-t-on la cl√© publique du destinataire ?
            PublicKey recipientPublicKey = keyManager.getContactPublicKey(String.valueOf(recipientUserId));
            if (recipientPublicKey == null) {
                System.out.println("Cl√© publique pour ID " + recipientUserId + " non trouv√©e localement. Demande au serveur...");
                requestPublicKey(recipientUserId);
                // Il faut attendre la r√©ponse. Pour l'instant, on l√®ve une exception.
                // Une meilleure gestion impliquerait une attente asynchrone ou une mise en file d'attente du message.
                throw new IllegalStateException("Cl√© publique pour l'utilisateur ID " + recipientUserId + " non disponible. Demande envoy√©e. R√©essayez d'envoyer le message.");
            }

            // 2. On a la cl√© publique, g√©n√©rer et envoyer la cl√© de session
            System.out.println("Cl√© publique trouv√©e pour ID " + recipientUserId + ". G√©n√©ration et envoi de la cl√© de session...");
            // G√©n√©rer une nouvelle cl√© de session RC4 (ou AES)
            SecretKey sessionKey = EncryptionUtils.generateRc4SessionKey(); // !! Changer pour AES !!
            String sessionKeyId = String.valueOf(System.currentTimeMillis()); // ID simple bas√© sur le temps

            // Chiffrer la cl√© de session avec la cl√© publique RSA du destinataire
            byte[] encryptedSessionKeyBytes = EncryptionUtils.encryptWithRsaPublicKey(sessionKey.getEncoded(), recipientPublicKey);

            // Cr√©er le message d'initialisation de session
            Message initMessage = Message.newSessionInitMessage(
                    getCurrentUserId(),
                    recipientUserId,
                    encryptedSessionKeyBytes
            );
            // initMessage.setSessionKeyId(sessionKeyId); // Optionnel: envoyer l'ID de cl√©

            // Envoyer le message d'init
            sendMessage(initMessage);

            // Stocker la cl√© de session localement associ√©e √† l'ID utilisateur
            keyManager.storeSessionKey(String.valueOf(recipientUserId), sessionKey);
            System.out.println("Message d'initialisation de session envoy√© √† ID " + recipientUserId);

        } else {
             System.out.println("Cl√© de session existante pour ID " + recipientUserId);
        }
    }

    /**
     * Envoie un message texte chiffr√© E2EE.
     * G√®re l'√©tablissement de session si n√©cessaire.
     * @param recipientUserId L'ID du destinataire.
     * @param textContent Le contenu texte √† chiffrer et envoyer.
     * @throws Exception Si l'envoi ou le chiffrement √©choue.
     */
    public void sendEncryptedTextMessage(long recipientUserId, String textContent) throws Exception {
        if (!isConnected() || recipientUserId <= 0 || textContent == null || textContent.isEmpty()) {
            throw new IllegalArgumentException("Param√®tres invalides pour sendEncryptedTextMessage");
        }

        // 1. Assurer que la session E2EE est pr√™te (peut lever une exception si cl√© publique manque)
        ensureSession(recipientUserId);

        // 2. R√©cup√©rer la cl√© de session (devrait exister apr√®s ensureSession)
        SecretKey sessionKey = keyManager.getSessionKey(String.valueOf(recipientUserId));
        if (sessionKey == null) {
            // Ne devrait pas arriver si ensureSession a r√©ussi, mais s√©curit√©
            throw new IllegalStateException("√âchec critique: Cl√© de session non trouv√©e apr√®s ensureSession pour ID " + recipientUserId);
        }
        String sessionKeyId = null; // R√©cup√©rer l'ID si on l'a stock√©/g√©n√©r√©

        // 3. Chiffrer le contenu avec la cl√© de session RC4 (ou AES)
        byte[] encryptedBytes = EncryptionUtils.encryptWithRc4(textContent.getBytes(StandardCharsets.UTF_8), sessionKey); // !! Changer pour AES !!

        // 4. Cr√©er l'objet Message chiffr√©
        Message message = Message.newEncryptedTextMessage(
                getCurrentUserId(),
                recipientUserId,
                encryptedBytes,
                sessionKeyId // Passer l'ID de session si utilis√©
        );

        // 5. Envoyer l'objet Message via la m√©thode existante
        sendMessage(message);
        System.out.println("Message texte chiffr√© envoy√© √† ID " + recipientUserId);
    }

    // --- FIN GESTION E2EE ---


    // M√©thode existante pour envoyer un objet Message (adapt√©e pour JSON)
    public void sendMessage(final Message message) throws IOException {
        if (out == null || socket == null || socket.isClosed()) {
            throw new IOException("Non connect√© au serveur.");
        }
        // Assigner l'exp√©diteur si ce n'est pas d√©j√† fait
        if (message.getSenderUserId() <= 0) {
             message.setSenderUserId(getCurrentUserId());
        }
        try {
            final String jsonMessage = objectMapper.writeValueAsString(message);
            out.println(jsonMessage);
        } catch (JsonProcessingException e) {
            throw new IOException("Erreur lors de la s√©rialisation du message en JSON", e);
        }
    }

    // M√©thode pour envoyer un objet CallSignal (adapt√©e pour JSON)
    public void sendCallSignal(final CallSignal signal) throws IOException {
         if (out == null || socket == null || socket.isClosed()) {
            throw new IOException("Non connect√© au serveur.");
        }
         // Assigner l'exp√©diteur si ce n'est pas d√©j√† fait
         if (signal.getSenderUserId() <= 0) { // Assumant un champ senderUserId dans CallSignal
             signal.setSenderUserId(getCurrentUserId());
         }
         try {
            final String jsonSignal = objectMapper.writeValueAsString(signal);
            out.println(jsonSignal);
        } catch (JsonProcessingException e) {
            throw new IOException("Erreur lors de la s√©rialisation du signal d'appel en JSON", e);
        }
    }


    private void startMessageListener() {
        if (listenerThread != null && listenerThread.isAlive()) {
            return; // D√©j√† en cours d'√©coute
        }
        isRunning = true;
        listenerThread = new Thread(() -> {
            try {
                String line;
                while (isRunning && (line = in.readLine()) != null) {
                    handleReceivedJson(line); // Traiter la ligne JSON re√ßue
                }
            } catch (SocketException e) {
                if (isRunning) {
                    System.err.println("Connexion perdue avec le serveur (SocketException): " + e.getMessage());
                } else {
                    System.out.println("Socket ferm√© normalement.");
                }
            } catch (IOException e) {
                if (isRunning) {
                    System.err.println("Erreur de lecture du serveur: " + e.getMessage());
                    e.printStackTrace();
                }
            } catch (Exception e) { // Capturer autres exceptions (ex: JSON parsing)
                 if (isRunning) {
                    System.err.println("Erreur inattendue dans le listener: " + e.getMessage());
                    e.printStackTrace();
                }
            } finally {
                isRunning = false;
                // Ne pas appeler disconnect() ici pour √©viter boucle infinie si disconnect cause l'erreur
                System.out.println("Thread d'√©coute arr√™t√©.");
                // Notifier l'UI de la d√©connexion ?
            }
        });
        listenerThread.start();
    }

    // Traite une ligne JSON re√ßue du serveur
    private void handleReceivedJson(String jsonLine) {
        try {
            // Essayer de d√©terminer si c'est un Message ou un CallSignal (ou autre)
            // On peut regarder des champs cl√©s ou utiliser une approche plus robuste
            if (jsonLine.contains("\"type\"") && (jsonLine.contains("\"senderUserId\"") || jsonLine.contains("\"encryptedContentBase64\""))) { // Heuristique simple pour Message
                Message message = objectMapper.readValue(jsonLine, Message.class);
                handleReceivedMessage(message);
            } else if (jsonLine.contains("\"type\"") && jsonLine.contains("\"sessionId\"")) { // Heuristique simple pour CallSignal
                CallSignal signal = objectMapper.readValue(jsonLine, CallSignal.class);
                if (callSignalConsumer != null) {
                    Platform.runLater(() -> callSignalConsumer.accept(signal));
                }
            }
             // G√©rer d'autres types d'objets JSON si n√©cessaire (ex: UserStatusUpdate)
             else if (jsonLine.contains("\"online\"") && jsonLine.contains("\"userId\"")) { // Heuristique pour UserStatusUpdate
                 // Supposons une classe UserStatusUpdate comme dans l'exemple pr√©c√©dent
                 // UserStatusUpdate update = objectMapper.readValue(jsonLine, UserStatusUpdate.class);
                 // if (userStatusListener != null) {
                 //     Platform.runLater(() -> userStatusListener.updateUserStatus(update.getUserId(), update.isOnline()));
                 // }
                 System.out.println("Mise √† jour de statut re√ßue (non trait√©e) : " + jsonLine);
             }
            else {
                System.out.println("JSON re√ßu non reconnu: " + jsonLine);
            }
        } catch (JsonProcessingException e) {
            System.err.println("Erreur de parsing JSON: " + e.getMessage() + " | JSON: " + jsonLine);
        } catch (Exception e) {
             System.err.println("Erreur traitement JSON re√ßu: " + e.getMessage() + " | JSON: " + jsonLine);
             e.printStackTrace();
        }
    }

    // Traite un objet Message d√©s√©rialis√©
    private void handleReceivedMessage(Message message) {
        System.out.println("Message re√ßu: " + message); // Log brut

        switch (message.getType()) {
            case PUBLIC_KEY_RESPONSE:
                handlePublicKeyResponse(message);
                break;
            case E2E_SESSION_INIT:
                handleSessionInit(message);
                break;
            case TEXT:
                // V√©rifier si le message TEXT est chiffr√© ou non
                if (message.getEncryptedContent() != null) {
                    handleEncryptedTextMessage(message);
                } else if (message.getContent() != null && messageConsumer != null) {
                    // Message texte simple non chiffr√© (ou syst√®me)
                    Platform.runLater(() -> messageConsumer.accept(message));
                }
                break;
            case SYSTEM:
                // Afficher directement les messages syst√®me
                if (messageConsumer != null && message.getContent() != null) {
                     Platform.runLater(() -> messageConsumer.accept(message));
                }
                break;
            // G√©rer les types MEDIA (pour l'instant, on les passe au consumer)
            case IMAGE:
            case VIDEO:
            case AUDIO:
            case DOCUMENT:
                 if (messageConsumer != null) {
                     // TODO: G√©rer le t√©l√©chargement/d√©chiffrement E2EE des m√©dias ici si n√©cessaire
                     Platform.runLater(() -> messageConsumer.accept(message));
                 }
                 break;
            default:
                System.out.println("Type de message non g√©r√©: " + message.getType());
        }
    }

    // --- M√©thodes de traitement E2EE sp√©cifiques ---

    private void handlePublicKeyResponse(Message message) {
        // Le contenu contient la cl√© publique en Base64
        String publicKeyString = message.getContent();
        long keyOwnerUserId = message.getSenderUserId(); // L'ID de l'utilisateur dont c'est la cl√©

        if (publicKeyString != null && !publicKeyString.isEmpty() && keyOwnerUserId > 0) {
            try {
                PublicKey publicKey = EncryptionUtils.stringToPublicKey(publicKeyString);
                keyManager.storeContactPublicKey(String.valueOf(keyOwnerUserId), publicKey); // Utiliser ID comme cl√©
                System.out.println("Cl√© publique pour ID " + keyOwnerUserId + " stock√©e.");
                // Informer l'UI ou d√©clencher une action (ex: r√©essayer d'envoyer un message en attente) ?
            } catch (Exception e) {
                System.err.println("Erreur conversion/stockage cl√© publique re√ßue pour ID " + keyOwnerUserId + ": " + e.getMessage());
            }
        } else {
             System.err.println("R√©ponse de cl√© publique invalide re√ßue: " + message);
        }
    }

    private void handleSessionInit(Message message) {
        // Ce message contient la cl√© de session RC4/AES, chiffr√©e avec NOTRE cl√© publique RSA
        byte[] encryptedSessionKey = message.getEncryptedContent(); // Vient de getEncryptedContentBase64 via Jackson
        long senderId = message.getSenderUserId();
        PrivateKey myPrivateKey = keyManager.getUserPrivateKey();

        if (encryptedSessionKey != null && senderId > 0 && myPrivateKey != null) {
            try {
                // D√©chiffrer la cl√© de session avec notre cl√© priv√©e RSA
                byte[] sessionKeyBytes = EncryptionUtils.decryptWithRsaPrivateKey(encryptedSessionKey, myPrivateKey);
                // Recr√©er la cl√© secr√®te (utiliser l'algo appropri√©)
                SecretKey sessionKey = new SecretKeySpec(sessionKeyBytes, "RC4"); // !! Changer pour AES !!

                // Stocker la cl√© de session associ√©e √† l'exp√©diteur (utiliser ID)
                keyManager.storeSessionKey(String.valueOf(senderId), sessionKey);
                System.out.println("Cl√© de session E2EE √©tablie avec ID " + senderId);

                // Optionnel: Confirmer l'√©tablissement de la session √† l'autre client ?
                // Optionnel: D√©clencher l'envoi de messages en attente ?

            } catch (Exception e) {
                System.err.println("√âchec d√©chiffrement/stockage cl√© de session de ID " + senderId + ": " + e.getMessage());
                e.printStackTrace();
            }
        } else {
             System.err.println("Message d'initialisation de session invalide re√ßu: " + message);
        }
    }

    private void handleEncryptedTextMessage(Message message) {
        // Message texte chiffr√© avec la cl√© de session RC4/AES
        byte[] encryptedContent = message.getEncryptedContent();
        long senderId = message.getSenderUserId();
        SecretKey sessionKey = keyManager.getSessionKey(String.valueOf(senderId)); // Utiliser ID

        if (encryptedContent != null && senderId > 0 && sessionKey != null) {
            try {
                // D√©chiffrer le contenu avec la cl√© de session
                byte[] decryptedBytes = EncryptionUtils.decryptWithRc4(encryptedContent, sessionKey); // !! Changer pour AES !!
                String decryptedContent = new String(decryptedBytes, StandardCharsets.UTF_8);

                // Cr√©er un nouveau message (ou modifier l'existant) avec le contenu d√©chiffr√©
                // pour le passer au consumer standard de l'UI.
                Message decryptedMessage = new Message();
                decryptedMessage.setId(message.getId()); // Garder les m√©tadonn√©es
                decryptedMessage.setSenderUserId(senderId);
                decryptedMessage.setReceiverUserId(message.getReceiverUserId());
                decryptedMessage.setGroupId(message.getGroupId());
                decryptedMessage.setTimestamp(message.getTimestamp());
                decryptedMessage.setStatus(message.getStatus());
                decryptedMessage.setType(MessageType.TEXT); // C'est redevenu un message texte simple
                decryptedMessage.setContent(decryptedContent); // Mettre le contenu d√©chiffr√©

                // Notifier l'UI avec le message d√©chiffr√©
                if (messageConsumer != null) {
                    Platform.runLater(() -> messageConsumer.accept(decryptedMessage));
                }

            } catch (Exception e) {
                System.err.println("√âchec du d√©chiffrement du message de ID " + senderId + ": " + e.getMessage());
                // Afficher un message d'erreur dans l'UI ?
                Message errorMsg = createErrorMessage(message, "[Erreur de d√©chiffrement]");
                 if (messageConsumer != null) {
                     Platform.runLater(() -> messageConsumer.accept(errorMsg));
                 }
            }
        } else {
             System.err.println("Message texte chiffr√© invalide ou cl√© de session manquante pour ID " + senderId + ": " + message);
             Message errorMsg = createErrorMessage(message, "[Message illisible - Session E2EE non √©tablie?]");
              if (messageConsumer != null) {
                  Platform.runLater(() -> messageConsumer.accept(errorMsg));
              }
        }
    }

    // Helper pour cr√©er un message d'erreur √† afficher dans l'UI
    private Message createErrorMessage(Message original, String errorText) {
         Message errorMsg = new Message();
         errorMsg.setId(original.getId());
         errorMsg.setSenderUserId(original.getSenderUserId());
         errorMsg.setReceiverUserId(original.getReceiverUserId());
         errorMsg.setGroupId(original.getGroupId());
         errorMsg.setTimestamp(original.getTimestamp());
         errorMsg.setStatus(original.getStatus());
         errorMsg.setType(MessageType.SYSTEM); // Marquer comme syst√®me/erreur
         errorMsg.setContent(errorText);
         return errorMsg;
    }


    // --- M√©thodes utilitaires et existantes ---

    public void disconnect() { // Surcharge pour correspondre √† l'appel dans ChatController
         // Pas besoin de envoyer LOGOUT ici si closeResources le fait via le finally du thread
         closeResources();
    }

    private void closeResources() {
         isRunning = false; // Arr√™ter la boucle d'√©coute
         if (listenerThread != null) {
             listenerThread.interrupt(); // Interrompre le thread s'il est bloqu√© sur readLine
         }
         try {
             if (out != null) out.close();
         } catch (Exception e) { /* Ignorer */ }
         try {
             if (in != null) in.close();
         } catch (Exception e) { /* Ignorer */ }
         try {
             if (socket != null && !socket.isClosed()) socket.close();
         } catch (IOException e) { /* Ignorer */ }
         out = null;
         in = null;
         socket = null;
         listenerThread = null; // Permettre la recr√©ation
         // Ne pas effacer userEmail/currentUserId ici, utile pour savoir qui √©tait connect√©
         System.out.println("Ressources r√©seau ferm√©es.");
         // Effacer les cl√©s de session ? Bonne pratique pour la s√©curit√©.
         // keyManager.clearAllSessionKeys();
    }

    public boolean isConnected() {
        return socket != null && socket.isConnected() && !socket.isClosed() && isRunning;
    }

    // --- M√©thodes pour la gestion des m√©dias ---
    public File getMediaFile(final Message message) {
        if (!message.isMediaMessage()) {
            throw new IllegalArgumentException("Not a media message");
        }
        File file = fileService.getFile(message.getContent());
        System.out.println("Looking for media file at: " + file.getAbsolutePath());
        System.out.println("File exists: " + file.exists());
        return file;
    }

    // Adapter ces m√©thodes pour utiliser l'ID utilisateur (long)
    public Message createDirectMediaMessage(final String senderEmail, final String receiverEmail, final File mediaFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);
        final User receiver = userDAO.findUserByEmail(receiverEmail);

        // Detect file type and save the file
        final MessageType type = fileService.detectMessageType(mediaFile.getName());
        // relative path of the media
        final String filePath = fileService.saveFile(mediaFile, type, mediaFile.getName());
        final String mimeType = fileService.getMimeType(mediaFile);

        return Message.newDirectMediaMessage(
                sender.getId(),
                receiver.getId(),
                filePath,
                type,
                mediaFile.getName(),
                mediaFile.length(),
                mimeType);
    }

    public Message createGroupMediaMessage(final String senderEmail, final long groupId, final File mediaFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);

        // Detect file type and save the file
        final MessageType type = fileService.detectMessageType(mediaFile.getName());
        final String filePath = fileService.saveFile(mediaFile, type, mediaFile.getName());
        final String mimeType = fileService.getMimeType(mediaFile);

        return Message.newGroupMediaMessage(
                sender.getId(),
                groupId,
                filePath,
                type,
                mediaFile.getName(),
                mediaFile.length(),
                mimeType);
    }

    public Message createDirectAudioMessage(final String senderEmail, final String receiverEmail, final File audioFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);
        final User receiver = userDAO.findUserByEmail(receiverEmail);

        // Save the audio file
        final String filePath = fileService.saveFile(audioFile, MessageType.AUDIO, audioFile.getName());
        final String mimeType = fileService.getMimeType(audioFile);

        return Message.newDirectMediaMessage(
                sender.getId(),
                receiver.getId(),
                filePath,
                MessageType.AUDIO,
                audioFile.getName(),
                audioFile.length(),
                mimeType);
    }

    public Message createGroupAudioMessage(final String senderEmail, final long groupId, final File audioFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);

        // Save the audio file
        final String filePath = fileService.saveFile(audioFile, MessageType.AUDIO, audioFile.getName());
        final String mimeType = fileService.getMimeType(audioFile);

        return Message.newGroupMediaMessage(
                sender.getId(),
                groupId,
                filePath,
                MessageType.AUDIO,
                audioFile.getName(),
                audioFile.length(),
                mimeType);
    }

     // --- M√©thodes pour les appels (existantes, adapt√©es pour JSON/ID) ---
     public CallSignal createCallRequest(CallSession session, String targetEmail) throws IOException {
         long targetId = userDAO.findUserByEmail(targetEmail).getId();
         return CallSignal.createCallRequest(session.getSessionId(), getCurrentUserId(), targetId);
     }
     public CallSignal createCallAccept(String sessionId, long targetUserId, int localPort) throws IOException {
         // L'IP locale peut √™tre ajout√©e ici ou c√¥t√© serveur
         String localIp = socket.getLocalAddress().getHostAddress(); // Utiliser l'IP de la socket connect√©e
         return CallSignal.createCallAccept(sessionId, getCurrentUserId(), targetUserId, localIp, localPort);
     }
     public CallSignal createCallReject(String sessionId, long targetUserId) throws IOException {
         return CallSignal.createCallReject(sessionId, getCurrentUserId(), targetUserId);
     }
     public CallSignal createCallEnd(String sessionId, long targetUserId) throws IOException {
         return CallSignal.createCallEnd(sessionId, getCurrentUserId(), targetUserId);
     }

}


// File: src/main/java/org/example/client/gui/service/ContactService.java
package org.example.client.gui.service;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.dao.ContactDAO;
import org.example.shared.dao.UserDAO;
import org.example.shared.model.Contact;
import org.example.shared.model.User;

/**
 * Service d√©di√© √† la gestion des contacts.
 */
public class ContactService {

    private final UserDAO userDAO;
    private final ContactDAO contactDAO;
    private final UserService userService = new UserService();

    public ContactService() {
        this.userDAO = new UserDAO();
        this.contactDAO = new ContactDAO();
    }

    /**
     * R√©cup√®re la liste des emails des contacts
     */
    public List<String> getContacts(final String userEmail) throws IOException {
        final User user = userDAO.findUserByEmail(userEmail);
        if (user == null) {
            throw new IOException("Utilisateur non trouv√©: " + userEmail);
        }
        return contactDAO.getContactsByUserId(user.getId());
    }

    /**
     * R√©cup√®re la liste des objets User complets pour les contacts
     */
    public List<User> getContactUsers(final String userEmail) throws IOException {
        final List<String> contactEmails = getContacts(userEmail);
        final List<User> users = new ArrayList<>();
        
        for (final String email : contactEmails) {
            final User user = userService.getUserByEmail(email);
            if (user != null) {
                users.add(user);
            }
        }
        
        return users;
    }

    /**
     * Ajoute un contact et retourne l'objet User correspondant
     */
    public User addContactUser(final String userEmail, final String contactEmail) throws IOException {
        final boolean added = addContact(userEmail, contactEmail);
        if (added) {
            return userService.getUserByEmail(contactEmail);
        }
        return null;
    }

    /**
     * Ajoute un contact par email
     */
    public boolean addContact(final String userEmail, final String contactEmail) throws IOException {
        final User user = userDAO.findUserByEmail(userEmail);
        final User contactUser = userDAO.findUserByEmail(contactEmail);

        if (user == null) {
            throw new IOException("Utilisateur non trouv√©: " + userEmail);
        }
        if (contactUser == null) {
            throw new IOException("Contact non trouv√©: " + contactEmail);
        }
        if (user.getId() == contactUser.getId()) {
            throw new IllegalArgumentException("Vous ne pouvez pas vous ajouter vous-m√™me comme contact.");
        }

        final Contact first_Contact = new Contact(user.getId(), contactUser.getId());
        final Contact second_Contact = new Contact(contactUser.getId(), user.getId());


        contactDAO.createContact(first_Contact);
        contactDAO.createContact(second_Contact);
        return true;
    }

    /**
     * Supprime un contact
     */
    public boolean removeContact(final String userEmail, final String contactEmail) throws IOException {
        final User user = userDAO.findUserByEmail(userEmail);
        final User contactUser = userDAO.findUserByEmail(contactEmail);

        if (user == null) {
            throw new IOException("Utilisateur non trouv√©: " + userEmail);
        }
        if (contactUser == null) {
            return false;
        }

        return contactDAO.deleteContact(user.getId(), contactUser.getId());
    }

    /**
     * V√©rifie si un utilisateur est en ligne.
     */
    public boolean isUserOnline(final long userId) throws IOException {
        final User user = userService.getUserById(userId);
        if (user == null) {
            throw new IOException("Utilisateur non trouv√© avec l'ID: " + userId);
        }
        return user.isOnline();
    }
}



// File: src/main/java/org/example/client/gui/service/FileService.java
package org.example.client.gui.service;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

import org.example.shared.model.Message;
import org.example.shared.model.enums.MessageType;

/**
 * Service for handling file operations for multimedia messages.
 */
public class FileService {

    // Base directory for storing media files
    private static final String MEDIA_DIR = System.getProperty("user.dir") + File.separator +
            "media_files";

    // Subdirectories for different media types
    private static final String IMAGES_DIR = MEDIA_DIR + File.separator + "images";
    private static final String VIDEOS_DIR = MEDIA_DIR + File.separator + "videos";
    private static final String DOCUMENTS_DIR = MEDIA_DIR + File.separator + "documents";
    private static final String AUDIO_DIR = MEDIA_DIR + File.separator + "audio";

    // Maximum file size (20MB)
    private static final long MAX_FILE_SIZE = 20 * 1024 * 1024;

    /**
     * Constructor - creates necessary directories if they don't exist.
     */
    public FileService() {
        createDirectories();
    }

    /**
     * Creates all necessary directories for storing media files.
     */

    private void createDirectories() {
        try {
            File mediaDir = new File(MEDIA_DIR);
            if (!mediaDir.exists()) {
                boolean created = mediaDir.mkdirs();
                System.out.println("Created main media directory: " + created + " at " + mediaDir.getAbsolutePath());
            } else {
                System.out.println("Main media directory already exists at: " + mediaDir.getAbsolutePath());
            }

            // Create each subdirectory individually and log results
            File imagesDir = new File(IMAGES_DIR);
            if (!imagesDir.exists()) {
                boolean created = imagesDir.mkdirs();
                System.out.println("Created images directory: " + created + " at " + imagesDir.getAbsolutePath());
            } else {
                System.out.println("Images directory already exists at: " + imagesDir.getAbsolutePath());
            }

            File videosDir = new File(VIDEOS_DIR);
            if (!videosDir.exists()) {
                boolean created = videosDir.mkdirs();
                System.out.println("Created videos directory: " + created + " at " + videosDir.getAbsolutePath());
            } else {
                System.out.println("Videos directory already exists at: " + videosDir.getAbsolutePath());
            }

            File documentsDir = new File(DOCUMENTS_DIR);
            if (!documentsDir.exists()) {
                boolean created = documentsDir.mkdirs();
                System.out.println("Created documents directory: " + created + " at " + documentsDir.getAbsolutePath());
            } else {
                System.out.println("Documents directory already exists at: " + documentsDir.getAbsolutePath());
            }

            File audioDir = new File(AUDIO_DIR);
            if (!audioDir.exists()) {
                boolean created = audioDir.mkdirs();
                System.out.println("Created audio directory: " + created + " at " + audioDir.getAbsolutePath());
            } else {
                System.out.println("Audio directory already exists at: " + audioDir.getAbsolutePath());
            }

            // Log summary
            System.out.println("Directory structure setup complete. Media files will be stored in: " + MEDIA_DIR);
        } catch (Exception e) {
            System.err.println("Error creating directories: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Saves a file to the appropriate directory and returns the path where it was saved.
     */
    public String saveFile(File file, MessageType type, String originalFilename) throws IOException {
        System.out.println("//// Saving file of type " + type);
        // Check file size
        if (file.length() > MAX_FILE_SIZE) {
            throw new IllegalArgumentException("File is too large. Maximum size is " +
                    (MAX_FILE_SIZE / (1024 * 1024)) + "MB");
        }

        // Get the appropriate directory
        String directory;
        switch (type) {
            case IMAGE:
                directory = IMAGES_DIR;
                break;
            case VIDEO:
                directory = VIDEOS_DIR;
                break;
            case DOCUMENT:
                directory = DOCUMENTS_DIR;
                break;
            case AUDIO:
                directory = AUDIO_DIR;
                break;
            default:
                throw new IllegalArgumentException("Invalid file type: " + type);
        }

        // Generate a unique filename to avoid collisions
        String fileExtension = getFileExtension(originalFilename);
        String uniqueFilename = UUID.randomUUID().toString() + fileExtension;
        String fullPath = directory + File.separator + uniqueFilename;

        System.out.println("Full path for saving: " + fullPath);

        // Copy the file
        try (InputStream in = new FileInputStream(file);
             OutputStream out = new FileOutputStream(fullPath)) {
            byte[] buffer = new byte[4096];
            int length;
            while ((length = in.read(buffer)) > 0) {
                out.write(buffer, 0, length);
            }
        }

        // IMPORTANT: Always use the same separator character (/) for storage in the database
        // We'll handle the platform-specific conversion when retrieving the file
        return type.name().toLowerCase() + "/" + uniqueFilename;
    }

    /**
     * Gets the full path to a media file from its relative path.
     */
    public File getFile(String relativePath) {
        if (relativePath == null || relativePath.isEmpty()) {
            throw new IllegalArgumentException("Relative path cannot be null or empty");
        }

        // Debug the input path
        System.out.println("Original relative path: " + relativePath);

        // Split the path into type and filename
        String[] parts = relativePath.split("/");
        if (parts.length < 2) {
            parts = relativePath.split("\\\\"); // Try Windows separator
        }

        // If we can't split, use the raw path (suboptimal but better than failing)
        if (parts.length < 2) {
            System.out.println("Warning: Cannot split path properly: " + relativePath);
            String normalizedPath = relativePath.replace('/', File.separatorChar).replace('\\', File.separatorChar);
            File file = new File(MEDIA_DIR + File.separator + normalizedPath);
            System.out.println("Falling back to direct path: " + file.getAbsolutePath());
            return file;
        }

        String typeDir = parts[0];
        String filename = parts[1];

        // Construct proper directory based on media type
        String typeDirectory;
        switch (typeDir.toLowerCase()) {
            case "image":
                typeDirectory = IMAGES_DIR;
                break;
            case "video":
                typeDirectory = VIDEOS_DIR;
                break;
            case "document":
                typeDirectory = DOCUMENTS_DIR;
                break;
            case "audio":
                typeDirectory = AUDIO_DIR;
                break;
            default:
                // Fallback to base directory with the original relative path
                System.out.println("Unknown media type: " + typeDir);
                String normalizedPath = relativePath.replace('/', File.separatorChar).replace('\\', File.separatorChar);
                File file = new File(MEDIA_DIR + File.separator + normalizedPath);
                System.out.println("Falling back to direct path: " + file.getAbsolutePath());
                return file;
        }

        // Construct the full path
        File file = new File(typeDirectory + File.separator + filename);
        System.out.println("Getting media file at: " + file.getAbsolutePath());
        System.out.println("File exists: " + file.exists());

        return file;
    }
    /**
     * Detects the message type based on the file extension.
     *
     * @param filename The name of the file
     * @return The detected message type
     */
    public MessageType detectMessageType(String filename) {
        String extension = getFileExtension(filename).toLowerCase();

        // Image formats
        if (extension.matches("\\.(jpg|jpeg|png|gif|bmp|webp)$")) {
            return MessageType.IMAGE;
        }

        // Video formats
        if (extension.matches("\\.(mp4|avi|mov|wmv|flv|mkv|webm)$")) {
            return MessageType.VIDEO;
        }

        // Audio formats
        if (extension.matches("\\.(mp3|wav|ogg|aac|wma|flac)$")) {
            return MessageType.AUDIO;
        }

        // Default to document for all other types
        return MessageType.DOCUMENT;
    }

    /**
     * Gets the MIME type for a file.
     *
     * @param file The file
     * @return The MIME type
     */
    public String getMimeType(File file) throws IOException {
        return Files.probeContentType(file.toPath());
    }

    /**
     * Gets the file extension from a filename.
     *
     * @param filename The filename
     * @return The file extension (including the dot)
     */
    private String getFileExtension(String filename) {
        int lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex >= 0) {
            return filename.substring(lastDotIndex);
        }
        return "";
    }

    /**
     * Deletes a file if it exists.
     *
     * @param relativePath The relative path to the file
     * @return true if the file was deleted, false otherwise
     */
    public boolean deleteFile(String relativePath) {
        File file = getFile(relativePath);
        if (file.exists()) {
            return file.delete();
        }
        return false;
    }
}


// File: src/main/java/org/example/client/gui/service/GroupService.java
package org.example.client.gui.service;

import java.io.IOException;
import java.util.List;

import org.example.shared.dao.GroupDAO;
import org.example.shared.dao.GroupMembershipDAO;
import org.example.shared.model.Group;
import org.example.shared.model.GroupMembership;

public class GroupService {

    private final GroupDAO groupDAO;
    private final GroupMembershipDAO groupMembershipDAO;

    public GroupService() {
        this.groupDAO = new GroupDAO();
        this.groupMembershipDAO = new GroupMembershipDAO();
    }

    public Group createGroup(final String groupName, final long ownerUserId) {
        final Group group = new Group(groupName, ownerUserId); // constructeur qui initialise aussi createdAt
        groupDAO.createGroup(group);
        if (group.getId() > 0) {
            final GroupMembership membership = new GroupMembership(ownerUserId, group.getId());
            groupMembershipDAO.createGroupMembership(membership);
        }
        return group;
    }

    public boolean addMemberToGroup(final long groupId, final long userId) {
        if (groupMembershipDAO.findGroupMembership(userId, groupId) == null) {
            final GroupMembership membership = new GroupMembership(userId, groupId);
            groupMembershipDAO.createGroupMembership(membership);
            return true;
        }
        return false;
    }
    
    public List<Group> getGroupsForUser(final long userId) throws IOException {
        return groupDAO.getGroupsForUser(userId);
    }

    /**
     * R√©cup√®re les identifiants des membres d'un groupe
     */
    public List<Long> getMembersForGroup(final long groupId) {
        return groupDAO.getMembersForGroup(groupId);
    }

    /**
     * Supprime un membre d'un groupe
     */
    public boolean removeMemberFromGroup(final long groupId, final long userId) {
        return groupMembershipDAO.removeGroupMembership(userId, groupId);
    }
}



// File: src/main/java/org/example/client/gui/service/UserService.java
package org.example.client.gui.service;

import java.io.IOException;

import org.example.shared.dao.UserDAO;
import org.example.shared.model.User;

/**
 * Service pour g√©rer les utilisateurs avec cache
 */
public class UserService {
    private final UserDAO userDAO;

    public UserService() {
        this.userDAO = new UserDAO();
    }
    
    /**
     * R√©cup√®re un utilisateur par email 
     */
    public User getUserByEmail(final String email) throws IOException {
        if (email == null || email.trim().isEmpty()) {
            throw new IllegalArgumentException("L'email ne peut pas √™tre vide");
        }
        
        // Sinon, interroger la base de donn√©es
        final User user = userDAO.findUserByEmail(email);
        if (user == null) {
            throw new IOException("Utilisateur non trouv√©: " + email);
        }
        
        return user;
    }
    
    /**
     * R√©cup√®re un utilisateur par ID
     */
    public User getUserById(final long userId) throws IOException {
        if (userId <= 0) {
            throw new IllegalArgumentException("L'ID utilisateur doit √™tre positif");
        }
        
        // Sinon, interroger la base de donn√©es
        final User user = userDAO.findUserById(userId);
        if (user == null) {
            throw new IOException("Utilisateur non trouv√© avec l'ID: " + userId);
        }
        
        return user;
    }
    
    /**
     * Met √† jour un utilisateur dans la base de donn√©es et le cache
     */
    public void updateUser(final User user) throws IOException {
        if (user == null) {
            throw new IllegalArgumentException("L'utilisateur ne peut pas √™tre null");
        }
        
        userDAO.updateUser(user);
    }
}



// File: src/main/java/org/example/server/broker/MessageBroker.java
package org.example.server.broker;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;

import org.example.server.ClientHandler;
import org.example.server.UdpCallServer;
import org.example.shared.dao.GroupDAO;
import org.example.shared.dao.MessageDAO;
import org.example.shared.model.CallSignal;
import org.example.shared.model.Message;
import org.example.shared.model.enums.MessageStatus;

public class MessageBroker {
    private static MessageBroker instance;
    private final Map<Long, MessageQueue> userQueues;
    private final MessageDAO messageDAO;
    final GroupDAO groupDAO;

    public static synchronized MessageBroker getInstance() {
        if (instance == null) {
            instance = new MessageBroker();
        }
        return instance;
    }

    private MessageBroker() {
        this.userQueues = new ConcurrentHashMap<>();
        this.messageDAO = new MessageDAO();
        this.groupDAO = new GroupDAO();
    }

    public void registerListener(final long userId, final ClientHandler listener) {
        final MessageQueue queue = getOrCreateQueue(userId);
        queue.setListener(listener);
        queue.loadPersistedMessages();
        queue.deliverPendingMessages();
    }

    public void unregisterListener(final long userId) {
        final MessageQueue queue = userQueues.remove(userId);
        if (queue != null) {
            queue.setListener(null);
            queue.clearQueue();
        }
    }

    public void sendMessage(final Message message) {
        if (message.isGroupMessage()) {
            final List<Long> groupMemberIds = groupDAO.getMembersForGroup(message.getGroupId());
            for (final Long memberId : groupMemberIds) {
                // Ignorer l'exp√©diteur
                if (!memberId.equals(message.getSenderUserId())) {
                    final MessageQueue queue = getOrCreateQueue(memberId);
                    // Cr√©er une copie du message pour ce destinataire
                    Message messageForRecipient = Message.copyForReceiver(message, memberId);
                    // Essayer de d√©livrer et, si √ßa √©choue, persister le message
                    if (!queue.tryDeliver(messageForRecipient)) {
                        persistMessage(messageForRecipient);
                    } else {
                        messageForRecipient.setStatus(MessageStatus.DELIVERED);
                    }
                }
            }
        } else {
            final MessageQueue queue = userQueues.get(message.getReceiverUserId());
            if (queue != null && queue.tryDeliver(message)) {
                message.setStatus(MessageStatus.DELIVERED);
            } else {
                persistMessage(message);
            }
        }
    }

    /**
     * Achemine un signal d'appel vers le destinataire appropri√©.
     * 
     * @param signal Le signal d'appel √† acheminer
     */
    public void routeCallSignal(final CallSignal signal) {
        try {
            // Traiter les signaux selon leur type
            switch (signal.getType()) {
                case CALL_REQUEST:
                    // Enregistrer la session d'appel dans le serveur UDP pour un √©ventuel relais
                    UdpCallServer.getInstance().registerSession(signal.getSessionId());
                    // Transmettre la demande d'appel au destinataire
                    deliverCallSignal(signal.getReceiverUserId(), signal);
                    break;

                case CALL_ACCEPT:
                    // Enregistrer le point de terminaison du destinataire dans le serveur UDP
                    UdpCallServer.getInstance().registerEndpoint(
                            signal.getSessionId(),
                            false,
                            java.net.InetAddress.getByName(signal.getIpAddress()),
                            signal.getPort());
                    // Transmettre l'acceptation √† l'appelant
                    deliverCallSignal(signal.getReceiverUserId(), signal);
                    break;

                case CALL_REJECT:
                case CALL_BUSY:
                    // Supprimer la session d'appel du serveur UDP
                    UdpCallServer.getInstance().removeSession(signal.getSessionId());
                    // Transmettre le rejet √† l'appelant
                    deliverCallSignal(signal.getReceiverUserId(), signal);
                    break;

                case CALL_END:
                    // Supprimer la session d'appel du serveur UDP
                    UdpCallServer.getInstance().removeSession(signal.getSessionId());
                    // Transmettre la fin d'appel √† l'autre partie
                    deliverCallSignal(signal.getReceiverUserId(), signal);
                    break;
            }
        } catch (final Exception e) {
            System.err.println("Erreur lors du routage du signal d'appel: " + e.getMessage());
        }
    }

    /**
     * D√©livre un signal d'appel √† un utilisateur sp√©cifique.
     * 
     * @param userId L'ID de l'utilisateur destinataire
     * @param signal Le signal d'appel √† d√©livrer
     */
    private void deliverCallSignal(final long userId, final CallSignal signal) {
        final MessageQueue queue = userQueues.get(userId);
        if (queue != null) {
            queue.tryDeliverCallSignal(signal);
        }
    }

    private void persistMessage(final Message message) {
        message.setStatus(MessageStatus.QUEUED);
        try {
            messageDAO.createMessage(message);
        } catch (final Exception e) {
            System.err.println("Failed to queue message: " + e.getMessage());
        }
    }

    private MessageQueue getOrCreateQueue(final long userId) {
        return userQueues.computeIfAbsent(userId, MessageQueue::new);
    }

    private class MessageQueue {
        private final long userId;
        private final BlockingQueue<Message> messages;
        private ClientHandler listener;

        MessageQueue(final long userId) {
            this.userId = userId;
            this.messages = new LinkedBlockingQueue<>();
        }

        synchronized void setListener(final ClientHandler listener) {
            this.listener = listener;
        }

        void addMessageToQueue(final Message message) {
            messages.offer(message);
        }

        synchronized void clearQueue() {
            messages.clear();
        }

        synchronized void loadPersistedMessages() {
            try {
                final List<Message> pendingMessages = messageDAO.getPendingMessagesForUser(userId);
                pendingMessages.forEach(this::addMessageToQueue);
            } catch (final Exception e) {
                System.err.println("Error reloading persisted messages for user " + userId + ": " + e.getMessage());
            }
        }

        boolean tryDeliver(final Message message) {
            if (listener != null) {
                try {
                    listener.onMessageReceived(message);
                    return true;
                } catch (final IOException e) {
                    System.err.println("Delivery failed for message " + message.getId());
                }
            }
            return false;
        }

        /**
         * Tente de d√©livrer un signal d'appel au client.
         * 
         * @param signal Le signal d'appel √† d√©livrer
         * @return true si la livraison a r√©ussi
         */
        boolean tryDeliverCallSignal(final CallSignal signal) {
            if (listener != null) {
                try {
                    listener.onCallSignalReceived(signal);
                    return true;
                } catch (final IOException e) {
                    System.err.println("Delivery failed for call signal to user " + userId);
                }
            }
            return false;
        }

        void deliverPendingMessages() {
            int initialSize = messages.size();
            for (int i = 0; i < initialSize; i++) {
                Message message = messages.poll();
                if (message == null) {
                    break;
                }
                if (tryDeliver(message)) {
                    try {
                        messageDAO.deleteMessage(message.getId());
                    } catch (Exception e) {
                        System.err.println("Failed to delete message " + message.getId() + ", re-adding to queue");
                        messages.offer(message);
                    }
                } else {
                    messages.offer(message);
                }
            }
        }
    }
}


// File: src/main/java/org/example/server/ChatServer.java
package org.example.server;

import java.net.ServerSocket;
import java.net.Socket;

public class ChatServer {
    private static final int PORT = 5000;
    public static void main(final String[] args) throws Exception {
        // D√©marrer le serveur UDP pour les appels audio
        UdpCallServer.getInstance().start();
        
        final ServerSocket server = new ServerSocket(PORT);
        System.out.println("Server TCP started on port " + PORT);
        System.out.println("Waiting for clients...");

        while (true) {
            final Socket client = server.accept();
            final ClientHandler clientHandler = new ClientHandler(client);
            new Thread(clientHandler).start();
        }
    }
}


// File: src/main/java/org/example/server/ClientHandler.java
package org.example.server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.Optional;

import org.example.server.broker.MessageBroker;
import org.example.shared.dao.UserDAO;
import org.example.shared.dto.Credentials;
import org.example.shared.dto.RegistrationDTO;
import org.example.shared.model.CallSignal;
import org.example.shared.model.Message;
import org.example.shared.model.User;
import org.example.shared.model.enums.MessageType;
import org.example.shared.util.PasswordUtils;
import org.example.shared.util.ValidationUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final MessageBroker broker;
    private final UserDAO userDAO;
    private final ObjectMapper mapper;
    private final ServerFileService fileService;

    private String clientEmail;
    private long clientId;
    private PrintWriter output;
    private BufferedReader input;
    private volatile boolean isConnected;

    public ClientHandler(final Socket socket) {
        this.clientSocket = socket;
        this.broker = MessageBroker.getInstance();
        this.userDAO = new UserDAO();
        this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
        this.fileService = new ServerFileService();
    }

    @Override
    public void run() {
        try (
                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream(), StandardCharsets.UTF_8));
                PrintWriter out = new PrintWriter(new OutputStreamWriter(clientSocket.getOutputStream(), StandardCharsets.UTF_8), true)) {
            this.input = in;
            this.output = out;

            final String requestType = input.readLine();
            if (requestType == null) return;

            if ("REGISTER".equals(requestType)) {
                handleRegistration();
                return;
            } else if ("LOGIN".equals(requestType)) {
                if (!authenticateUser()) {
                    sendResponse("AUTH_FAILED");
                    return;
                }
                sendResponse("AUTH_SUCCESS");

                handleUserLogin(clientEmail);
                initializeSubscription();
                processMessages();
            } else {
                System.out.println("Unknown request type: " + requestType);
                sendResponse("UNKNOWN_REQUEST_TYPE");
                return;
            }
        } catch (final IOException e) {
            System.out.println("Client connection error for " + (clientEmail != null ? clientEmail : clientSocket.getInetAddress()) + ": " + e.getMessage());
        } finally {
            cleanup();
        }
    }

    private void handleRegistration() throws IOException {
        try {
            final RegistrationDTO registrationDTO = mapper.readValue(input.readLine(), RegistrationDTO.class);

            if (!ValidationUtils.isValidEmail(registrationDTO.getEmail())) {
                sendResponse("Invalid email format");
                return;
            }

            if (!ValidationUtils.isStrongPassword(registrationDTO.getPassword())) {
                sendResponse("Password does not meet security criteria");
                return;
            }

            if (!ValidationUtils.doPasswordsMatch(registrationDTO.getPassword(), registrationDTO.getPasswordConfirmation())) {
                sendResponse("Passwords do not match");
                return;
            }

            final User existingUser = userDAO.findUserByEmail(registrationDTO.getEmail());
            if (existingUser != null) {
                sendResponse("REGISTER_FAILURE_EMAIL_EXISTS");
                return;
            }

            final User newUser = new User();
            newUser.setEmail(registrationDTO.getEmail());
            newUser.setDisplayName(registrationDTO.getEmail().split("@")[0]);
            newUser.setPasswordHash(PasswordUtils.hashPassword(registrationDTO.getPassword()));
            newUser.setCreatedAt(LocalDateTime.now());
            newUser.setOnline(false);

            userDAO.createUser(newUser);

            sendResponse("REGISTER_SUCCESS");
        } catch (final Exception e) {
            System.out.println("Registration error: " + e.getMessage());
            e.printStackTrace();
            sendResponse("Registration error: " + e.getMessage());
        }
    }

    private boolean authenticateUser() throws IOException {
        final String jsonCredentials = input.readLine();
        if (jsonCredentials == null) return false;

        try {
            final Credentials credentials = mapper.readValue(jsonCredentials, Credentials.class);
            final User user = userDAO.findUserByEmail(credentials.getEmail());
            if (user != null && PasswordUtils.verifyPassword(credentials.getPassword(), user.getPasswordHash())) {
                this.clientEmail = user.getEmail();
                this.clientId = user.getId();
                System.out.println("Authentication successful for " + clientEmail + " (ID: " + clientId + ")");
                return true;
            } else {
                System.out.println("Authentication failed for " + credentials.getEmail());
                return false;
            }
        } catch (final JsonProcessingException e) {
            System.err.println("Error parsing JSON credentials: " + e.getMessage());
            sendResponse("AUTH_ERROR_FORMAT");
            return false;
        } catch (final Exception e) {
            System.err.println("Error during authentication: " + e.getMessage());
            sendResponse("AUTH_ERROR_SERVER");
            e.printStackTrace();
            return false;
        }
    }

    private void initializeSubscription() throws IOException {
        broker.registerListener(clientId, this);
        isConnected = true;
    }

    private void processMessages() throws IOException {
        String jsonData;
        while (isConnected && (jsonData = input.readLine()) != null) {
            try {
                // V√©rifier d'abord si c'est un signal d'appel bas√© sur le JSON brut
                if (jsonData.contains("\"type\":\"CALL_")) {
                    final CallSignal signal = mapper.readValue(jsonData, CallSignal.class);
                    broker.routeCallSignal(signal);
                    continue; // Passer au prochain message apr√®s avoir trait√© le signal d'appel
                }

                // Si ce n'est pas un signal d'appel, traiter comme un Message normal
                final Message message = mapper.readValue(jsonData, Message.class);
                message.setSenderUserId(this.clientId);

                // V√©rifier si c'est un message de d√©connexion par son contenu
                if ("LOGOUT".equalsIgnoreCase(message.getContent()) && message.getType() == MessageType.SYSTEM) {
                    handleUserLogout(clientEmail);
                    terminateSession();
                    sendResponse("LOGOUT_SUCCESS");
                    return;
                }

                // G√©rer les autres types de messages via le switch
                switch (message.getType()) {
                    case PUBLIC_KEY_REQUEST:
                        handlePublicKeyRequest(message);
                        break;
                    case PUBLIC_KEY_RESPONSE:
                        handleClientPublicKeyUpdate(message);
                        break;
                    case E2E_SESSION_INIT:
                    case TEXT:
                    case IMAGE:
                    case VIDEO:
                    case AUDIO:
                    case DOCUMENT:
                        if (message.isMediaMessage()) {
                            processMediaMessage(message);
                        }
                        broker.sendMessage(message);
                        break;
                    case SYSTEM:
                        System.out.println("SYSTEM message received from client ID " + message.getSenderUserId() + " (content: " + message.getContent() + ") - Ignored unless LOGOUT.");
                        break;
                    default:
                        System.out.println("Unknown or unhandled message type received: " + message.getType());
                }
            } catch (final JsonProcessingException e) {
                System.err.println("Error parsing JSON from " + clientEmail + ": " + e.getMessage() + " | JSON: " + jsonData);
            } catch (final IOException e) {
                System.err.println("IO error processing message from " + clientEmail + ": " + e.getMessage());
                throw e;
            } catch (final Exception e) {
                System.err.println("Unexpected error processing message from " + clientEmail + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    private void processMediaMessage(final Message message) {
        try {
            fileService.ensureMediaDirectoriesExist();
            System.out.println("Processing media message: " + message.getType() +
                    ", File: " + (message.getFileName() != null ? message.getFileName() : "Unknown"));
        } catch (final Exception e) {
            System.err.println("Error processing media message: " + e.getMessage());
        }
    }

    private void handlePublicKeyRequest(final Message requestMessage) {
        try {
            final long targetUserId = Long.parseLong(requestMessage.getContent());
            final long requesterUserId = requestMessage.getSenderUserId();

            System.out.println("Public key request for ID " + targetUserId + " by ID " + requesterUserId);

            final Optional<String> publicKeyOpt = userDAO.getPublicKey(targetUserId);

            if (publicKeyOpt.isPresent() && publicKeyOpt.get() != null && !publicKeyOpt.get().isEmpty()) {
                final Message response = new Message();
                response.setType(MessageType.PUBLIC_KEY_RESPONSE);
                response.setSenderUserId(targetUserId);
                response.setReceiverUserId(requesterUserId);
                response.setContent(publicKeyOpt.get());
                response.setTimestamp(LocalDateTime.now());

                sendMessageToClient(response);
                System.out.println("Public key for ID " + targetUserId + " sent to ID " + requesterUserId);
            } else {
                System.out.println("Public key not found or empty for ID " + targetUserId);
            }
        } catch (final NumberFormatException e) {
            System.err.println("Invalid target ID in PUBLIC_KEY_REQUEST from ID " + requestMessage.getSenderUserId() + ": " + requestMessage.getContent());
        } catch (final Exception e) {
            System.err.println("Error processing PUBLIC_KEY_REQUEST from ID " + requestMessage.getSenderUserId() + ": " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleClientPublicKeyUpdate(final Message message) {
        final String publicKeyString = message.getContent();
        final long senderId = message.getSenderUserId();

        if (senderId != this.clientId) {
            System.err.println("Attempt to update public key by ID " + senderId + " for connected client ID " + this.clientId + ". Ignored.");
            return;
        }

        if (publicKeyString != null && !publicKeyString.isEmpty()) {
            final boolean success = userDAO.updatePublicKey(this.clientId, publicKeyString);
            if (success) {
                System.out.println("Public key stored/updated for ID " + this.clientId);
            } else {
                System.err.println("Failed to store public key for ID " + this.clientId);
            }
        } else {
            System.err.println("Empty public key received from ID " + this.clientId);
        }
    }

    public void sendMessageToClient(final Message message) {
        if (output != null && !clientSocket.isClosed() && isConnected) {
            try {
                final String jsonMessage = mapper.writeValueAsString(message);
                output.println(jsonMessage);
            } catch (final JsonProcessingException e) {
                System.err.println("Error serializing JSON for direct send to ID " + clientId + ": " + e.getMessage());
            } catch (final Exception e) {
                System.err.println("Unknown error during direct send to ID " + clientId + ": " + e.getMessage());
            }
        } else {
            System.err.println("Attempt to send direct message to disconnected or uninitialized client (ID: " + clientId + ")");
        }
    }

    public void onMessageReceived(final Message message) throws IOException {
        sendMessageToClient(message);
    }

    public void onCallSignalReceived(final CallSignal signal) throws IOException {
        if (output != null && !clientSocket.isClosed() && isConnected) {
            try {
                final String jsonSignal = mapper.writeValueAsString(signal);
                output.println(jsonSignal);
            } catch (final JsonProcessingException e) {
                System.err.println("Error serializing JSON for call signal to ID " + clientId + ": " + e.getMessage());
            } catch (final Exception e) {
                System.err.println("Unknown error during call signal send to ID " + clientId + ": " + e.getMessage());
            }
        } else {
            System.err.println("Attempt to send call signal to disconnected or uninitialized client (ID: " + clientId + ")");
        }
    }

    private void sendResponse(final String response) {
        if (output != null) {
            output.println(response);
        }
    }

    private void terminateSession() {
        isConnected = false;
    }

    private void cleanup() {
        if (!isConnected) {
            return;
        }
        isConnected = false;
        System.out.println("Cleanup for " + (clientEmail != null ? clientEmail : clientSocket.getInetAddress()));

        if (clientId > 0) {
            broker.unregisterListener(clientId);
            handleUserLogout(clientEmail);
        }

        try {
            if (input != null) input.close();
        } catch (final IOException e) { }
        if (output != null) output.close();
        try {
            if (clientSocket != null && !clientSocket.isClosed()) clientSocket.close();
        } catch (final IOException e) { }
        System.out.println("Resources closed for " + (clientEmail != null ? clientEmail : "unauthenticated client"));
    }

    public void handleUserLogin(final String email) {
        try {
            final User user = userDAO.findUserByEmail(email);
            if (user != null) {
                user.setOnline(true);
                final boolean success = userDAO.updateUser(user);
                if (!success) {
                    System.err.println("Failed to update online status for: " + email);
                }
            }
        } catch (final Exception e) {
            System.err.println("Error updating online status: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void handleUserLogout(final String email) {
        try {
            final User user = userDAO.findUserByEmail(email);
            if (user != null) {
                user.setOnline(false);
                final boolean success = userDAO.updateUser(user);
                if (!success) {
                    System.err.println("Failed to update offline status for: " + email);
                }
            }
        } catch (final Exception e) {
            System.err.println("Error updating offline status: " + e.getMessage());
            e.printStackTrace();
        }
    }
}


// File: src/main/java/org/example/server/ServerFileService.java
package org.example.server;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

import org.example.shared.model.enums.MessageType;

/**
 * Service for handling file operations on the server side.
 */
public class ServerFileService {

    // Base directory for storing media files
    private static final String MEDIA_DIR = System.getProperty("user.dir") + File.separator +
            "media_files";

    // Subdirectories for different media types
    private static final String IMAGES_DIR = MEDIA_DIR + File.separator + "images";
    private static final String VIDEOS_DIR = MEDIA_DIR + File.separator + "videos";
    private static final String DOCUMENTS_DIR = MEDIA_DIR + File.separator + "documents";
    private static final String AUDIO_DIR = MEDIA_DIR + File.separator + "audio";

    /**
     * Creates all necessary directories for storing media files.
     */
    public void ensureMediaDirectoriesExist() throws IOException {
        Files.createDirectories(Paths.get(IMAGES_DIR));
        Files.createDirectories(Paths.get(VIDEOS_DIR));
        Files.createDirectories(Paths.get(DOCUMENTS_DIR));
        Files.createDirectories(Paths.get(AUDIO_DIR));
    }

    /**
     * Gets the full path to a media file from its relative path.
     *
     * @param relativePath The relative path stored in the message
     * @return The full path to the file
     */
    public File getFile(String relativePath) {
        return new File(MEDIA_DIR + File.separator + relativePath);
    }

    /**
     * Saves a file to the appropriate directory and returns the path where it was saved.
     *
     * @param inputStream The input stream of the file
     * @param type The type of media
     * @param originalFilename The original filename
     * @return The path where the file was saved (relative to the media directory)
     * @throws IOException If an I/O error occurs
     */
    public String saveFile(InputStream inputStream, MessageType type, String originalFilename) throws IOException {
        // Get the appropriate directory
        String directory;
        switch (type) {
            case IMAGE:
                directory = IMAGES_DIR;
                break;
            case VIDEO:
                directory = VIDEOS_DIR;
                break;
            case DOCUMENT:
                directory = DOCUMENTS_DIR;
                break;
            case AUDIO:
                directory = AUDIO_DIR;
                break;
            default:
                throw new IllegalArgumentException("Invalid file type: " + type);
        }

        // Generate a unique filename to avoid collisions
        String fileExtension = getFileExtension(originalFilename);
        String uniqueFilename = UUID.randomUUID().toString() + fileExtension;
        String fullPath = directory + File.separator + uniqueFilename;

        // Save the file
        try (FileOutputStream fos = new FileOutputStream(fullPath)) {
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                fos.write(buffer, 0, bytesRead);
            }
        }

        // Return the relative path to be stored in the message
        return type.name().toLowerCase() + "/" + uniqueFilename;
    }

    /**
     * Gets the file extension from a filename.
     *
     * @param filename The filename
     * @return The file extension (including the dot)
     */
    private String getFileExtension(String filename) {
        int lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex >= 0) {
            return filename.substring(lastDotIndex);
        }
        return "";
    }

    /**
     * Deletes a file if it exists.
     *
     * @param relativePath The relative path to the file
     * @return true if the file was deleted, false otherwise
     */
    public boolean deleteFile(String relativePath) {
        File file = getFile(relativePath);
        if (file.exists()) {
            return file.delete();
        }
        return false;
    }
}


// File: src/main/java/org/example/server/UdpCallServer.java
package org.example.server;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Serveur UDP pour relayer les paquets audio entre clients.
 * Utilis√© comme solution de secours quand la connexion directe entre clients √©choue.
 */
public class UdpCallServer {
    private static final int UDP_PORT = 5001;
    private static final int BUFFER_SIZE = 4096;
    
    private DatagramSocket socket;
    private final ExecutorService threadPool;
    private final Map<String, CallSession> activeSessions;
    private volatile boolean running;
    
    // Singleton
    private static UdpCallServer instance;
    
    /**
     * Repr√©sente une session d'appel active avec les informations des deux clients.
     */
    private static class CallSession {
        private final String sessionId;
        private InetAddress caller;
        private int callerPort;
        private InetAddress receiver;
        private int receiverPort;
        
        public CallSession(String sessionId) {
            this.sessionId = sessionId;
        }
        
        public void setCallerEndpoint(InetAddress address, int port) {
            this.caller = address;
            this.callerPort = port;
        }
        
        public void setReceiverEndpoint(InetAddress address, int port) {
            this.receiver = address;
            this.receiverPort = port;
        }
        
        public boolean isComplete() {
            return caller != null && receiver != null;
        }
        
        public boolean isFromCaller(InetAddress address, int port) {
            return address.equals(caller) && port == callerPort;
        }
        
        public boolean isFromReceiver(InetAddress address, int port) {
            return address.equals(receiver) && port == receiverPort;
        }
        
        public String getSessionId() {
            return sessionId;
        }
    }
    
    private UdpCallServer() {
        this.threadPool = Executors.newCachedThreadPool();
        this.activeSessions = new ConcurrentHashMap<>();
    }
    
    public static synchronized UdpCallServer getInstance() {
        if (instance == null) {
            instance = new UdpCallServer();
        }
        return instance;
    }
    
    /**
     * D√©marre le serveur UDP.
     */
    public void start() {
        if (running) {
            return;
        }
        
        try {
            socket = new DatagramSocket(UDP_PORT);
            running = true;
            
            System.out.println("Serveur UDP d√©marr√© sur le port " + UDP_PORT);
            
            // D√©marrer le thread principal pour recevoir les paquets
            threadPool.execute(this::receivePackets);
        } catch (SocketException e) {
            System.err.println("Erreur lors du d√©marrage du serveur UDP: " + e.getMessage());
        }
    }
    
    /**
     * Arr√™te le serveur UDP.
     */
    public void stop() {
        running = false;
        if (socket != null && !socket.isClosed()) {
            socket.close();
        }
        threadPool.shutdown();
        activeSessions.clear();
    }
    
    /**
     * Enregistre une nouvelle session d'appel.
     * 
     * @param sessionId ID unique de la session
     * @return true si la session a √©t√© cr√©√©e avec succ√®s
     */
    public boolean registerSession(String sessionId) {
        if (activeSessions.containsKey(sessionId)) {
            return false;
        }
        activeSessions.put(sessionId, new CallSession(sessionId));
        return true;
    }
    
    /**
     * Enregistre un point de terminaison pour une session d'appel.
     * 
     * @param sessionId ID de la session
     * @param isCaller true si c'est l'appelant, false si c'est le destinataire
     * @param address adresse IP du client
     * @param port port UDP du client
     * @return true si l'enregistrement a r√©ussi
     */
    public boolean registerEndpoint(String sessionId, boolean isCaller, InetAddress address, int port) {
        CallSession session = activeSessions.get(sessionId);
        if (session == null) {
            return false;
        }
        
        if (isCaller) {
            session.setCallerEndpoint(address, port);
        } else {
            session.setReceiverEndpoint(address, port);
        }
        
        return true;
    }
    
    /**
     * Supprime une session d'appel.
     * 
     * @param sessionId ID de la session √† supprimer
     */
    public void removeSession(String sessionId) {
        activeSessions.remove(sessionId);
    }
    
    /**
     * Boucle principale pour recevoir et relayer les paquets.
     */
    private void receivePackets() {
        byte[] buffer = new byte[BUFFER_SIZE];
        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
        
        while (running) {
            try {
                // R√©initialiser le paquet pour la prochaine r√©ception
                packet.setLength(buffer.length);
                
                // Recevoir un paquet
                socket.receive(packet);
                
                // Traiter le paquet dans un thread s√©par√©
                final DatagramPacket receivedPacket = new DatagramPacket(
                        packet.getData().clone(),
                        packet.getLength(),
                        packet.getAddress(),
                        packet.getPort());
                
                threadPool.execute(() -> processPacket(receivedPacket));
                
            } catch (IOException e) {
                if (running) {
                    System.err.println("Erreur lors de la r√©ception d'un paquet UDP: " + e.getMessage());
                }
            }
        }
    }
    
    /**
     * Traite un paquet re√ßu et le relaie au destinataire appropri√©.
     * 
     * @param packet Le paquet re√ßu
     */
    private void processPacket(DatagramPacket packet) {
        // Extraire les informations du paquet
        InetAddress sourceAddress = packet.getAddress();
        int sourcePort = packet.getPort();
        
        // Trouver la session correspondante
        for (CallSession session : activeSessions.values()) {
            if (!session.isComplete()) {
                continue;
            }
            
            try {
                // D√©terminer la destination en fonction de la source
                if (session.isFromCaller(sourceAddress, sourcePort)) {
                    // Relayer du caller vers le receiver
                    DatagramPacket forwardPacket = new DatagramPacket(
                            packet.getData(),
                            packet.getLength(),
                            session.receiver,
                            session.receiverPort);
                    socket.send(forwardPacket);
                    return;
                } else if (session.isFromReceiver(sourceAddress, sourcePort)) {
                    // Relayer du receiver vers le caller
                    DatagramPacket forwardPacket = new DatagramPacket(
                            packet.getData(),
                            packet.getLength(),
                            session.caller,
                            session.callerPort);
                    socket.send(forwardPacket);
                    return;
                }
            } catch (IOException e) {
                System.err.println("Erreur lors du relais d'un paquet UDP: " + e.getMessage());
            }
        }
    }
}



// File: src/main/java/org/example/shared/dao/ContactDAO.java
package org.example.shared.dao;

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLIntegrityConstraintViolationException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.model.Contact;

public class ContactDAO {

    public void createContact(final Contact contact) {
        final String sql = "INSERT INTO contacts (user_id, contact_user_id, added_at) VALUES (?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, contact.getUserId());
            stmt.setLong(2, contact.getContactUserId());
            stmt.setTimestamp(3, Timestamp.valueOf(contact.getAddedAt()));
            stmt.executeUpdate();
        } catch (final SQLIntegrityConstraintViolationException ex) {
            System.err.println("Contact d√©j√† existant: " + ex.getMessage());
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public Contact findContactById(final long id) {
        final String sql = "SELECT * FROM contacts WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    final Contact contact = new Contact();
                    // Remplacer par l'attribution des champs si un id existe dans Contact
                    contact.setUserId(rs.getLong("user_id"));
                    contact.setContactUserId(rs.getLong("contact_user_id"));
                    contact.setAddedAt(rs.getTimestamp("added_at").toLocalDateTime());
                    return contact;
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public boolean deleteContact(final long userId, final long contactId) {
        final String sql = "DELETE FROM contacts WHERE user_id = ? AND contact_user_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            stmt.setLong(2, contactId);
            final int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    public List<String> getContactsByUserId(final long userId) throws IOException {
        final List<String> contactEmails = new ArrayList<>();
        final String sql = "SELECT u.email FROM contacts c JOIN users u ON c.contact_user_id = u.id WHERE c.user_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    contactEmails.add(rs.getString("email"));
                }
            }
        } catch (final SQLException e) {
            throw new IOException("Erreur lors de la r√©cup√©ration des contacts", e);
        }
        return contactEmails;
    }
}



// File: src/main/java/org/example/shared/dao/GroupDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.model.Group;

public class GroupDAO {

    public void createGroup(final Group group) {
        // Mise √† jour de la requ√™te pour inclure profile_picture_url
        final String sql = "INSERT INTO `groups` (name, owner_user_id, created_at, profile_picture_url) VALUES (?,?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setString(1, group.getName());
            stmt.setLong(2, group.getOwnerUserId());
            stmt.setTimestamp(3, Timestamp.valueOf(group.getCreatedAt()));
            stmt.setString(4, group.getProfilePictureUrl());
            stmt.executeUpdate();
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    group.setId(generatedKeys.getLong(1));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public Group findGroupById(final long id) {
        final String sql = "SELECT * FROM `groups` WHERE id = ?";
        Group group = null;
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    group = new Group();
                    group.setId(rs.getLong("id"));
                    group.setName(rs.getString("name"));
                    group.setOwnerUserId(rs.getLong("owner_user_id"));
                    group.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
                    group.setProfilePictureUrl(rs.getString("profile_picture_url"));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return group;
    }

    /**
     * R√©cup√®re les identifiants des utilisateurs membres du groupe.
     */
    public List<Long> getMembersForGroup(final long groupId) {
        final List<Long> memberIds = new ArrayList<>();
        final String sql = "SELECT user_id FROM group_memberships WHERE group_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, groupId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    memberIds.add(rs.getLong("user_id"));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return memberIds;
    }

    /**
     * R√©cup√®re les groupes auxquels un utilisateur appartient.
     */
    public List<Group> getGroupsForUser(final long userId) {
        final List<Group> groups = new ArrayList<>();
        final String sql = "SELECT g.id, g.name, g.owner_user_id, g.created_at " +
                     "FROM `groups` g " +
                     "JOIN group_memberships gm ON g.id = gm.group_id " +
                     "WHERE gm.user_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    final Group group = new Group();
                    group.setId(rs.getLong("id"));
                    group.setName(rs.getString("name"));
                    group.setOwnerUserId(rs.getLong("owner_user_id"));
                    group.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
                    groups.add(group);
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return groups;
    }
}


// File: src/main/java/org/example/shared/dao/GroupMembershipDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;

import org.example.shared.model.GroupMembership;

public class GroupMembershipDAO {

    public void createGroupMembership(final GroupMembership membership) {
        final String sql = "INSERT INTO group_memberships (user_id, group_id, joined_at) VALUES (?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, membership.getUserId());
            stmt.setLong(2, membership.getGroupId());
            stmt.setTimestamp(3, Timestamp.valueOf(membership.getJoinedAt()));
            stmt.executeUpdate();
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public GroupMembership findGroupMembership(final long userId, final long groupId) {
        final String sql = "SELECT * FROM group_memberships WHERE user_id = ? AND group_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            stmt.setLong(2, groupId);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    final GroupMembership membership = new GroupMembership();
                    membership.setUserId(rs.getLong("user_id"));
                    membership.setGroupId(rs.getLong("group_id"));
                    membership.setJoinedAt(rs.getTimestamp("joined_at").toLocalDateTime());
                    return membership;
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public boolean removeGroupMembership(final long userId, final long groupId) {
        final String sql = "DELETE FROM group_memberships WHERE user_id = ? AND group_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            stmt.setLong(2, groupId);
            final int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (final SQLException e) {
            e.printStackTrace();
            return false;
        }
    }
}



// File: src/main/java/org/example/shared/dao/JDBCUtil.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class JDBCUtil {
    private static final String URL = "jdbc:mysql://localhost:3306/chat_db";
    private static final String USER = "root";
    private static final String PASSWORD = "password";

    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(URL, USER, PASSWORD);
    }
}



// File: src/main/java/org/example/shared/dao/MessageDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.model.Message;
import org.example.shared.model.enums.MessageStatus;
import org.example.shared.model.enums.MessageType;

public class MessageDAO {

    public void createMessage(final Message message) {
        final String sql = "INSERT INTO messages (sender_user_id, receiver_user_id, group_id, content, timestamp, status, "
                + "message_type, file_name, file_size, mime_type) VALUES (?,?,?,?,?,?,?,?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setLong(1, message.getSenderUserId());
            if (message.getReceiverUserId() != null) {
                stmt.setLong(2, message.getReceiverUserId());
            } else {
                stmt.setNull(2, Types.BIGINT);
            }
            if (message.getGroupId() != null) {
                stmt.setLong(3, message.getGroupId());
            } else {
                stmt.setNull(3, Types.BIGINT);
            }
            stmt.setString(4, message.getContent());
            stmt.setTimestamp(5, Timestamp.valueOf(message.getTimestamp()));
            stmt.setString(6, message.getStatus().name());
            stmt.setString(7, message.getType().name());
            // Set multimedia fields
            if (message.getFileName() != null) {
                stmt.setString(8, message.getFileName());
            } else {
                stmt.setNull(8, Types.VARCHAR);
            }

            if (message.getFileSize() != null) {
                stmt.setLong(9, message.getFileSize());
            } else {
                stmt.setNull(9, Types.BIGINT);
            }

            if (message.getMimeType() != null) {
                stmt.setString(10, message.getMimeType());
            } else {
                stmt.setNull(10, Types.VARCHAR);
            }
            stmt.executeUpdate();
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    message.setId(generatedKeys.getLong(1));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public Message findMessageById(final long id) {
        final String sql = "SELECT * FROM messages WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return extractMessageFromResultSet(rs);
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<Message> getPendingMessagesForUser(final long receiverUserId) throws SQLException {
        final List<Message> messages = new ArrayList<>();
        // R√©cup√©rer les messages directs et les messages de groupe pour lesquels
        // l'utilisateur est membre
        final String sql = "SELECT * FROM messages " +
                "WHERE ((receiver_user_id = ? AND status = ?) " +
                "OR (group_id IS NOT NULL AND status = ? " +
                "    AND group_id IN (SELECT group_id FROM group_memberships WHERE user_id = ?)))";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, receiverUserId);
            stmt.setString(2, MessageStatus.QUEUED.name());
            stmt.setString(3, MessageStatus.QUEUED.name());
            stmt.setLong(4, receiverUserId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    final Message message = new Message();
                    message.setId(rs.getLong("id"));
                    message.setSenderUserId(rs.getLong("sender_user_id"));
                    final long rec = rs.getLong("receiver_user_id");
                    if (!rs.wasNull()) {
                        message.setReceiverUserId(rec);
                    }
                    final long grp = rs.getLong("group_id");
                    if (!rs.wasNull()) {
                        message.setGroupId(grp);
                    }
                    message.setContent(rs.getString("content"));
                    final Timestamp ts = rs.getTimestamp("timestamp");
                    if (ts != null) {
                        message.setTimestamp(ts.toLocalDateTime());
                    }
                    message.setStatus(MessageStatus.valueOf(rs.getString("status")));
                    messages.add(message);
                }
            }
        }
        return messages;
    }

    public List<Message> getConversation(final long user1Id, final long user2Id) {
        final List<Message> messages = new ArrayList<>();
        final String sql = "SELECT * FROM messages WHERE " +
                " (sender_user_id = ? AND receiver_user_id = ?) OR (sender_user_id = ? AND receiver_user_id = ?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, user1Id);
            stmt.setLong(2, user2Id);
            stmt.setLong(3, user2Id);
            stmt.setLong(4, user1Id);

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    messages.add(extractMessageFromResultSet(rs));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return messages;
    }

    public boolean deleteMessage(final long messageId) throws SQLException {
        final String sql = "DELETE FROM messages WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, messageId);
            final int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        }
    }

    public void updateMessageStatus(final long messageId, final MessageStatus status) throws SQLException {
        final String sql = "UPDATE messages SET status = ? WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, status.name());
            stmt.setLong(2, messageId);
            stmt.executeUpdate();
        }
    }

    // Helper method to extract a Message from a ResultSet
    private Message extractMessageFromResultSet(final ResultSet rs) throws SQLException {
        final Message message = new Message();
        message.setId(rs.getLong("id"));
        message.setSenderUserId(rs.getLong("sender_user_id"));

        final long receiverUserId = rs.getLong("receiver_user_id");
        if (!rs.wasNull()) {
            message.setReceiverUserId(receiverUserId);
        }

        final long groupId = rs.getLong("group_id");
        if (!rs.wasNull()) {
            message.setGroupId(groupId);
        }

        message.setContent(rs.getString("content"));
        final Timestamp ts = rs.getTimestamp("timestamp");
        if (ts != null) {
            message.setTimestamp(ts.toLocalDateTime());
        }

        message.setStatus(MessageStatus.valueOf(rs.getString("status")));

        // Extract multimedia fields
        String messageTypeStr = rs.getString("message_type");
        if (messageTypeStr != null) {
            message.setType(MessageType.valueOf(messageTypeStr));
        } else {
            message.setType(MessageType.TEXT); // Default to TEXT for backward compatibility
        }

        message.setFileName(rs.getString("file_name"));

        final long fileSize = rs.getLong("file_size");
        if (!rs.wasNull()) {
            message.setFileSize(fileSize);
        }

        message.setMimeType(rs.getString("mime_type"));

        return message;
    }
}



// File: src/main/java/org/example/shared/dao/UserDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.Optional;

import org.example.shared.model.User;

public class UserDAO {

    public void createUser(final User user) {
        final String sql = "INSERT INTO users (email, display_name, password_hash, is_online, created_at, last_login_at, profile_picture_url, public_key) VALUES (?,?,?,?,?,?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setString(1, user.getEmail());
            stmt.setString(2, user.getDisplayName());
            stmt.setString(3, user.getPasswordHash());
            stmt.setBoolean(4, user.isOnline());
            stmt.setTimestamp(5, Timestamp.valueOf(user.getCreatedAt()));
            stmt.setTimestamp(6, user.getLastLoginAt() != null ? Timestamp.valueOf(user.getLastLoginAt()) : null);
            stmt.setString(7, user.getProfilePictureUrl());
            stmt.setString(8, user.getPublicKey());

            stmt.executeUpdate();
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    user.setId(generatedKeys.getLong(1));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public User findUserById(final long id) {
        final String sql = "SELECT * FROM users WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return mapRowToUser(rs);
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public User findUserByEmail(final String email) {
        final String sql = "SELECT * FROM users WHERE email = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, email);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return mapRowToUser(rs);
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public boolean updateUser(final User user) {
        final String sql = "UPDATE users SET email=?, display_name=?, password_hash=?, is_online=?, created_at=?, last_login_at=?, profile_picture_url=?, public_key=? WHERE id=?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, user.getEmail());
            stmt.setString(2, user.getDisplayName());
            stmt.setString(3, user.getPasswordHash());
            stmt.setBoolean(4, user.isOnline());
            stmt.setTimestamp(5, Timestamp.valueOf(user.getCreatedAt()));
            stmt.setTimestamp(6, user.getLastLoginAt() != null ? Timestamp.valueOf(user.getLastLoginAt()) : null);
            stmt.setString(7, user.getProfilePictureUrl());
            stmt.setString(8, user.getPublicKey());
            stmt.setLong(9, user.getId());

            final int rowsAffected = stmt.executeUpdate();
            return rowsAffected > 0;
        } catch (final SQLException e) {
            System.err.println("Erreur lors de la mise √† jour de l'utilisateur: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    public void deleteUser(final long id) {
        final String sql = "DELETE FROM users WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);
            stmt.executeUpdate();
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public boolean updatePublicKey(final long userId, final String publicKeyString) {
        final String sql = "UPDATE users SET public_key = ? WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, publicKeyString);
            pstmt.setLong(2, userId);

            final int affectedRows = pstmt.executeUpdate();
            return affectedRows > 0;
        } catch (final SQLException e) {
            System.err.println("Erreur SQL lors de la mise √† jour de la cl√© publique pour l'ID " + userId + ": " + e.getMessage());
            return false;
        }
    }

    public Optional<String> getPublicKey(final long userId) {
        final String sql = "SELECT public_key FROM users WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setLong(1, userId);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    return Optional.ofNullable(rs.getString("public_key"));
                }
            }
        } catch (final SQLException e) {
            System.err.println("Erreur SQL lors de la r√©cup√©ration de la cl√© publique pour l'ID " + userId + ": " + e.getMessage());
        }
        return Optional.empty();
    }

    private User mapRowToUser(final ResultSet rs) throws SQLException {
        final User user = new User();
        user.setId(rs.getLong("id"));
        user.setEmail(rs.getString("email"));
        user.setDisplayName(rs.getString("display_name"));
        user.setPasswordHash(rs.getString("password_hash"));
        user.setOnline(rs.getBoolean("is_online"));
        user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
        final Timestamp ts = rs.getTimestamp("last_login_at");
        if (ts != null) {
            user.setLastLoginAt(ts.toLocalDateTime());
        }
        user.setProfilePictureUrl(rs.getString("profile_picture_url"));
        user.setPublicKey(rs.getString("public_key"));
        return user;
    }
}



// File: src/main/java/org/example/shared/dto/Credentials.java
package org.example.shared.dto;

/**
 * Classe DTO pour les informations d'authentification.
 */
public class Credentials {
    private String email;
    private String password;
    
    // Constructeur par d√©faut requis pour Jackson
    public Credentials() {
    }
    
    public Credentials(final String email, final String password) {
        this.email = email;
        this.password = password;
    }
    
    // Getters et Setters
    public String getEmail() {
        return email;
    }
    
    public void setEmail(final String email) {
        this.email = email;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(final String password) {
        this.password = password;
    }
}


// File: src/main/java/org/example/shared/dto/RegistrationDTO.java
package org.example.shared.dto;

import java.io.Serializable;

public class RegistrationDTO implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String email;
    private String password;
    private String passwordConfirmation;
    
    // Constructeur par d√©faut pour Jackson
    public RegistrationDTO() {
    }
    
    public RegistrationDTO(String email, String password, String passwordConfirmation) {
        this.email = email;
        this.password = password;
        this.passwordConfirmation = passwordConfirmation;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
    
    public String getPasswordConfirmation() {
        return passwordConfirmation;
    }
    
    public void setPasswordConfirmation(String passwordConfirmation) {
        this.passwordConfirmation = passwordConfirmation;
    }
}



// File: src/main/java/org/example/shared/model/CallSession.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Repr√©sente une session d'appel audio entre deux utilisateurs.
 */
public class CallSession {
    private String sessionId;
    private long callerUserId;
    private long receiverUserId;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private CallStatus status;
    
    /**
     * Statut possible d'un appel.
     */
    public enum CallStatus {
        INITIATING,    // L'appel est en cours d'initialisation
        RINGING,       // L'appel sonne chez le destinataire
        ACCEPTED,      // L'appel a √©t√© accept√©
        REJECTED,      // L'appel a √©t√© rejet√©
        ENDED,         // L'appel s'est termin√© normalement
        MISSED,        // L'appel a √©t√© manqu√©
        ERROR          // Une erreur s'est produite pendant l'appel
    }
    
    /**
     * Constructeur par d√©faut pour la s√©rialisation JSON.
     */
    public CallSession() {
    }
    
    /**
     * Cr√©e une nouvelle session d'appel.
     * 
     * @param callerUserId ID de l'utilisateur qui appelle
     * @param receiverUserId ID de l'utilisateur qui re√ßoit l'appel
     */
    public CallSession(long callerUserId, long receiverUserId) {
        this.sessionId = UUID.randomUUID().toString();
        this.callerUserId = callerUserId;
        this.receiverUserId = receiverUserId;
        this.startTime = LocalDateTime.now();
        this.status = CallStatus.INITIATING;
    }
    
    /**
     * Marque l'appel comme termin√©.
     */
    public void endCall() {
        this.endTime = LocalDateTime.now();
        if (this.status == CallStatus.ACCEPTED) {
            this.status = CallStatus.ENDED;
        } else if (this.status == CallStatus.RINGING) {
            this.status = CallStatus.MISSED;
        }
    }
    
    /**
     * Calcule la dur√©e de l'appel en secondes.
     * 
     * @return La dur√©e de l'appel en secondes, ou 0 si l'appel n'est pas termin√©
     */
    public long getDurationSeconds() {
        if (startTime != null && endTime != null && status == CallStatus.ENDED) {
            return java.time.Duration.between(startTime, endTime).getSeconds();
        }
        return 0;
    }

    // Getters et setters
    
    public String getSessionId() {
        return sessionId;
    }

    public void setSessionId(String sessionId) {
        this.sessionId = sessionId;
    }

    public long getCallerUserId() {
        return callerUserId;
    }

    public void setCallerUserId(long callerUserId) {
        this.callerUserId = callerUserId;
    }

    public long getReceiverUserId() {
        return receiverUserId;
    }

    public void setReceiverUserId(long receiverUserId) {
        this.receiverUserId = receiverUserId;
    }

    public LocalDateTime getStartTime() {
        return startTime;
    }

    public void setStartTime(LocalDateTime startTime) {
        this.startTime = startTime;
    }

    public LocalDateTime getEndTime() {
        return endTime;
    }

    public void setEndTime(LocalDateTime endTime) {
        this.endTime = endTime;
    }

    public CallStatus getStatus() {
        return status;
    }

    public void setStatus(CallStatus status) {
        this.status = status;
    }
}



// File: src/main/java/org/example/shared/model/CallSignal.java
package org.example.shared.model;

import java.time.LocalDateTime;

/**
 * Repr√©sente un signal de contr√¥le pour les appels audio.
 * Ces signaux sont envoy√©s via TCP pour la signalisation des appels.
 */
public class CallSignal {
    private String sessionId;
    private long senderUserId;
    private long receiverUserId;
    private SignalType type;
    private String ipAddress;
    private int port;
    private LocalDateTime timestamp;
    
    /**
     * Types de signaux pour la gestion des appels.
     */
    public enum SignalType {
        CALL_REQUEST,   // Demande d'appel
        CALL_ACCEPT,    // Acceptation d'appel
        CALL_REJECT,    // Rejet d'appel
        CALL_END,       // Fin d'appel
        CALL_BUSY       // Destinataire occup√©
    }
    
    /**
     * Constructeur par d√©faut pour la s√©rialisation JSON.
     */
    public CallSignal() {
        this.timestamp = LocalDateTime.now();
    }
    
    /**
     * Cr√©e un nouveau signal d'appel.
     * 
     * @param sessionId ID de la session d'appel
     * @param senderUserId ID de l'utilisateur qui envoie le signal
     * @param receiverUserId ID de l'utilisateur qui re√ßoit le signal
     * @param type Type de signal
     */
    public CallSignal(String sessionId, long senderUserId, long receiverUserId, SignalType type) {
        this();
        this.sessionId = sessionId;
        this.senderUserId = senderUserId;
        this.receiverUserId = receiverUserId;
        this.type = type;
    }
    
    /**
     * Cr√©e un signal de demande d'appel.
     * 
     * @param sessionId ID de la session d'appel
     * @param callerUserId ID de l'appelant
     * @param receiverUserId ID du destinataire
     * @return Un nouveau signal de demande d'appel
     */
    public static CallSignal createCallRequest(String sessionId, long callerUserId, long receiverUserId) {
        return new CallSignal(sessionId, callerUserId, receiverUserId, SignalType.CALL_REQUEST);
    }
    
    /**
     * Cr√©e un signal d'acceptation d'appel.
     * 
     * @param sessionId ID de la session d'appel
     * @param receiverUserId ID du destinataire qui accepte l'appel
     * @param callerUserId ID de l'appelant
     * @param ipAddress Adresse IP du destinataire pour la communication UDP
     * @param port Port UDP du destinataire
     * @return Un nouveau signal d'acceptation d'appel
     */
    public static CallSignal createCallAccept(String sessionId, long receiverUserId, long callerUserId, 
                                             String ipAddress, int port) {
        CallSignal signal = new CallSignal(sessionId, receiverUserId, callerUserId, SignalType.CALL_ACCEPT);
        signal.setIpAddress(ipAddress);
        signal.setPort(port);
        return signal;
    }
    
    /**
     * Cr√©e un signal de rejet d'appel.
     * 
     * @param sessionId ID de la session d'appel
     * @param receiverUserId ID du destinataire qui rejette l'appel
     * @param callerUserId ID de l'appelant
     * @return Un nouveau signal de rejet d'appel
     */
    public static CallSignal createCallReject(String sessionId, long receiverUserId, long callerUserId) {
        return new CallSignal(sessionId, receiverUserId, callerUserId, SignalType.CALL_REJECT);
    }
    
    /**
     * Cr√©e un signal de fin d'appel.
     * 
     * @param sessionId ID de la session d'appel
     * @param endingUserId ID de l'utilisateur qui termine l'appel
     * @param otherUserId ID de l'autre utilisateur
     * @return Un nouveau signal de fin d'appel
     */
    public static CallSignal createCallEnd(String sessionId, long endingUserId, long otherUserId) {
        return new CallSignal(sessionId, endingUserId, otherUserId, SignalType.CALL_END);
    }
    
    /**
     * Cr√©e un signal d'occupation.
     * 
     * @param sessionId ID de la session d'appel
     * @param busyUserId ID de l'utilisateur occup√©
     * @param callerUserId ID de l'appelant
     * @return Un nouveau signal d'occupation
     */
    public static CallSignal createCallBusy(String sessionId, long busyUserId, long callerUserId) {
        return new CallSignal(sessionId, busyUserId, callerUserId, SignalType.CALL_BUSY);
    }

    // Getters et setters
    
    public String getSessionId() {
        return sessionId;
    }

    public void setSessionId(String sessionId) {
        this.sessionId = sessionId;
    }

    public long getSenderUserId() {
        return senderUserId;
    }

    public void setSenderUserId(long senderUserId) {
        this.senderUserId = senderUserId;
    }

    public long getReceiverUserId() {
        return receiverUserId;
    }

    public void setReceiverUserId(long receiverUserId) {
        this.receiverUserId = receiverUserId;
    }

    public SignalType getType() {
        return type;
    }

    public void setType(SignalType type) {
        this.type = type;
    }

    public String getIpAddress() {
        return ipAddress;
    }

    public void setIpAddress(String ipAddress) {
        this.ipAddress = ipAddress;
    }

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }
}



// File: src/main/java/org/example/shared/model/Contact.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;

public class Contact {

    private long userId;        // FK vers User.id (celui qui ajoute)
    private long contactUserId; // FK vers User.id (celui qui est ajout√©)
    private LocalDateTime addedAt;

    // Constructeur par d√©faut
    public Contact() {
        this.addedAt = LocalDateTime.now();
    }

    // Constructeur principal
    public Contact(final long userId, final long contactUserId) {
        this();
        this.userId = userId;
        this.contactUserId = contactUserId;
    }

    // ...existing getters and setters...
    public long getUserId() { return userId; }
    public void setUserId(final long userId) { this.userId = userId; }
    public long getContactUserId() { return contactUserId; }
    public void setContactUserId(final long contactUserId) { this.contactUserId = contactUserId; }
    public LocalDateTime getAddedAt() { return addedAt; }
    public void setAddedAt(final LocalDateTime addedAt) { this.addedAt = addedAt; }

    // ...equals, hashCode, toString...
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final Contact contact = (Contact) o;
        return userId == contact.userId && contactUserId == contact.contactUserId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(userId, contactUserId);
    }

    @Override
    public String toString() {
        return "Contact{" + "userId=" + userId + ", contactUserId=" + contactUserId + ", addedAt=" + addedAt + '}';
    }
}



// File: src/main/java/org/example/shared/model/enums/MessageStatus.java
package org.example.shared.model.enums;

/**
 * D√©finit les statuts possibles d'un message.
 * 
 * Les statuts permettent de suivre l'√©tat d'un message dans le syst√®me.
 */
public enum MessageStatus {
    SENT,       // Envoy√© par le client, potentiellement en transit vers le destinataire/groupe
    DELIVERED,  // Confirm√© comme re√ßu par le serveur/broker du destinataire (pas forc√©ment lu)
    READ,       // Confirm√© comme lu par le client destinataire (n√©cessite logique d'ACK)
    FAILED,     // √âchec de l'envoi ou de la persistance
    QUEUED      // Mis en file d'attente car le destinataire √©tait hors ligne
}



// File: src/main/java/org/example/shared/model/enums/MessageType.java
package org.example.shared.model.enums;

public enum MessageType {
    TEXT,    // Message texte simple (peut √™tre chiffr√© ou non, voir champ encryptedContent)
    IMAGE,   // Message image
    VIDEO,   // Message vid√©o
    AUDIO,   // Message audio
    DOCUMENT,// Message document

    // --- NOUVEAUX TYPES POUR E2EE ---
    E2E_SESSION_INIT,    // Message contenant une cl√© de session E2EE chiffr√©e
    PUBLIC_KEY_REQUEST,  // Demande de cl√© publique d'un utilisateur
    PUBLIC_KEY_RESPONSE, // R√©ponse contenant une cl√© publique

    // --- AUTRES TYPES POSSIBLES ---
    SYSTEM,              // Message syst√®me (ex: user joined/left, non chiffr√©)
    STATUS_UPDATE        // Mise √† jour de statut (typing, read receipt)
    // Ajouter d'autres types si n√©cessaire
}


// File: src/main/java/org/example/shared/model/Group.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;

public class Group {

    private long id;
    private String name;
    private long ownerUserId; // FK vers User.id
    private LocalDateTime createdAt;
    private String profilePictureUrl; // Nouvelle propri√©t√© pour l'image

    // Constructeur par d√©faut
    public Group() {
        this.createdAt = LocalDateTime.now();
    }

    // Constructeur pour la cr√©ation initiale
    public Group(final String name, final long ownerUserId) {
        this();
        this.name = name;
        this.ownerUserId = ownerUserId;
    }

    // ...existing getters and setters...
    public long getId() { return id; }
    public void setId(final long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(final String name) { this.name = name; }
    public long getOwnerUserId() { return ownerUserId; }
    public void setOwnerUserId(final long ownerUserId) { this.ownerUserId = ownerUserId; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(final LocalDateTime createdAt) { this.createdAt = createdAt; }

    public String getProfilePictureUrl() {
        return profilePictureUrl;
    }
    public void setProfilePictureUrl(final String profilePictureUrl) {
        this.profilePictureUrl = profilePictureUrl;
    }

    // ...equals, hashCode, toString...
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final Group group = (Group) o;
        return id > 0 && id == group.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "Group{" + "id=" + id + ", name='" + name + '\'' +
               ", ownerUserId=" + ownerUserId + '}';
    }
}



// File: src/main/java/org/example/shared/model/GroupMembership.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;

public class GroupMembership {

    private long userId;   // FK vers User.id
    private long groupId;  // FK vers Group.id
    private LocalDateTime joinedAt;

    // Constructeur par d√©faut
    public GroupMembership() {
        this.joinedAt = LocalDateTime.now();
    }

    // Constructeur principal
    public GroupMembership(final long userId, final long groupId) {
        this();
        this.userId = userId;
        this.groupId = groupId;
    }

    // ...existing getters and setters...
    public long getUserId() { return userId; }
    public void setUserId(final long userId) { this.userId = userId; }
    public long getGroupId() { return groupId; }
    public void setGroupId(final long groupId) { this.groupId = groupId; }
    public LocalDateTime getJoinedAt() { return joinedAt; }
    public void setJoinedAt(final LocalDateTime joinedAt) { this.joinedAt = joinedAt; }

    // ...equals, hashCode, toString...
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final GroupMembership that = (GroupMembership) o;
        return userId == that.userId && groupId == that.groupId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(userId, groupId);
    }

    @Override
    public String toString() {
        return "GroupMembership{" + "userId=" + userId + ", groupId=" + groupId + ", joinedAt=" + joinedAt + '}';
    }
}



// File: src/main/java/org/example/shared/model/Message.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;
import java.util.Base64; // Import Base64

import org.example.shared.model.enums.MessageStatus;
import org.example.shared.model.enums.MessageType;  // Assurez-vous que cet enum est mis √† jour

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude; // Pour ne pas inclure les champs null

@JsonInclude(JsonInclude.Include.NON_NULL) // Ne pas inclure les champs null dans JSON
public class Message {

    private long id;
    private long senderUserId;   // FK vers User.id
    private Long receiverUserId; // FK vers User.id (Nullable pour les messages de groupe)
    private Long groupId;        // FK vers Group.id (Nullable pour les messages directs)
    private String content;      // Pour les messages TEXT non-E2EE, chemins de fichiers media, ou contenu sp√©cial (ex: cl√© publique)
    private LocalDateTime timestamp;
    private MessageStatus status; // Utilise l'Enum MessageStatus

    // Champs existants pour multimedia
    private MessageType type;    // Type of message (TEXT, IMAGE, VIDEO, DOCUMENT, AUDIO, E2E_SESSION_INIT, etc.)
    private String fileName;     // Original file name
    private Long fileSize;       // Size of file in bytes
    private String mimeType;     // MIME type of the file

    // --- NOUVEAUX CHAMPS POUR E2EE ---
    private byte[] encryptedContent; // Contenu chiffr√© (pour TEXT E2EE, potentiellement media)
    private String sessionKeyId;     // Identifiant de la cl√© de session utilis√©e (optionnel)
    // --- FIN NOUVEAUX CHAMPS POUR E2EE ---


    // Constructeur par d√©faut
    public Message() {
        this.timestamp = LocalDateTime.now();
        this.status = MessageStatus.SENT; // Statut par d√©faut lors de la cr√©ation c√¥t√© client
        this.type = MessageType.TEXT;     // Type par d√©faut
    }

    // --- FACTORIES EXISTANTES (Peuvent rester pour compatibilit√© ou messages syst√®me) ---

    public static Message newDirectMessage(final long senderUserId, final long receiverUserId, final String content) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setReceiverUserId(receiverUserId);
        msg.setContent(content);
        msg.setType(MessageType.TEXT); // Message texte simple (non chiffr√© par d√©faut ici)
        return msg;
    }

    public static Message newGroupMessage(final long senderUserId, final long groupId, final String content) {
        // Les messages de groupe E2EE sont complexes, ce factory reste pour du texte simple non-E2EE
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setGroupId(groupId);
        msg.setContent(content);
        msg.setType(MessageType.TEXT);
        return msg;
    }

    // Factories pour media (content contient le chemin ou l'identifiant du fichier)
    public static Message newDirectMediaMessage(final long senderUserId, final long receiverUserId,
                                                final String filePath, final MessageType type, final String fileName,
                                                final Long fileSize, final String mimeType) {
        // Pour E2EE media, il faudrait chiffrer le fichier et potentiellement mettre les bytes dans encryptedContent
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setReceiverUserId(receiverUserId);
        msg.setContent(filePath); // Le chemin reste en clair ici
        msg.setType(type);
        msg.setFileName(fileName);
        msg.setFileSize(fileSize);
        msg.setMimeType(mimeType);
        return msg;
    }

     public static Message newGroupMediaMessage(final long senderUserId, final long groupId,
                                               final String filePath, final MessageType type, final String fileName,
                                               final Long fileSize, final String mimeType) {
        // Idem pour E2EE media groupe
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setGroupId(groupId);
        msg.setContent(filePath);
        msg.setType(type);
        msg.setFileName(fileName);
        msg.setFileSize(fileSize);
        msg.setMimeType(mimeType);
        return msg;
    }


    // --- NOUVELLES FACTORIES POUR E2EE ---

    /** Cr√©e un message texte chiffr√© E2EE */
    public static Message newEncryptedTextMessage(final long senderUserId, final long receiverUserId,
                                                  final byte[] encryptedContent, final String sessionKeyId) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setReceiverUserId(receiverUserId);
        msg.setType(MessageType.TEXT); // On r√©utilise TEXT, mais on sait qu'il est chiffr√© car encryptedContent est non null
        msg.setEncryptedContent(encryptedContent);
        msg.setSessionKeyId(sessionKeyId);
        msg.setContent(null); // Le contenu clair est nul
        return msg;
    }

    /** Cr√©e un message pour initier une session E2EE (envoi de cl√© sym√©trique chiffr√©e) */
    public static Message newSessionInitMessage(final long senderUserId, final long receiverUserId,
                                                final byte[] encryptedSessionKey) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setReceiverUserId(receiverUserId);
        msg.setType(MessageType.E2E_SESSION_INIT); // Nouveau type requis dans l'enum MessageType
        msg.setEncryptedContent(encryptedSessionKey); // La cl√© chiffr√©e est dans le contenu chiffr√©
        msg.setContent(null);
        return msg;
    }

     /** Cr√©e un message pour demander la cl√© publique d'un utilisateur */
    public static Message newPublicKeyRequestMessage(final long senderUserId, final long targetUserId) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        // Pas de destinataire direct, le serveur interpr√®te la demande
        // msg.setReceiverUserId(null); // Ou un ID sp√©cial pour le serveur ?
        msg.setType(MessageType.PUBLIC_KEY_REQUEST); // Nouveau type requis
        msg.setContent(String.valueOf(targetUserId)); // Mettre l'ID demand√© dans le contenu
        return msg;
    }

     /** Cr√©e un message contenant une cl√© publique en r√©ponse √† une demande */
    public static Message newPublicKeyResponseMessage(final long keyOwnerUserId, final long recipientUserId, final String publicKeyString) {
        final Message msg = new Message();
        msg.setSenderUserId(keyOwnerUserId); // Qui poss√®de la cl√©
        msg.setReceiverUserId(recipientUserId); // √Ä qui envoyer la r√©ponse
        msg.setType(MessageType.PUBLIC_KEY_RESPONSE); // Nouveau type requis
        msg.setContent(publicKeyString); // La cl√© publique (Base64) dans le contenu
        return msg;
    }

    // --- FIN NOUVELLES FACTORIES POUR E2EE ---


    // M√©thode utilitaire existante pour cloner (√† adapter si besoin)
    public static Message copyForReceiver(final Message original, final long receiverUserId) {
        final Message copy = new Message();
        copy.setSenderUserId(original.getSenderUserId());
        copy.setReceiverUserId(receiverUserId); // D√©finit le destinataire sp√©cifique
        copy.setGroupId(original.getGroupId()); // Garde l'ID de groupe si c'est un message de groupe
        copy.setContent(original.getContent());
        copy.setTimestamp(original.getTimestamp());
        copy.setStatus(MessageStatus.QUEUED); // Le statut pour la copie est QUEUED initialement
        copy.setType(original.getType());
        copy.setFileName(original.getFileName());
        copy.setFileSize(original.getFileSize());
        copy.setMimeType(original.getMimeType());
        // Copier aussi les champs E2EE
        copy.setEncryptedContent(original.getEncryptedContent()); // Copie la r√©f√©rence du tableau de bytes
        copy.setSessionKeyId(original.getSessionKeyId());
        return copy;
    }

    // --- GETTERS ET SETTERS (Existants + Nouveaux) ---

    public long getId() { return id; }
    public void setId(final long id) { this.id = id; }
    public long getSenderUserId() { return senderUserId; }
    public void setSenderUserId(final long senderUserId) { this.senderUserId = senderUserId; }
    public Long getReceiverUserId() { return receiverUserId; }
    public void setReceiverUserId(final Long receiverUserId) { this.receiverUserId = receiverUserId; }
    public Long getGroupId() { return groupId; }
    public void setGroupId(final Long groupId) { this.groupId = groupId; }
    public String getContent() { return content; }
    public void setContent(final String content) { this.content = content; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(final LocalDateTime timestamp) { this.timestamp = timestamp; }
    public MessageStatus getStatus() { return status; }
    public void setStatus(final MessageStatus status) { this.status = status; }
    public MessageType getType() { return type; }
    public void setType(final MessageType type) { this.type = type; }
    public String getFileName() { return fileName; }
    public void setFileName(final String fileName) { this.fileName = fileName; }
    public Long getFileSize() { return fileSize; }
    public void setFileSize(final Long fileSize) { this.fileSize = fileSize; }
    public String getMimeType() { return mimeType; }
    public void setMimeType(final String mimeType) { this.mimeType = mimeType; }

    // Getters/Setters pour les champs E2EE
    public String getSessionKeyId() { return sessionKeyId; }
    public void setSessionKeyId(String sessionKeyId) { this.sessionKeyId = sessionKeyId; }

    // G√©rer la conversion Base64 pour la s√©rialisation JSON de encryptedContent
    public String getEncryptedContentBase64() {
        return (encryptedContent != null) ? Base64.getEncoder().encodeToString(encryptedContent) : null;
    }

    public void setEncryptedContentBase64(String base64Data) {
        this.encryptedContent = (base64Data != null && !base64Data.isEmpty()) ? Base64.getDecoder().decode(base64Data) : null;
    }

    @JsonIgnore // Ignorer le byte[] brut pour Jackson, utiliser la version Base64
    public byte[] getEncryptedContent() { return encryptedContent; }
    @JsonIgnore
    public void setEncryptedContent(byte[] encryptedContent) { this.encryptedContent = encryptedContent; }


    // --- M√âTHODES UTILITAIRES (@JsonIgnore) ---

    @JsonIgnore
    public boolean isDirectMessage() {
        return receiverUserId != null && groupId == null;
    }

    @JsonIgnore
    public boolean isGroupMessage() {
        return groupId != null && receiverUserId == null; // Correction: receiverUserId doit √™tre null pour groupe
    }

    @JsonIgnore
    public boolean isTextMessage() {
        // Un message TEXT est consid√©r√© comme texte simple s'il n'a pas de contenu chiffr√©
        return type == MessageType.TEXT && encryptedContent == null;
    }

     @JsonIgnore
    public boolean isEncryptedTextMessage() {
        // Un message TEXT est consid√©r√© comme chiffr√© s'il a du contenu chiffr√©
        return type == MessageType.TEXT && encryptedContent != null;
    }

    @JsonIgnore
    public boolean isMediaMessage() {
        // Inclut tous les types sauf TEXT et les types E2EE sp√©cifiques
        return type != MessageType.TEXT &&
               type != MessageType.E2E_SESSION_INIT &&
               type != MessageType.PUBLIC_KEY_REQUEST &&
               type != MessageType.PUBLIC_KEY_RESPONSE; // Ajuster si d'autres types syst√®me sont ajout√©s
    }

    // Les m√©thodes isImageMessage, isVideoMessage etc. restent valides

    @JsonIgnore
    public boolean isImageMessage() { return type == MessageType.IMAGE; }
    @JsonIgnore
    public boolean isVideoMessage() { return type == MessageType.VIDEO; }
    @JsonIgnore
    public boolean isDocumentMessage() { return type == MessageType.DOCUMENT; }
    @JsonIgnore
    public boolean isAudioMessage() { return type == MessageType.AUDIO; }

    // --- equals, hashCode, toString ---

    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final Message message = (Message) o;
        // L'√©galit√© bas√©e sur l'ID est ok si l'ID est g√©n√©r√© par la DB et unique.
        // Si l'ID n'est pas encore d√©fini (avant sauvegarde), cette √©galit√© ne fonctionne pas.
        return id > 0 && id == message.id;
    }

    @Override
    public int hashCode() {
        // Bas√© sur l'ID si > 0, sinon bas√© sur d'autres champs immuables apr√®s cr√©ation.
        return (id > 0) ? Objects.hash(id) : Objects.hash(senderUserId, receiverUserId, groupId, timestamp);
    }

    @Override
    public String toString() {
        String details = "id=" + id +
                         ", type=" + type +
                         ", senderUserId=" + senderUserId +
                         (isDirectMessage() ? ", receiverUserId=" + receiverUserId : "") +
                         (isGroupMessage() ? ", groupId=" + groupId : "") +
                         ", status=" + status +
                         ", timestamp=" + timestamp;
        if (encryptedContent != null) {
            details += ", encryptedContent=[bytes]";
        } else if (content != null) {
            details += ", content='" + content.substring(0, Math.min(content.length(), 30)) + "...'";
        }
        if (fileName != null) {
             details += ", fileName='" + fileName + "'";
        }
        return "Message{" + details + '}';
    }
}


// File: src/main/java/org/example/shared/model/User.java
package org.example.shared.model;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Objects;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;

public class User implements Serializable {
    private static final long serialVersionUID = 1L;

    private long id;
    private String email; // Unique
    private String displayName;
    private String passwordHash; // Important: C'est un HASH !
    private final BooleanProperty online = new SimpleBooleanProperty(false);
    private LocalDateTime createdAt;
    private LocalDateTime lastLoginAt; // Peut √™tre null
    private String profilePictureUrl; // URL de l'image de profil
    private String status;
    private String publicKey; // Nouveau champ pour la cl√© publique

    // Constructeur par d√©faut
    public User() {
        this.createdAt = LocalDateTime.now();
        this.online.set(false);
        this.profilePictureUrl = "/images/default_avatar.png"; // Image par d√©faut
    }

    // Constructeur pour la cr√©ation initiale (avant sauvegarde)
    public User(final String email, final String displayName, final String passwordHash) {
        this();
        this.email = email;
        this.displayName = displayName;
        this.passwordHash = passwordHash;
    }

    public long getId() { return id; }
    public void setId(final long id) { this.id = id; }
    public String getEmail() { return email; }
    public void setEmail(final String email) { this.email = email; }
    public String getDisplayName() { return displayName; }
    public void setDisplayName(final String displayName) { this.displayName = displayName; }
    public String getPasswordHash() { return passwordHash; }
    public void setPasswordHash(final String passwordHash) { this.passwordHash = passwordHash; }
    public boolean isOnline() { return online.get(); }
    public void setOnline(final boolean online) { this.online.set(online); }
    public BooleanProperty onlineProperty() { return online; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(final LocalDateTime createdAt) { this.createdAt = createdAt; }
    public LocalDateTime getLastLoginAt() { return lastLoginAt; }
    public void setLastLoginAt(final LocalDateTime lastLoginAt) { this.lastLoginAt = lastLoginAt; }
    public String getProfilePictureUrl() { 
        return profilePictureUrl; 
    }
    public void setProfilePictureUrl(final String profilePictureUrl) { 
        this.profilePictureUrl = profilePictureUrl; 
    }
    public String getStatus() { return status; }
    public void setStatus(final String status) { this.status = status; }
    public String getPublicKey() { return publicKey; }
    public void setPublicKey(final String publicKey) { this.publicKey = publicKey; }

    /**
     * Retourne le nom d'affichage si disponible, sinon l'email
     */
    public String getDisplayNameOrEmail() {
        return displayName != null && !displayName.isEmpty() ? displayName : email;
    }

    /**
     * Retourne l'URL de l'avatar ou une image par d√©faut
     */
    public String getAvatarUrl() {
        return profilePictureUrl != null && !profilePictureUrl.isEmpty() ? 
               profilePictureUrl : "/images/default_avatar.png";
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final User user = (User) o;
        if (id > 0 && user.id > 0) return id == user.id;
        return Objects.equals(email, user.email);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id > 0 ? id : email);
    }

    @Override
    public String toString() {
        return "User{" + "id=" + id + ", email='" + email + '\'' + ", displayName='" + displayName + '\'' + '}';
    }
}



// File: src/main/java/org/example/shared/util/PasswordUtils.java
package org.example.shared.util;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;

public class PasswordUtils {
    
    /**
     * G√©n√®re un hash s√©curis√© du mot de passe
     * Note: Dans une application r√©elle, on utiliserait un algorithme plus robuste comme bcrypt ou PBKDF2
     * 
     * @param password le mot de passe √† hasher
     * @return le hash du mot de passe
     */
    public static String hashPassword(String password) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(password.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Erreur lors du hashage du mot de passe", e);
        }
    }
    
    /**
     * V√©rifie si un mot de passe correspond √† un hash
     * 
     * @param password le mot de passe en clair
     * @param storedHash le hash stock√©
     * @return true si le mot de passe correspond au hash, false sinon
     */
    public static boolean verifyPassword(String password, String storedHash) {
        String passwordHash = hashPassword(password);
        return passwordHash.equals(storedHash);
    }
    
    /**
     * G√©n√®re un mot de passe al√©atoire
     * 
     * @param length la longueur du mot de passe
     * @return un mot de passe al√©atoire
     */
    public static String generateRandomPassword(int length) {
        final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+";
        SecureRandom random = new SecureRandom();
        StringBuilder sb = new StringBuilder();
        
        for (int i = 0; i < length; i++) {
            int randomIndex = random.nextInt(chars.length());
            sb.append(chars.charAt(randomIndex));
        }
        
        return sb.toString();
    }
}



// File: src/main/java/org/example/shared/util/ValidationUtils.java
package org.example.shared.util;

import java.util.regex.Pattern;

public class ValidationUtils {
    
    // Regex pour valider un email
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("^[A-Za-z0-9+_.-]+@(.+)$");
    
    /**
     * V√©rifie si l'email est valide selon le pattern d√©fini
     * @param email l'email √† valider
     * @return true si l'email est valide, false sinon
     */
    public static boolean isValidEmail(String email) {
        if (email == null || email.trim().isEmpty()) {
            return false;
        }
        return EMAIL_PATTERN.matcher(email).matches();
    }
    
    /**
     * V√©rifie si le mot de passe respecte les crit√®res de s√©curit√©:
     * - Au moins 8 caract√®res
     * - Au moins une lettre majuscule
     * - Au moins une lettre minuscule
     * - Au moins un chiffre
     * - Au moins un caract√®re sp√©cial
     * 
     * @param password le mot de passe √† valider
     * @return true si le mot de passe est valide, false sinon
     */
    public static boolean isStrongPassword(String password) {
        if (password == null || password.length() < 8) {
            return false;
        }
        
        boolean hasUppercase = false;
        boolean hasLowercase = false;
        boolean hasDigit = false;
        boolean hasSpecial = false;
        
        for (char c : password.toCharArray()) {
            if (Character.isUpperCase(c)) {
                hasUppercase = true;
            } else if (Character.isLowerCase(c)) {
                hasLowercase = true;
            } else if (Character.isDigit(c)) {
                hasDigit = true;
            } else {
                hasSpecial = true;
            }
        }
        
        return hasUppercase && hasLowercase && hasDigit && hasSpecial;
    }
    
    /**
     * V√©rifie si les deux mots de passe correspondent
     * @param password le mot de passe
     * @param confirmPassword la confirmation du mot de passe
     * @return true si les mots de passe correspondent, false sinon
     */
    public static boolean doPasswordsMatch(String password, String confirmPassword) {
        return password != null && password.equals(confirmPassword);
    }
}



// File: src/main/resources/fxml/call-dialog.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.Font?>

<VBox xmlns="http://javafx.com/javafx"
      xmlns:fx="http://javafx.com/fxml"
      fx:controller="org.example.client.gui.controllers.CallDialogController"
      spacing="15" alignment="CENTER"
      prefWidth="350" prefHeight="200"
      style="-fx-background-color: white; -fx-border-color: #cccccc; -fx-border-radius: 5;">
    
    <padding>
        <Insets top="20" right="20" bottom="20" left="20"/>
    </padding>
    
    <Label fx:id="callerNameLabel" text="Nom de l'appelant" style="-fx-font-weight: bold;">
        <font>
            <Font size="16"/>
        </font>
    </Label>
    
    <Label fx:id="callStatusLabel" text="Appel entrant...">
        <font>
            <Font size="14"/>
        </font>
    </Label>
    
    <HBox spacing="20" alignment="CENTER">
        <Button fx:id="acceptButton" text="Accepter" onAction="#handleAcceptCall" 
                style="-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-weight: bold; -fx-min-width: 100px;"/>
        <Button fx:id="rejectButton" text="Refuser" onAction="#handleRejectCall"
                style="-fx-background-color: #F44336; -fx-text-fill: white; -fx-font-weight: bold; -fx-min-width: 100px;"/>
    </HBox>
</VBox>



// File: src/main/resources/fxml/chat.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.client.gui.controllers.ChatController"
            prefHeight="600.0" prefWidth="800.0">

    <stylesheets>
        <URL value="@../css/chat.css"/>
    </stylesheets>

    <top>
        <HBox alignment="CENTER_LEFT" spacing="10" styleClass="header">
            <Label text="Chat Application" styleClass="header-text"/>
            <Button fx:id="mediaGalleryButton" text="Galerie M√©dia" styleClass="media-gallery-button"/>
            <Region HBox.hgrow="ALWAYS"/>
            <Label fx:id="userEmailLabel" styleClass="header-text"/>
            <Button text="D√©connexion" onAction="#handleLogout"/>
        </HBox>
    </top>

    <left>
        <VBox spacing="5" prefWidth="250">
            <padding>
                <Insets top="5" right="5" bottom="5" left="5"/>
            </padding>

            <Label text="Contacts" style="-fx-font-weight: bold;"/>
            <HBox spacing="5">
                <TextField fx:id="newContactField" promptText="Ajouter un contact" HBox.hgrow="ALWAYS"/>
                <Button text="+" onAction="#handleAddContact"/>
                <Button text="-" onAction="#handleRemoveContact"/>
            </HBox>
            <ListView fx:id="contactListView" VBox.vgrow="ALWAYS" styleClass="contact-list">
                <placeholder>
                    <Label text="Aucun contact"/>
                </placeholder>
            </ListView>

            <Separator>
                <padding>
                    <Insets top="10" bottom="10"/>
                </padding>
            </Separator>

            <Label text="Groupes" style="-fx-font-weight: bold;"/>
            <HBox spacing="5">
                <TextField fx:id="groupNameField" promptText="Nom du groupe" HBox.hgrow="ALWAYS"/>
                <Button text="+" onAction="#handleCreateGroup"/>
            </HBox>
            <ListView fx:id="groupListView" VBox.vgrow="ALWAYS" styleClass="group-list">
                <placeholder>
                    <Label text="Aucun groupe"/>
                </placeholder>
            </ListView>
            <HBox spacing="5">
                <TextField fx:id="memberEmailField" promptText="Email du membre" HBox.hgrow="ALWAYS"/>
                <Button text="+" onAction="#handleAddMemberToGroup"/>
                <Button text="-" onAction="#handleRemoveMemberFromGroup"/>
            </HBox>
        </VBox>
    </left>

    <center>
        <BorderPane>
            <top>
                <VBox spacing="2" style="-fx-background-color: #f5f5f5;">
                    <HBox alignment="CENTER_LEFT" style="-fx-padding: 5px;">
                        <Label fx:id="statusLabel" styleClass="status-label"/>
                    </HBox>
                    <HBox alignment="CENTER_LEFT" style="-fx-padding: 0 5px 5px 5px;">
                        <Label fx:id="groupMembersLabel" styleClass="group-members-label"/>
                    </HBox>
                </VBox>
            </top>
            <center>
                <ScrollPane fx:id="chatScrollPane" fitToWidth="true">
                    <VBox fx:id="chatHistoryContainer" spacing="5" styleClass="chat-history"/>
                </ScrollPane>
            </center>
            <bottom>
                <VBox spacing="5">
                    <!-- Media attachment indicator -->
                    <HBox fx:id="attachmentPreviewContainer" spacing="5" alignment="CENTER_LEFT" styleClass="attachment-preview" managed="false" visible="false">
                        <Label fx:id="attachmentNameLabel" styleClass="attachment-name"/>
                        <Region HBox.hgrow="ALWAYS"/>
                        <Button text="√ó" onAction="#handleRemoveAttachment" styleClass="remove-attachment-button"/>
                    </HBox>

                    <!-- Recording indicator -->
                    <HBox fx:id="recordingIndicatorContainer" spacing="5" alignment="CENTER_LEFT" styleClass="recording-indicator" managed="false" visible="false">
                        <Label text="‚ö´ Enregistrement en cours..." styleClass="recording-label"/>
                        <Region HBox.hgrow="ALWAYS"/>
                        <Label fx:id="recordingTimeLabel" text="00:00" styleClass="recording-time"/>
                    </HBox>

                    <!-- Message input area -->
                    <HBox spacing="5" alignment="CENTER_LEFT" style="-fx-padding: 10px;">
                        <!-- Media attachment button -->
                        <Button fx:id="mediaButton" text="üìé Media" styleClass="send-button" onAction="#handleMediaButtonClick"/>

                        <!-- Audio recording button -->
                        <Button fx:id="audioRecordButton" text="üé§ Audio" styleClass="send-button" onAction="#handleAudioRecordButtonClick"/>

                        <!-- Message text field -->
                        <TextField fx:id="messageField" promptText="√âcrire un message..." HBox.hgrow="ALWAYS"/>

                        <!-- Send button -->
                        <Button text="Envoyer" styleClass="send-button" onAction="#handleSendMessage"/>
                        <Button fx:id="callButton" text="üìû Appeler" styleClass="call-button" onAction="#handleCallRequest" disable="true"/>
                    </HBox>

                    <!-- Zone d'interface d'appel (initialement cach√©e) -->
                    <VBox fx:id="callControlsBox" spacing="5" style="-fx-padding: 10px; -fx-background-color: #f0f0f0; -fx-border-color: #cccccc; -fx-border-radius: 5;" visible="false" managed="false">
                        <HBox alignment="CENTER_LEFT" spacing="10">
                            <Label fx:id="callStatusLabel" text="Aucun appel en cours" HBox.hgrow="ALWAYS"/>
                            <Button fx:id="acceptCallButton" text="Accepter" onAction="#handleAcceptCall" visible="false" managed="false"/>
                            <Button fx:id="rejectCallButton" text="Refuser" onAction="#handleRejectCall" visible="false" managed="false"/>
                            <Button fx:id="endCallButton" text="Terminer" onAction="#handleEndCall" visible="false" managed="false"/>
                            <ToggleButton fx:id="muteButton" text="Muet" onAction="#handleToggleMute" visible="false" managed="false"/>
                        </HBox>
                    </VBox>
                </VBox>
            </bottom>
        </BorderPane>
    </center>
</BorderPane>


// File: src/main/resources/fxml/login.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.PasswordField?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>
<?import javafx.scene.control.Hyperlink?>

<BorderPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="400.0" minWidth="600.0"
    prefHeight="400.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/17"
    xmlns:fx="http://javafx.com/fxml/1" fx:controller="org.example.client.gui.controllers.LoginController">
    <center>
        <VBox alignment="CENTER" maxWidth="400.0" spacing="15.0" BorderPane.alignment="CENTER">
            <children>
                <Label text="Chat Application" textAlignment="CENTER">
                    <font>
                        <Font name="System Bold" size="24.0" />
                    </font>
                </Label>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Email" />
                        <TextField fx:id="emailField" promptText="Entrez votre email" />
                    </children>
                </VBox>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Mot de passe" />
                        <PasswordField fx:id="passwordField" promptText="Entrez votre mot de passe" />
                    </children>
                </VBox>
                <Button fx:id="loginButton" defaultButton="true" maxWidth="1.7976931348623157E308"
                    mnemonicParsing="false" onAction="#handleLogin" text="Se connecter">
                    <VBox.margin>
                        <Insets top="10.0" />
                    </VBox.margin>
                </Button>
                <HBox alignment="CENTER" spacing="5.0">
                    <children>
                        <Label text="Pas encore de compte ?" />
                        <Hyperlink onAction="#handleRegisterLink" text="Cr√©er un compte" />
                    </children>
                    <VBox.margin>
                        <Insets top="10.0" />
                    </VBox.margin>
                </HBox>
            </children>
            <BorderPane.margin>
                <Insets left="20.0" right="20.0" />
            </BorderPane.margin>
            <padding>
                <Insets bottom="20.0" left="20.0" right="20.0" top="20.0" />
            </padding>
        </VBox>
    </center>
    <bottom>
        <HBox alignment="CENTER" prefHeight="50.0" spacing="10.0" BorderPane.alignment="CENTER">
            <children>
                <Label text=" 2025 Chat Application" textFill="#686868" />
            </children>
        </HBox>
    </bottom>
</BorderPane>


// File: src/main/resources/fxml/media_dialog.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.Text?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.client.gui.controllers.MediaDialogController"
            prefWidth="500.0" prefHeight="400.0">

    <top>
        <HBox alignment="CENTER" spacing="10" style="-fx-background-color: #4caf50; -fx-padding: 10px;">
            <Label text="Envoyer un m√©dia" style="-fx-text-fill: white; -fx-font-size: 16px;"/>
        </HBox>
    </top>

    <center>
        <VBox spacing="15" style="-fx-padding: 20px;">
            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Type de m√©dia:" />
                <ComboBox fx:id="mediaTypeComboBox" promptText="Choisir type de m√©dia" prefWidth="200"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Fichier:" />
                <TextField fx:id="filePathField" editable="false" HBox.hgrow="ALWAYS" />
                <Button text="Parcourir..." onAction="#handleBrowseFile" />
            </HBox>

            <VBox fx:id="previewContainer" VBox.vgrow="ALWAYS" spacing="10" style="-fx-padding: 10px; -fx-border-color: #ddd; -fx-border-radius: 5px;">
                <Text text="Aper√ßu du m√©dia sera affich√© ici" style="-fx-fill: #999;"/>
            </VBox>

            <HBox fx:id="recordAudioContainer" spacing="10" alignment="CENTER_LEFT" visible="false" managed="false">
                <Button fx:id="recordButton" text="üé§ Enregistrer" onAction="#handleRecordAudio" />
                <Label fx:id="recordingTimeLabel" text="00:00" />
                <Region HBox.hgrow="ALWAYS" />
                <ProgressBar fx:id="audioLevelIndicator" progress="0" prefWidth="100" />
            </HBox>
        </VBox>
    </center>

    <bottom>
        <HBox alignment="CENTER_RIGHT" spacing="10" style="-fx-padding: 10px; -fx-background-color: #f5f5f5;">
            <Button text="Annuler" onAction="#handleCancel" style="-fx-padding: 5px 15px;" />
            <Button fx:id="sendButton" text="Envoyer" onAction="#handleSend" style="-fx-padding: 5px 15px; -fx-background-color: #4caf50; -fx-text-fill: white;" />
        </HBox>
    </bottom>

</BorderPane>


// File: src/main/resources/fxml/media_gallery.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.client.gui.controllers.MediaGalleryController"
            prefWidth="800.0" prefHeight="600.0">

    <top>
        <HBox alignment="CENTER_LEFT" spacing="10" style="-fx-background-color: #4caf50; -fx-padding: 10px;">
            <Label fx:id="titleLabel" text="Galerie m√©dia"
                   style="-fx-text-fill: white; -fx-font-size: 18px;"/>
            <Region HBox.hgrow="ALWAYS"/>
            <ComboBox fx:id="mediaTypeFilter" prefWidth="150"/>
        </HBox>
    </top>

    <center>
        <ScrollPane fitToWidth="true" fitToHeight="true">
            <FlowPane fx:id="mediaContainer" hgap="10" vgap="10" prefWrapLength="700">
                <padding>
                    <Insets top="10" right="10" bottom="10" left="10"/>
                </padding>
            </FlowPane>
        </ScrollPane>
    </center>

    <bottom>
        <HBox alignment="CENTER_RIGHT" spacing="10" style="-fx-padding: 10px; -fx-background-color: #f5f5f5;">
            <Label fx:id="statsLabel" text="Total: 0 m√©dias"/>
            <Region HBox.hgrow="ALWAYS"/>
            <Button text="Fermer" onAction="#handleClose"
                    style="-fx-padding: 5px 15px;"/>
        </HBox>
    </bottom>

</BorderPane>


// File: src/main/resources/fxml/register.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Hyperlink?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.PasswordField?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<BorderPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="500.0" minWidth="600.0"
    prefHeight="500.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/17"
    xmlns:fx="http://javafx.com/fxml/1" fx:controller="org.example.client.gui.controllers.RegisterController">
    <center>
        <VBox alignment="CENTER" maxWidth="400.0" spacing="15.0" BorderPane.alignment="CENTER">
            <children>
                <Label text="Cr√©er un compte" textAlignment="CENTER">
                    <font>
                        <Font name="System Bold" size="24.0" />
                    </font>
                </Label>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Email" />
                        <TextField fx:id="emailField" promptText="Entrez votre email" />
                        <Label fx:id="emailErrorLabel" styleClass="error-label" textFill="RED" visible="false" />
                    </children>
                </VBox>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Mot de passe" />
                        <PasswordField fx:id="passwordField" promptText="Entrez votre mot de passe" />
                        <Label fx:id="passwordErrorLabel" styleClass="error-label" textFill="RED" visible="false" />
                    </children>
                </VBox>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Confirmer le mot de passe" />
                        <PasswordField fx:id="confirmPasswordField" promptText="Confirmez votre mot de passe" />
                        <Label fx:id="confirmPasswordErrorLabel" styleClass="error-label" textFill="RED" visible="false" />
                    </children>
                </VBox>
                <Label fx:id="passwordRequirementsLabel" text="Le mot de passe doit contenir au moins 8 caract√®res, une majuscule, une minuscule, un chiffre et un caract√®re sp√©cial." textFill="#686868" wrapText="true">
                    <font>
                        <Font size="11.0" />
                    </font>
                </Label>
                <Button fx:id="registerButton" defaultButton="true" maxWidth="1.7976931348623157E308"
                    mnemonicParsing="false" onAction="#handleRegister" text="S'inscrire">
                    <VBox.margin>
                        <Insets top="10.0" />
                    </VBox.margin>
                </Button>
                <HBox alignment="CENTER" spacing="5.0">
                    <children>
                        <Label text="Vous avez d√©j√† un compte ?" />
                        <Hyperlink onAction="#handleLoginLink" text="Se connecter" />
                    </children>
                </HBox>
            </children>
            <BorderPane.margin>
                <Insets left="20.0" right="20.0" />
            </BorderPane.margin>
            <padding>
                <Insets bottom="20.0" left="20.0" right="20.0" top="20.0" />
            </padding>
        </VBox>
    </center>
    <bottom>
        <HBox alignment="CENTER" prefHeight="50.0" spacing="10.0" BorderPane.alignment="CENTER">
            <children>
                <Label text="¬© 2025 Chat Application" textFill="#686868" />
            </children>
        </HBox>
    </bottom>
</BorderPane>



