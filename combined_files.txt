// File: src/main/java/org/example/client/exception/PublicKeyNotAvailableException.java
package org.example.client.exception;

/**
 * Exception levée lorsque la clé publique d'un destinataire n'est pas
 * disponible localement et qu'une demande a été envoyée au serveur.
 * L'opération (par ex. envoi de message) doit être retentée ultérieurement.
 */
public class PublicKeyNotAvailableException extends Exception {
    public PublicKeyNotAvailableException(final String message) {
        super(message);
    }
}



// File: src/main/java/org/example/client/gui/ChatClientApplication.java
package org.example.client.gui;

import java.io.IOException;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.stage.Stage;

public class ChatClientApplication extends Application {

    @Override
    public void start(final Stage primaryStage) {
        try {
            // Vérification que les ressources FXML peuvent être chargées
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            final Parent root = loader.load();
            
            primaryStage.setTitle("Chat Application");
            primaryStage.setScene(new Scene(root, 600, 400));
            primaryStage.setMinWidth(600);
            primaryStage.setMinHeight(400);
            primaryStage.show();
        } catch (final IOException e) {
            showErrorAndExit("Erreur de chargement FXML", 
                    "Impossible de charger l'interface utilisateur: " + e.getMessage());
        } catch (final Exception e) {
            showErrorAndExit("Erreur d'initialisation", 
                    "L'application n'a pas pu démarrer correctement: " + e.getMessage());
        }
    }

    /**
     * Affiche une erreur et quitte l'application
     */
    private void showErrorAndExit(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText("Erreur critique");
        alert.setContentText(message);
        alert.showAndWait();
        Platform.exit();
    }

    public static void main(final String[] args) {
        try {
            launch(args);
        } catch (final Exception e) {
            System.err.println("Erreur lors du lancement de l'application JavaFX:");
            System.err.println("Cette erreur peut être due à l'absence de modules JavaFX.");
            System.err.println("Veuillez lancer l'application avec les arguments VM suivants:");
            System.err.println("--module-path <chemin/vers/javafx-sdk>/lib --add-modules javafx.controls,javafx.fxml");
            e.printStackTrace();
        }
    }
    
    @Override
    public void stop() {
        // Nettoyage des ressources lors de la fermeture de l'application
        System.out.println("Application fermée");
    }
}



// File: src/main/java/org/example/client/gui/controllers/CallDialogController.java
package org.example.client.gui.controllers;

import java.net.URL;
import java.util.ResourceBundle;

import org.example.client.gui.service.CallManager;
import org.example.shared.model.CallSession;
import org.example.shared.model.User;

import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.stage.Stage;

/**
 * Contrôleur pour la fenêtre de dialogue d'appel entrant.
 */
public class CallDialogController implements Initializable {
    
    @FXML private Label callerNameLabel;
    @FXML private Label callStatusLabel;
    @FXML private Button acceptButton;
    @FXML private Button rejectButton;
    
    private CallSession callSession;
    private User caller;
    private String callerIp;
    private int callerPort;
    private Runnable onAcceptCallback;
    private Runnable onRejectCallback;
    
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        // Rien à initialiser ici
    }
    
    /**
     * Initialise le dialogue avec les informations d'appel.
     * 
     * @param session La session d'appel
     * @param caller L'utilisateur qui appelle
     * @param callerIp L'adresse IP de l'appelant
     * @param callerPort Le port UDP de l'appelant
     * @param onAccept Callback à exécuter si l'appel est accepté
     * @param onReject Callback à exécuter si l'appel est rejeté
     */
    public void initData(CallSession session, User caller, String callerIp, int callerPort, 
                         Runnable onAccept, Runnable onReject) {
        this.callSession = session;
        this.caller = caller;
        this.callerIp = callerIp;
        this.callerPort = callerPort;
        this.onAcceptCallback = onAccept;
        this.onRejectCallback = onReject;
        
        // Mettre à jour l'interface utilisateur
        Platform.runLater(() -> {
            callerNameLabel.setText("Appel de " + caller.getDisplayNameOrEmail());
        });
    }
    
    /**
     * Gère l'acceptation de l'appel.
     */
    @FXML
    private void handleAcceptCall(ActionEvent event) {
        // Mettre à jour l'interface utilisateur
        acceptButton.setDisable(true);
        rejectButton.setDisable(true);
        callStatusLabel.setText("Connexion en cours...");
        
        // Accepter l'appel via le CallManager
        CallManager.getInstance().acceptCall(callSession, callerIp, callerPort);
        
        // Exécuter le callback d'acceptation
        if (onAcceptCallback != null) {
            onAcceptCallback.run();
        }
        
        // Fermer la fenêtre
        closeDialog();
    }
    
    /**
     * Gère le rejet de l'appel.
     */
    @FXML
    private void handleRejectCall(ActionEvent event) {
        // Mettre à jour l'interface utilisateur
        acceptButton.setDisable(true);
        rejectButton.setDisable(true);
        callStatusLabel.setText("Appel refusé");
        
        // Exécuter le callback de rejet
        if (onRejectCallback != null) {
            onRejectCallback.run();
        }
        
        // Fermer la fenêtre
        closeDialog();
    }
    
    /**
     * Ferme la fenêtre de dialogue.
     */
    private void closeDialog() {
        Platform.runLater(() -> {
            Stage stage = (Stage) acceptButton.getScene().getWindow();
            stage.close();
        });
    }
}



// File: src/main/java/org/example/client/gui/controllers/ChatController.java
package org.example.client.gui.controllers;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import javax.sound.sampled.LineUnavailableException;

import org.example.client.exception.PublicKeyNotAvailableException;
import org.example.client.gui.repository.JsonLocalMessageRepository;
import org.example.client.gui.security.KeyManager;
import org.example.client.gui.service.AudioRecorderService;
import org.example.client.gui.service.CallManager;
import org.example.client.gui.service.ChatService;
import org.example.client.gui.service.ContactService;
import org.example.client.gui.service.FileService;
import org.example.client.gui.service.GroupService;
import org.example.client.gui.service.UserService;
import org.example.shared.model.CallSession;
import org.example.shared.model.CallSignal;
import org.example.shared.model.Group;
import org.example.shared.model.Message;
import org.example.shared.model.User;
import org.example.shared.model.enums.MessageType;

import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.MenuItem;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextField;
import javafx.scene.control.ToggleButton;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import javafx.scene.media.MediaView;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.stage.FileChooser;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class ChatController {
    @FXML
    private Label userEmailLabel;
    @FXML
    private ListView<User> contactListView;
    @FXML
    private ListView<Group> groupListView;
    @FXML
    private TextField newContactField, messageField, groupNameField, memberEmailField;
    @FXML
    private VBox chatHistoryContainer;
    @FXML
    private ScrollPane chatScrollPane;
    @FXML
    private Label statusLabel;
    @FXML
    private Button mediaButton;
    @FXML
    private Button audioRecordButton;
    @FXML
    private HBox attachmentPreviewContainer;
    @FXML
    private Label attachmentNameLabel;
    @FXML
    private HBox recordingIndicatorContainer;
    @FXML
    private Label recordingTimeLabel;

    @FXML
    private Button mediaGalleryButton;

    @FXML
    private Label groupMembersLabel;

    // Éléments d'interface pour les appels
    @FXML
    private Button callButton;
    @FXML
    private VBox callControlsBox;
    @FXML
    private Label callStatusLabel;
    @FXML
    private Button acceptCallButton;
    @FXML
    private Button rejectCallButton;
    @FXML
    private Button endCallButton;
    @FXML
    private ToggleButton muteButton;

    private ChatService chatService;
    private String userEmail;
    private User selectedContactUser;
    private Group selectedGroup;

    private final ObservableList<User> contacts = FXCollections.observableArrayList();
    private final ObservableList<Group> groups = FXCollections.observableArrayList();

    private final JsonLocalMessageRepository localRepo = new JsonLocalMessageRepository();
    private final ContactService contactService = new ContactService();
    private final GroupService groupService = new GroupService();
    private final UserService userService = new UserService();
    private final CallManager callManager = CallManager.getInstance();
    private final FileService fileService = new FileService();
    private final AudioRecorderService audioRecorderService = new AudioRecorderService();

    private final Object loadLock = new Object();

    private static final DateTimeFormatter TIME_FMT = DateTimeFormatter.ofPattern("HH:mm");

    // Media attachment state
    private File selectedMediaFile;
    private MessageType selectedMediaType;

    // Audio recording state
    private boolean isRecording = false;
    private Timer recordingTimer;
    private int recordingSeconds = 0;

    // KeyManager for E2EE
    private KeyManager keyManager;

    @FXML
    public void initialize() {
        mediaGalleryButton.setOnAction(this::handleOpenMediaGallery);
        contactListView.setItems(contacts);
        groupListView.setItems(groups);

        contactListView.setCellFactory(list -> createCell(
                user -> user.getDisplayNameOrEmail(),
                user -> {
                    try {
                        return localRepo.getLastContactMessage(userEmail,
                                chatService.getCurrentUserId(),
                                user.getId());
                    } catch (final IOException e) {
                        return Optional.empty();
                    }
                },
                User::getAvatarUrl,
                msg -> msg.map(m -> {
                    try {
                        final String prefix = (m.getSenderUserId() == chatService.getCurrentUserId()) ? "Vous: " : "";
                        if (m.isTextMessage()) {
                            return prefix + truncate(m.getContent(), 30);
                        } else {
                            final String mediaTypeIcon = getMediaTypeIcon(m.getType());
                            return prefix + mediaTypeIcon + " " + (m.getFileName() != null ? m.getFileName() : "Média");
                        }
                    } catch (final Exception e) {
                        return "Erreur chargement";
                    }
                }).orElse("")));

        groupListView.setCellFactory(list -> createCell(
                group -> group.getName(),
                group -> {
                    try {
                        return localRepo.getLastGroupMessage(userEmail, group.getId());
                    } catch (final IOException e) {
                        return Optional.empty();
                    }
                },
                group -> Optional.ofNullable(group.getProfilePictureUrl())
                        .filter(u -> !u.isEmpty())
                        .orElse("/images/default_group.png"),
                msg -> msg.map(m -> {
                    String name = "Inconnu";
                    try {
                        name = userService.getUserById(m.getSenderUserId()).getEmail().split("@")[0];
                    } catch (final IOException e) {
                        /* ignore */ }
                    final String prefix = (m.getSenderUserId() == chatService.getCurrentUserId() ? "Vous: "
                            : name + ": ");
                    if (m.isTextMessage()) {
                        return prefix + truncate(m.getContent(), 30);
                    } else {
                        final String mediaTypeIcon = getMediaTypeIcon(m.getType());
                        return prefix + mediaTypeIcon + " " + (m.getFileName() != null ? m.getFileName() : "Média");
                    }
                }).orElse("")));

        contactListView.getSelectionModel().selectedItemProperty().addListener((obs, old, sel) -> {
            if (sel != null) {
                groupListView.getSelectionModel().clearSelection();
                selectedContactUser = sel;
                selectedGroup = null;
                loadContactConversation(selectedContactUser);

                // Effacer l'affichage des membres pour une conversation individuelle
                groupMembersLabel.setText("");

                setStatus("Conversation chargée avec " + selectedContactUser.getDisplayNameOrEmail());

                // Activer le bouton d'appel uniquement pour les conversations de contact (pas
                // de groupe)
                callButton.setDisable(false);
            }
        });

        groupListView.getSelectionModel().selectedItemProperty().addListener((obs, old, sel) -> {
            if (sel != null) {
                contactListView.getSelectionModel().clearSelection();
                selectedGroup = sel;
                selectedContactUser = null;
                loadGroupConversation(sel);

                // Les membres seront affichés par la méthode loadGroupConversation
                // qui appelle displayGroupMembers

                setStatus("Conversation de groupe chargée : " + sel.getName());

                // Désactiver le bouton d'appel pour les conversations de groupe
                callButton.setDisable(true);
            }
        });

        messageField.setOnAction(this::handleSendMessage);

        // Initialiser l'interface d'appel
        initCallUI();

        // Initialize media button context menu
        final ContextMenu mediaMenu = new ContextMenu();

        final MenuItem imageItem = new MenuItem("Image");
        imageItem.setOnAction(e -> openMediaFileChooser("Images", "*.png", "*.jpg", "*.jpeg", "*.gif"));

        final MenuItem videoItem = new MenuItem("Vidéo");
        videoItem.setOnAction(e -> openMediaFileChooser("Vidéos", "*.mp4", "*.avi", "*.mov", "*.wmv"));

        final MenuItem documentItem = new MenuItem("Document");
        documentItem.setOnAction(e -> openMediaFileChooser("Documents", "*.*"));

        mediaMenu.getItems().addAll(imageItem, videoItem, documentItem);

        mediaButton.setOnMouseClicked(e -> {
            mediaMenu.show(mediaButton, e.getScreenX(), e.getScreenY());
        });

        // Check if audio recording is supported
        if (!audioRecorderService.isAudioRecordingSupported()) {
            audioRecordButton.setDisable(true);
            audioRecordButton.setTooltip(
                    new javafx.scene.control.Tooltip("L'enregistrement audio n'est pas pris en charge sur ce système"));
        }
    }

    private String getMediaTypeIcon(final MessageType type) {
        switch (type) {
            case IMAGE:
                return "🖼️";
            case VIDEO:
                return "🎬";
            case AUDIO:
                return "🔊";
            case DOCUMENT:
                return "📄";
            default:
                return "";
        }
    }

    public void initData(final ChatService service, final String userEmail, final KeyManager keyManager) {
        this.chatService = service;
        this.userEmail = userEmail;
        this.keyManager = keyManager;
        userEmailLabel.setText(userEmail);

        chatService.setMessageConsumer(this::handleIncomingMessage);
        chatService.setCallSignalConsumer(this::handleCallSignal);
        loadContacts();
        loadGroups();

        // Démarrer le rafraîchissement périodique des statuts
        startContactStatusUpdater();

        // Initialiser l'UI d'appel
        initCallUI();
    }

    /**
     * Initialise l'interface utilisateur pour les appels.
     */
    private void initCallUI() {
        // Lier le label de statut d'appel au CallManager
        callStatusLabel.textProperty().bind(callManager.callStatusProperty());

        // Initialiser les boutons d'appel comme invisibles
        callControlsBox.setVisible(false);
        callControlsBox.setManaged(false);
        acceptCallButton.setVisible(false);
        acceptCallButton.setManaged(false);
        rejectCallButton.setVisible(false);
        rejectCallButton.setManaged(false);
        endCallButton.setVisible(false);
        endCallButton.setManaged(false);
        muteButton.setVisible(false);
        muteButton.setManaged(false);
    }

    /**
     * Gère une demande d'appel (bouton Appeler).
     */
    @FXML
    private void handleCallRequest(final ActionEvent event) {
        if (selectedContactUser == null) {
            setStatus("Veuillez sélectionner un contact pour appeler");
            return;
        }

        try {
            // Créer une nouvelle session d'appel
            final User currentUser = userService.getUserByEmail(userEmail);
            final CallSession callSession = new CallSession(currentUser.getId(), selectedContactUser.getId());

            // Initialiser l'appel dans le CallManager
            if (!callManager.initiateCall(selectedContactUser, callSession)) {
                setStatus("Impossible d'initialiser l'appel. Un appel est peut-être déjà en cours.");
                return;
            }

            // Envoyer le signal d'appel
            final CallSignal callRequest = chatService.createCallRequest(callSession, selectedContactUser.getEmail());
            chatService.sendCallSignal(callRequest);

            // Afficher l'interface d'appel
            showCallUI(false);

            setStatus("Appel en cours vers " + selectedContactUser.getDisplayNameOrEmail());
        } catch (final IOException e) {
            setStatus("Erreur lors de l'appel : " + e.getMessage());
        }
    }

    /**
     * Gère l'acceptation d'un appel.
     */
    @FXML
    private void handleAcceptCall(final ActionEvent event) {
        try {
            final CallSession currentSession = callManager.getCurrentSession();
            if (currentSession == null) {
                setStatus("Aucun appel à accepter");
                return;
            }

            // Initialiser le CallManager qui va créer le socket UDP et obtenir un port
            // Le port local sera maintenant géré par le CallManager

            // Récupérer le port local attribué par le CallManager
            final int localPort = callManager.getLocalPort();
            System.out.println("Acceptation d'appel avec port local: " + localPort);

            // Envoyer le signal d'acceptation avec l'adresse IP et le port local
            final CallSignal acceptSignal = chatService.createCallAccept(
                    currentSession.getSessionId(),
                    currentSession.getCallerUserId(),
                    localPort);
            chatService.sendCallSignal(acceptSignal);

            // Mettre à jour l'interface d'appel
            updateCallUIForActiveCall();

            setStatus("Appel accepté");
        } catch (final IOException e) {
            setStatus("Erreur lors de l'acceptation de l'appel : " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Gère le rejet d'un appel.
     */
    @FXML
    private void handleRejectCall(final ActionEvent event) {
        try {
            final CallSession currentSession = callManager.getCurrentSession();
            if (currentSession == null) {
                setStatus("Aucun appel à rejeter");
                return;
            }

            // Envoyer le signal de rejet
            final CallSignal rejectSignal = chatService.createCallReject(
                    currentSession.getSessionId(),
                    currentSession.getCallerUserId());
            chatService.sendCallSignal(rejectSignal);

            // Terminer l'appel localement
            callManager.endCall();

            // Masquer l'interface d'appel
            hideCallUI();

            setStatus("Appel rejeté");
        } catch (final IOException e) {
            setStatus("Erreur lors du rejet de l'appel : " + e.getMessage());
        }
    }

    /**
     * Gère la fin d'un appel en cours.
     */
    @FXML
    private void handleEndCall(final ActionEvent event) {
        try {
            final CallSession currentSession = callManager.getCurrentSession();
            if (currentSession == null) {
                setStatus("Aucun appel à terminer");
                return;
            }

            // Déterminer l'autre utilisateur dans l'appel
            final long otherUserId = (currentSession.getCallerUserId() == chatService.getCurrentUserId())
                    ? currentSession.getReceiverUserId()
                    : currentSession.getCallerUserId();

            // Envoyer le signal de fin d'appel
            final CallSignal endSignal = chatService.createCallEnd(
                    currentSession.getSessionId(),
                    otherUserId);
            chatService.sendCallSignal(endSignal);

            // Terminer l'appel localement
            callManager.endCall();

            // Masquer l'interface d'appel
            hideCallUI();

            setStatus("Appel terminé");
        } catch (final IOException e) {
            setStatus("Erreur lors de la fin de l'appel : " + e.getMessage());
        }
    }

    /**
     * Gère l'activation/désactivation du microphone.
     */
    @FXML
    private void handleToggleMute(final ActionEvent event) {
        final boolean muted = muteButton.isSelected();
        callManager.setMicrophoneMuted(muted);
        muteButton.setText(muted ? "Activer micro" : "Muet");
    }

    /**
     * Gère les signaux d'appel reçus.
     */
    private void handleCallSignal(final CallSignal signal) {
        Platform.runLater(() -> {
            try {
                switch (signal.getType()) {
                    case CALL_REQUEST:
                        handleIncomingCallRequest(signal);
                        break;

                    case CALL_ACCEPT:
                        handleCallAccepted(signal);
                        break;

                    case CALL_REJECT:
                        handleCallRejected(signal);
                        break;

                    case CALL_END:
                        handleCallEnded(signal);
                        break;

                    case CALL_BUSY:
                        handleCallBusy(signal);
                        break;
                }
            } catch (final Exception e) {
                setStatus("Erreur lors du traitement du signal d'appel : " + e.getMessage());
            }
        });
    }

    /**
     * Gère une demande d'appel entrante.
     */
    private void handleIncomingCallRequest(final CallSignal signal) throws IOException {
        // Vérifier si un appel est déjà en cours
        if (callManager.isCallActive()) {
            // Envoyer un signal d'occupation
            final CallSignal busySignal = CallSignal.createCallBusy(
                    signal.getSessionId(),
                    signal.getReceiverUserId(),
                    signal.getSenderUserId());
            chatService.sendCallSignal(busySignal);
            return;
        }

        // Récupérer l'utilisateur appelant
        final User caller = userService.getUserById(signal.getSenderUserId());

        // Créer une session d'appel
        final CallSession callSession = new CallSession(signal.getSenderUserId(), signal.getReceiverUserId());
        callSession.setSessionId(signal.getSessionId());
        callSession.setStatus(CallSession.CallStatus.RINGING);

        // Définir l'utilisateur distant dans le CallManager
        callManager.setRemoteUser(caller);

        // Afficher la fenêtre de dialogue d'appel entrant
        showIncomingCallDialog(callSession, caller);
    }

    /**
     * Gère l'acceptation d'un appel par le destinataire.
     */
    private void handleCallAccepted(final CallSignal signal) {
        // Configurer la connexion d'appel avec les informations du destinataire
        callManager.setupCallConnection(signal.getIpAddress(), signal.getPort());

        // Mettre à jour l'interface d'appel
        updateCallUIForActiveCall();
    }

    /**
     * Gère le rejet d'un appel par le destinataire.
     */
    private void handleCallRejected(final CallSignal signal) {
        // Terminer l'appel localement
        callManager.endCall();

        // Masquer l'interface d'appel
        hideCallUI();

        setStatus("Appel rejeté par le destinataire");
    }

    /**
     * Gère la fin d'un appel par l'autre partie.
     */
    private void handleCallEnded(final CallSignal signal) {
        // Terminer l'appel localement
        callManager.endCall();

        // Masquer l'interface d'appel
        hideCallUI();

        setStatus("Appel terminé par l'autre partie");
    }

    /**
     * Gère le cas où le destinataire est occupé.
     */
    private void handleCallBusy(final CallSignal signal) {
        // Terminer l'appel localement
        callManager.endCall();

        // Masquer l'interface d'appel
        hideCallUI();

        setStatus("Le destinataire est occupé");
    }

    /**
     * Affiche la fenêtre de dialogue pour un appel entrant.
     */
    private void showIncomingCallDialog(final CallSession callSession, final User caller) {
        try {
            // Charger le FXML de la fenêtre de dialogue
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/call-dialog.fxml"));
            final Parent dialogRoot = loader.load();

            // Récupérer le contrôleur
            final CallDialogController controller = loader.getController();

            // Initialiser le contrôleur avec les informations d'appel
            controller.initData(
                    callSession,
                    caller,
                    null, // L'adresse IP sera définie lors de l'acceptation
                    0, // Le port sera défini lors de l'acceptation
                    () -> {
                        // Callback pour l'acceptation
                        showCallUI(true);
                    },
                    () -> {
                        // Callback pour le rejet
                        // Rien à faire ici, le contrôleur envoie déjà le signal de rejet
                    });

            // Créer et afficher la fenêtre
            final Stage dialogStage = new Stage();
            dialogStage.initModality(Modality.APPLICATION_MODAL);
            dialogStage.initStyle(StageStyle.UNDECORATED);
            dialogStage.setScene(new Scene(dialogRoot));
            dialogStage.setTitle("Appel entrant");
            dialogStage.show();

        } catch (final IOException e) {
            setStatus("Erreur lors de l'affichage de la fenêtre d'appel : " + e.getMessage());
        }
    }

    /**
     * Affiche l'interface d'appel.
     *
     * @param incoming true si c'est un appel entrant, false si c'est un appel
     *                 sortant
     */
    private void showCallUI(final boolean incoming) {
        callControlsBox.setVisible(true);
        callControlsBox.setManaged(true);

        if (incoming) {
            // Pour un appel entrant, on affiche les boutons Accepter et Refuser
            acceptCallButton.setVisible(true);
            acceptCallButton.setManaged(true);
            rejectCallButton.setVisible(true);
            rejectCallButton.setManaged(true);
            endCallButton.setVisible(false);
            endCallButton.setManaged(false);
            muteButton.setVisible(false);
            muteButton.setManaged(false);
        } else {
            // Pour un appel sortant, on affiche uniquement le bouton Terminer
            acceptCallButton.setVisible(false);
            acceptCallButton.setManaged(false);
            rejectCallButton.setVisible(false);
            rejectCallButton.setManaged(false);
            endCallButton.setVisible(true);
            endCallButton.setManaged(true);
            muteButton.setVisible(false);
            muteButton.setManaged(false);
        }
    }

    /**
     * Met à jour l'interface d'appel pour un appel actif.
     */
    private void updateCallUIForActiveCall() {
        callControlsBox.setVisible(true);
        callControlsBox.setManaged(true);

        acceptCallButton.setVisible(false);
        acceptCallButton.setManaged(false);
        rejectCallButton.setVisible(false);
        rejectCallButton.setManaged(false);
        endCallButton.setVisible(true);
        endCallButton.setManaged(true);
        muteButton.setVisible(true);
        muteButton.setManaged(true);
    }

    /**
     * Masque l'interface d'appel.
     */
    private void hideCallUI() {
        callControlsBox.setVisible(false);
        callControlsBox.setManaged(false);
    }

    private <T> ListCell<T> createCell(
            final java.util.function.Function<T, String> nameFn,
            final java.util.function.Function<T, Optional<Message>> lastMsgFn,
            final java.util.function.Function<T, String> avatarUrlFn,
            final java.util.function.Function<Optional<Message>, String> msgTextFn) {
        return new ListCell<T>() {
            private User currentUser = null;
            private final ChangeListener<Boolean> onlineListener = (obs, oldVal, newVal) -> {
                updateOnlineIndicator(newVal);
            };

            private final HBox hbox = new HBox(10);
            private final ImageView avatar = new ImageView();
            private final VBox contentBox = new VBox(2);
            private final Label nameLabel = new Label();
            private final Label lastMsgLabel = new Label();
            private final Circle onlineIndicator = new Circle(5);

            {
                hbox.setPadding(new Insets(5));
                hbox.setAlignment(Pos.CENTER_LEFT);
                avatar.setFitHeight(30);
                avatar.setFitWidth(30);
                avatar.setPreserveRatio(true);
                nameLabel.getStyleClass().add("contact-name");
                lastMsgLabel.getStyleClass().add("last-message");
                contentBox.getChildren().addAll(nameLabel, lastMsgLabel);

                onlineIndicator.getStyleClass().add("offline-indicator");

                final StackPane avatarContainer = new StackPane();
                avatarContainer.getChildren().add(avatar);
                StackPane.setAlignment(onlineIndicator, Pos.BOTTOM_RIGHT);
                avatarContainer.getChildren().add(onlineIndicator);

                hbox.getChildren().addAll(avatarContainer, contentBox);
            }

            @Override
            protected void updateItem(final T item, final boolean empty) {
                super.updateItem(item, empty);

                // Remove previous listener
                if (currentUser != null) {
                    currentUser.onlineProperty().removeListener(onlineListener);
                    currentUser = null;
                }

                if (empty || item == null) {
                    setText(null);
                    setGraphic(null);
                    onlineIndicator.setVisible(false);
                    return;
                }

                nameLabel.setText(nameFn.apply(item));
                final String url = avatarUrlFn.apply(item);
                if (url != null) {
                    final Image img = loadImage(url, 30);
                    if (img != null) {
                        avatar.setImage(img);
                    }
                }
                final Optional<Message> msg = lastMsgFn.apply(item);
                lastMsgLabel.setText(msgTextFn.apply(msg));

                if (item instanceof User) {
                    currentUser = (User) item;
                    currentUser.onlineProperty().addListener(onlineListener);
                    updateOnlineIndicator(currentUser.isOnline());
                } else {
                    onlineIndicator.setVisible(false);
                }

                setGraphic(hbox);
            }

            private void updateOnlineIndicator(final boolean isOnline) {
                Platform.runLater(() -> {
                    onlineIndicator.getStyleClass().removeAll("online-indicator", "offline-indicator");
                    onlineIndicator.getStyleClass().add(isOnline ? "online-indicator" : "offline-indicator");
                    onlineIndicator.setVisible(true);
                });
            }
        };
    }

    private Image loadImage(final String imageUrl, final double size) {

        try (InputStream stream = getClass().getResourceAsStream(imageUrl)) {
            if (stream != null) {
                return new Image(stream, size, size, true, true);
            } else {
                final String fallback = imageUrl.contains("group") ? "/images/default_group.png"
                        : "/images/default_avatar.png";
                try (InputStream fallbackStream = getClass().getResourceAsStream(fallback)) {
                    if (fallbackStream != null) {
                        return new Image(fallbackStream, size, size, true, true);
                    }
                }
            }
        } catch (final IOException e) {
            System.err.println("Erreur lors du chargement de l'image " + imageUrl + ": " + e.getMessage());
        }
        return null;
    }

    private ImageView createCircularAvatar(final String imageUrl, final double size) {
        final ImageView imageView = new ImageView();
        imageView.setFitWidth(size);
        imageView.setFitHeight(size);
        imageView.setPreserveRatio(true);
        final javafx.scene.shape.Circle clip = new javafx.scene.shape.Circle(size / 2, size / 2, size / 2);
        imageView.setClip(clip);

        return imageView;
    }

    private void addMessageToChat(final Message message) {
        try {
            final User sender = userService.getUserById(message.getSenderUserId());
            final User currentUser = userService.getUserByEmail(userEmail);
            final boolean isMine = message.getSenderUserId() == currentUser.getId();
            final boolean isGroup = message.getGroupId() != null;

            final HBox messageContainer = new HBox(10);
            messageContainer.getStyleClass().add("message-container");
            messageContainer.setAlignment(isMine ? Pos.CENTER_RIGHT : Pos.CENTER_LEFT);
            messageContainer.setPadding(new Insets(5));
            messageContainer.setMaxWidth(chatHistoryContainer.getWidth() * 0.8);

            // Avatar
            final ImageView avatar = createCircularAvatar(sender.getAvatarUrl(), 35);
            avatar.getStyleClass().add("message-avatar");
            if (!isMine)
                messageContainer.getChildren().add(avatar);

            // Contenu du message
            final VBox contentBox = new VBox(5);
            contentBox.getStyleClass().add("message-content");
            contentBox.getStyleClass().add(isMine ? "my-message" : "other-message");

            if (isGroup && !isMine) {
                final Label nameLabel = new Label(sender.getDisplayNameOrEmail());
                nameLabel.getStyleClass().add("sender-name");
                contentBox.getChildren().add(nameLabel);
            }

            // For text messages, use the existing logic
            if (message.isTextMessage()) {
                // Créer un conteneur horizontal pour le texte et l'horodatage
                final HBox contentTimeContainer = new HBox();
                contentTimeContainer.getStyleClass().add("content-time-container");

                // Texte du message
                final Label contentLabel = new Label(message.getContent());
                contentLabel.setWrapText(true);
                contentLabel.getStyleClass().add("message-text");
                contentLabel.setMaxWidth(chatHistoryContainer.getWidth() * 0.6); // Pour laisser de la place à
                                                                                 // l'horodatage

                // Horodatage
                final Label timeLabel = new Label(message.getTimestamp().format(TIME_FMT));
                timeLabel.getStyleClass().add("message-time");

                // Assembler le conteneur de message
                contentTimeContainer.getChildren().addAll(contentLabel, timeLabel);
                contentBox.getChildren().add(contentTimeContainer);
            }
            // For media messages, create appropriate media preview
            else {
                // Add media content based on the type
                switch (message.getType()) {
                    case IMAGE:
                        addImageContent(contentBox, message);
                        break;
                    case VIDEO:
                        addVideoContent(contentBox, message);
                        break;
                    case AUDIO:
                        addAudioContent(contentBox, message);
                        break;
                    case DOCUMENT:
                        addDocumentContent(contentBox, message);
                        break;
                    default:
                        // Fallback to text representation
                        final Label fallbackLabel = new Label("Type de média non pris en charge");
                        contentBox.getChildren().add(fallbackLabel);
                }

                // Add timestamp below the media
                final HBox timeContainer = new HBox();
                timeContainer.setAlignment(Pos.CENTER_RIGHT);
                final Label timeLabel = new Label(message.getTimestamp().format(TIME_FMT));
                timeLabel.getStyleClass().add("message-time");
                timeContainer.getChildren().add(timeLabel);
                contentBox.getChildren().add(timeContainer);
            }

            messageContainer.getChildren().add(contentBox);

            if (isMine)
                messageContainer.getChildren().add(avatar);

            Platform.runLater(() -> {
                chatHistoryContainer.getChildren().add(messageContainer);
                scrollToBottom();
            });
        } catch (final IOException e) {
            setStatus("Erreur d'affichage du message : " + e.getMessage());
        }
    }

    private void addImageContent(final VBox contentBox, final Message message) {
        try {
            System.out.println();
            final File imageFile = chatService.getMediaFile(message);
            if (imageFile.exists()) {
                final Image image = new Image(imageFile.toURI().toString());
                final ImageView imageView = new ImageView(image);

                // Limit image size
                final double maxWidth = 250;
                final double maxHeight = 250;

                if (image.getWidth() > maxWidth || image.getHeight() > maxHeight) {
                    final double widthRatio = maxWidth / image.getWidth();
                    final double heightRatio = maxHeight / image.getHeight();
                    final double ratio = Math.min(widthRatio, heightRatio);

                    imageView.setFitWidth(image.getWidth() * ratio);
                    imageView.setFitHeight(image.getHeight() * ratio);
                } else {
                    imageView.setFitWidth(image.getWidth());
                    imageView.setFitHeight(image.getHeight());
                }

                imageView.getStyleClass().add("image-preview");

                // Add click handler to open the image in a new window
                imageView.setOnMouseClicked(e -> openImageViewer(image));

                contentBox.getChildren().add(imageView);

                // Add filename if available
                if (message.getFileName() != null) {
                    final Label filenameLabel = new Label(message.getFileName());
                    filenameLabel.setTextFill(Color.GRAY);
                    filenameLabel.setFont(Font.font("System", FontWeight.NORMAL, 10));
                    contentBox.getChildren().add(filenameLabel);
                }
            } else {
                final Label errorLabel = new Label("Image non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (final Exception e) {
            final Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    private void addVideoContent(final VBox contentBox, final Message message) {
        try {
            final File videoFile = chatService.getMediaFile(message);
            if (videoFile.exists()) {
                final HBox videoContainer = new HBox();
                videoContainer.setAlignment(Pos.CENTER);
                videoContainer.getStyleClass().add("video-preview");

                // Create a thumbnail or play button
                final Button playButton = new Button("▶");
                playButton.getStyleClass().add("audio-play-button");
                playButton.setOnAction(e -> openVideoPlayer(videoFile));

                final Label videoLabel = new Label(message.getFileName() != null ? message.getFileName() : "Vidéo");

                videoContainer.getChildren().addAll(playButton, videoLabel);
                contentBox.getChildren().add(videoContainer);
            } else {
                final Label errorLabel = new Label("Vidéo non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (final Exception e) {
            final Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    private void addAudioContent(final VBox contentBox, final Message message) {
        try {
            final File audioFile = chatService.getMediaFile(message);
            if (audioFile.exists()) {
                final HBox audioPlayer = new HBox(10);
                audioPlayer.setAlignment(Pos.CENTER_LEFT);
                audioPlayer.getStyleClass().add("audio-player");

                final Button playButton = new Button("▶");
                playButton.getStyleClass().add("audio-play-button");

                final ProgressBar progressBar = new ProgressBar(0);
                progressBar.getStyleClass().add("audio-progress");
                progressBar.setPrefWidth(150);

                final Label durationLabel = new Label("00:00");

                // Create the media player
                final Media media = new Media(audioFile.toURI().toString());
                final MediaPlayer mediaPlayer = new MediaPlayer(media);

                // Configure the progress bar and duration label
                mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
                    final double progress = newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds();
                    Platform.runLater(() -> {
                        progressBar.setProgress(progress);
                        durationLabel.setText(formatDuration(newVal));
                    });
                });

                mediaPlayer.setOnEndOfMedia(() -> {
                    mediaPlayer.stop();
                    mediaPlayer.seek(javafx.util.Duration.ZERO);
                    playButton.setText("▶");
                });

                // Configure the play button
                playButton.setOnAction(e -> {
                    if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                        mediaPlayer.pause();
                        playButton.setText("▶");
                    } else {
                        mediaPlayer.play();
                        playButton.setText("⏸");
                    }
                });

                audioPlayer.getChildren().addAll(playButton, progressBar, durationLabel);
                contentBox.getChildren().add(audioPlayer);
            } else {
                final Label errorLabel = new Label("Audio non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (final Exception e) {
            final Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    private void addDocumentContent(final VBox contentBox, final Message message) {
        try {
            final File documentFile = chatService.getMediaFile(message);
            if (documentFile.exists()) {
                final HBox documentContainer = new HBox(10);
                documentContainer.getStyleClass().add("document-preview");

                final Label iconLabel = new Label("📄");
                iconLabel.getStyleClass().add("document-icon");

                final VBox documentInfo = new VBox(5);

                final Label nameLabel = new Label(message.getFileName() != null ? message.getFileName() : "Document");
                nameLabel.getStyleClass().add("document-name");

                final Label sizeLabel = new Label(formatFileSize(message.getFileSize()));
                sizeLabel.getStyleClass().add("document-size");

                documentInfo.getChildren().addAll(nameLabel, sizeLabel);
                documentContainer.getChildren().addAll(iconLabel, documentInfo);

                // Add click handler to open the document
                documentContainer.setOnMouseClicked(e -> openDocument(documentFile));

                contentBox.getChildren().add(documentContainer);
            } else {
                final Label errorLabel = new Label("Document non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (final Exception e) {
            final Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    // Helper method to format file size
    private String formatFileSize(final Long size) {
        if (size == null) {
            return "Taille inconnue";
        }

        if (size < 1024) {
            return size + " octets";
        } else if (size < 1024 * 1024) {
            return String.format("%.1f KB", size / 1024.0);
        } else if (size < 1024 * 1024 * 1024) {
            return String.format("%.1f MB", size / (1024.0 * 1024));
        } else {
            return String.format("%.1f GB", size / (1024.0 * 1024 * 1024));
        }
    }

    // Helper method to format duration
    private String formatDuration(final javafx.util.Duration duration) {
        int seconds = (int) Math.floor(duration.toSeconds());
        final int minutes = seconds / 60;
        seconds = seconds % 60;
        return String.format("%02d:%02d", minutes, seconds);
    }

    // Open image in a larger viewer
    private void openImageViewer(final Image image) {
        final Stage imageStage = new Stage();
        imageStage.initModality(Modality.APPLICATION_MODAL);
        imageStage.setTitle("Visionneuse d'image");

        final ImageView imageView = new ImageView(image);
        imageView.setPreserveRatio(true);

        // Limit size to fit screen
        imageView.setFitWidth(Math.min(image.getWidth(), 800));
        imageView.setFitHeight(Math.min(image.getHeight(), 600));

        final ScrollPane scrollPane = new ScrollPane(imageView);
        scrollPane.setPannable(true);
        scrollPane.setFitToWidth(true);
        scrollPane.setFitToHeight(true);

        final Scene scene = new Scene(scrollPane);
        imageStage.setScene(scene);
        imageStage.show();
    }

    // Open video player
    private void openVideoPlayer(final File videoFile) {
        final Stage videoStage = new Stage();
        videoStage.initModality(Modality.APPLICATION_MODAL);
        videoStage.setTitle("Lecteur vidéo");

        final Media media = new Media(videoFile.toURI().toString());
        final MediaPlayer mediaPlayer = new MediaPlayer(media);
        final MediaView mediaView = new MediaView(mediaPlayer);

        // Set up controls
        final Button playButton = new Button("⏸");
        playButton.setOnAction(e -> {
            if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                mediaPlayer.pause();
                playButton.setText("▶");
            } else {
                mediaPlayer.play();
                playButton.setText("⏸");
            }
        });

        final ProgressBar progressBar = new ProgressBar(0);
        progressBar.setPrefWidth(300);

        mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
            final double progress = newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds();
            Platform.runLater(() -> progressBar.setProgress(progress));
        });

        // Add seek functionality
        progressBar.setOnMouseClicked(e -> {
            final double percent = e.getX() / progressBar.getWidth();
            mediaPlayer.seek(mediaPlayer.getTotalDuration().multiply(percent));
        });

        final HBox controls = new HBox(10, playButton, progressBar);
        controls.setAlignment(Pos.CENTER);
        controls.setPadding(new Insets(10));

        final VBox root = new VBox(10, mediaView, controls);
        root.setAlignment(Pos.CENTER);

        final Scene scene = new Scene(root, 640, 480);
        videoStage.setScene(scene);

        videoStage.setOnCloseRequest(e -> mediaPlayer.stop());

        videoStage.show();
        mediaPlayer.play();
    }

    // Open document with system default application
    private void openDocument(final File documentFile) {
        try {
            java.awt.Desktop.getDesktop().open(documentFile);
        } catch (final Exception e) {
            setStatus("Erreur lors de l'ouverture du document: " + e.getMessage());
        }
    }

    private void scrollToBottom() {
        Platform.runLater(() -> {
            chatScrollPane.setVvalue(1.0);
        });
    }

    private void setStatus(final String status) {
        Platform.runLater(() -> {
            if (status != null && (status.startsWith("Erreur") || status.startsWith("Échec"))) {
                statusLabel.setStyle("-fx-text-fill: red;");
            } else {
                statusLabel.setStyle("");
            }
            statusLabel.setText(status);
        });
    }

    private String truncate(final String text, final int maxLength) {
        return text.length() > maxLength ? text.substring(0, maxLength) + "..." : text;
    }

    private void loadContacts() {
        try {
            final List<User> contactList = contactService.getContactUsers(userEmail);
            Platform.runLater(() -> {
                contacts.clear();
                contacts.addAll(contactList);
            });
        } catch (final IOException e) {
            setStatus("Erreur lors du chargement des contacts : " + e.getMessage());
        }
    }

    private void loadGroups() {
        try {
            final long userId = userService.getUserByEmail(userEmail).getId();
            final List<Group> groupList = groupService.getGroupsForUser(userId);
            Platform.runLater(() -> {
                groups.clear();
                groups.addAll(groupList);
            });
        } catch (final IOException e) {
            setStatus("Erreur lors du chargement des groupes : " + e.getMessage());
        }
    }

    private void loadContactConversation(final User contactUser) {
        Platform.runLater(() -> {
            synchronized (loadLock) {
                chatHistoryContainer.getChildren().clear();
                try {
                    // Effacer l'affichage des membres car on est dans une conversation individuelle
                    groupMembersLabel.setText("");

                    final long myId = userService.getUserByEmail(userEmail).getId();
                    final long contactId = contactUser.getId();
                    final List<Message> contactMessages = localRepo.loadContactMessages(userEmail, myId, contactId);
                    contactMessages.forEach(this::addMessageToChat);
                    scrollToBottom();

                    // Activer le bouton d'appel pour les conversations individuelles
                    callButton.setDisable(false);
                } catch (final IOException e) {
                    setStatus("Erreur lors du chargement de la conversation avec " + contactUser.getDisplayNameOrEmail()
                            + " : "
                            + e.getMessage());
                }
            }
        });
    }

    private void loadGroupConversation(final Group group) {
        Platform.runLater(() -> {
            synchronized (loadLock) {
                chatHistoryContainer.getChildren().clear();
                try {
                    // Afficher les membres du groupe dans l'en-tête
                    displayGroupMembers(group);
                    final List<Message> groupMessages = localRepo.loadGroupMessages(userEmail, group.getId());
                    groupMessages.forEach(this::addMessageToChat);
                    scrollToBottom();
                } catch (final IOException e) {
                    setStatus("Erreur lors du chargement de l'historique de groupe : " + e.getMessage());
                }
            }
        });
    }

    /**
     * Affiche les membres du groupe dans l'en-tête de la conversation
     */
    private void displayGroupMembers(final Group group) {
        if (group == null) {
            groupMembersLabel.setText("");
            return;
        }
        try {
            // Récupérer les IDs des membres du groupe
            final List<Long> memberIds = groupService.getMembersForGroup(group.getId());
            // Construire la liste des noms des membres
            final List<String> memberNames = new ArrayList<>();
            for (final Long memberId : memberIds) {
                try {
                    final User user = userService.getUserById(memberId);
                    final String displayName = user.getDisplayNameOrEmail().split("@")[0];
                    memberNames.add(displayName);
                } catch (final IOException e) {
                    memberNames.add("Inconnu");
                }
            }
            // Joindre les noms avec des virgules
            final String membersText = "Membres : " + String.join(", ", memberNames);
            groupMembersLabel.setText(membersText);
        } catch (final Exception e) {
            groupMembersLabel.setText("Erreur lors du chargement des membres");
            setStatus("Erreur lors du chargement des membres : " + e.getMessage());
        }
    }

    @FXML
    private void handleSendMessage(final ActionEvent event) {
        if (selectedMediaFile != null) {
            System.out.println("Avertissement: L'envoi de média E2EE n'est pas encore implémenté.");
            // sendMediaMessage();
            return;
        }

        final String content = messageField.getText().trim();
        if (content.isEmpty()) {
            return;
        }

        long recipientUserId = -1;
        long recipientGroupId = -1;

        if (selectedContactUser != null) {
            recipientUserId = selectedContactUser.getId();
        } else if (selectedGroup != null) {
            System.out.println("Avertissement: L'envoi de messages E2EE aux groupes n'est pas supporté. Envoi en clair.");
            recipientGroupId = selectedGroup.getId();
            try {
                final User sender = userService.getUserByEmail(userEmail);
                final Message message = Message.newGroupMessage(sender.getId(), recipientGroupId, content);
                chatService.sendMessage(message);
                messageField.clear();
                addMessageToChat(message);
                localRepo.addLocalMessage(userEmail, message);
                groupListView.refresh();
                setStatus("Message de groupe envoyé (non chiffré)");
            } catch (final IOException e) {
                setStatus("Erreur lors de l'envoi du message de groupe : " + e.getMessage());
            }
            return;
        } else {
            setStatus("Veuillez sélectionner un contact ou un groupe.");
            return;
        }

        if (recipientUserId > 0) {
            try {
                final Message localDisplayMessage = Message.newDirectMessage(chatService.getCurrentUserId(), recipientUserId, content);
                addMessageToChat(localDisplayMessage);
                localRepo.addLocalMessage(userEmail, localDisplayMessage);

                chatService.sendEncryptedTextMessage(recipientUserId, content);

                messageField.clear();
                contactListView.refresh();
                setStatus("Message chiffré envoyé");

            } catch (final PublicKeyNotAvailableException e) {
                setStatus("Préparation de la connexion sécurisée... Réessayez d'envoyer.");
                System.err.println("Avertissement UI: " + e.getMessage());
            } catch (final Exception e) {
                setStatus("Erreur d'envoi E2EE : " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    private void handleIncomingMessage(final Message message) {
        Platform.runLater(() -> {
            try {
                localRepo.addLocalMessage(userEmail, message);

                if (message.getGroupId() != null) {
                    final boolean groupExists = groups.stream()
                            .anyMatch(g -> g.getId() == message.getGroupId());
                    if (!groupExists) {
                        loadGroups();
                    } else {
                        groupListView.refresh();
                    }

                    if (selectedGroup != null && selectedGroup.getId() == message.getGroupId()) {
                        addMessageToChat(message);
                    }
                    setStatus("Nouveau message de groupe reçu");
                } else {
                    final User sender = userService.getUserById(message.getSenderUserId());

                    if (sender != null && !contacts.contains(sender)) {
                        contacts.add(sender);
                    }
                    contactListView.refresh();

                    if (selectedContactUser != null &&
                            sender.getId() == selectedContactUser.getId()) {
                        addMessageToChat(message);
                    }

                    if (message.getType() == MessageType.TEXT) {
                        setStatus("Nouveau message reçu de " + (sender != null ? sender.getDisplayNameOrEmail() : "Inconnu"));
                    } else if (message.getType() == MessageType.SYSTEM) {
                        setStatus("Info système: " + message.getContent());
                    } else if (message.isMediaMessage()) {
                        setStatus("Nouveau média reçu de " + (sender != null ? sender.getDisplayNameOrEmail() : "Inconnu"));
                    } else {
                        setStatus("Notification reçue");
                    }
                }

                scrollToBottom();
            } catch (final IOException e) {
                setStatus("Erreur lors du traitement du message reçu : " + e.getMessage());
            }
        });
    }

    @FXML
    private void handleAddContact() {
        final String email = newContactField.getText().trim();

        if (email.isEmpty()) {
            setStatus("Veuillez saisir un email");
            return;
        }

        final boolean contactExists = contacts.stream()
                .anyMatch(user -> user.getEmail().equalsIgnoreCase(email));

        if (contactExists) {
            setStatus("Ce contact existe déjà.");
            newContactField.clear();
            return;
        }

        try {
            final User addedUser = contactService.addContactUser(userEmail, email);
            if (addedUser != null) {
                contacts.add(addedUser);
                newContactField.clear();
                setStatus("Contact ajouté: " + addedUser.getDisplayNameOrEmail());
            }
        } catch (final IllegalArgumentException e) {
            setStatus("Erreur: " + e.getMessage());
        } catch (final IOException e) {
            setStatus("Erreur de connexion: " + e.getMessage());
        }
    }

    @FXML
    private void handleRemoveContact() {
        if (selectedContactUser == null) {
            setStatus("Aucun contact sélectionné pour la suppression");
            return;
        }
        try {
            final boolean removed = contactService.removeContact(userEmail, selectedContactUser.getEmail());
            if (removed) {
                contacts.remove(selectedContactUser);
                chatHistoryContainer.getChildren().clear();
                final long myId = chatService.getCurrentUserId();
                localRepo.removeConversation(userEmail, myId, selectedContactUser.getId());
                setStatus("Contact et conversation supprimés: " + selectedContactUser.getDisplayNameOrEmail());
                selectedContactUser = null;
            } else {
                setStatus("La suppression du contact a échoué");
            }
        } catch (final IOException e) {
            setStatus("Erreur: " + e.getMessage());
        }
    }

    @FXML
    private void handleCreateGroup(final ActionEvent event) {
        final String groupName = groupNameField.getText().trim();
        if (groupName.isEmpty()) {
            setStatus("Le nom du groupe est obligatoire");
            return;
        }
        final long ownerId = chatService.getCurrentUserId();
        final Group createdGroup = groupService.createGroup(groupName, ownerId);
        if (createdGroup.getId() > 0) {
            setStatus("Groupe créé : " + createdGroup.getName());
            groups.add(createdGroup);
            groupNameField.clear();
        } else {
            setStatus("Erreur lors de la création du groupe");
        }
    }

    @FXML
    private void handleAddMemberToGroup(final ActionEvent event) {
        final String memberEmail = memberEmailField.getText().trim();
        if (memberEmail.isEmpty()) {
            setStatus("Veuillez entrer l'email du membre à ajouter");
            return;
        }
        final Group selectedGroup = groupListView.getSelectionModel().getSelectedItem();
        if (selectedGroup == null) {
            setStatus("Veuillez sélectionner un groupe");
            return;
        }
        try {
            final long memberId = userService.getUserByEmail(memberEmail).getId();
            final boolean success = groupService.addMemberToGroup(selectedGroup.getId(), memberId);
            if (success) {
                setStatus("Membre ajouté avec succès");
                memberEmailField.clear();
            } else {
                setStatus("Le membre est déjà présent ou l'ajout a échoué");
            }
        } catch (final IOException e) {
            setStatus("Erreur lors de l'ajout du membre : " + e.getMessage());
        }
    }

    @FXML
    private void handleRemoveMemberFromGroup(final ActionEvent event) {
        final Group selectedGroup = groupListView.getSelectionModel().getSelectedItem();
        if (selectedGroup == null) {
            setStatus("Veuillez sélectionner un groupe");
            return;
        }

        final String memberEmail = memberEmailField.getText().trim();
        if (memberEmail.isEmpty()) {
            setStatus("Veuillez entrer l'email du membre à supprimer");
            return;
        }

        try {
            final User memberUser = userService.getUserByEmail(memberEmail);
            if (memberUser == null) {
                setStatus("Utilisateur non trouvé: " + memberEmail);
                return;
            }

            if (memberUser.getId() == selectedGroup.getOwnerUserId()) {
                setStatus("Impossible de supprimer le propriétaire du groupe");
                return;
            }

            final boolean removed = groupService.removeMemberFromGroup(selectedGroup.getId(), memberUser.getId());
            if (removed) {
                setStatus("Membre supprimé avec succès");
                memberEmailField.clear();

                if (selectedGroup.equals(this.selectedGroup)) {
                    displayGroupMembers(selectedGroup);
                }
            } else {
                setStatus("La suppression du membre a échoué ou l'utilisateur n'était pas membre du groupe");
            }
        } catch (final IOException e) {
            setStatus("Erreur lors de la suppression du membre: " + e.getMessage());
        }
    }

    @FXML
    private void handleLogout() {
        try {
            chatService.disconnect();
            chatHistoryContainer.getChildren().clear();

            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            final Parent loginView = loader.load();

            final Stage stage = (Stage) userEmailLabel.getScene().getWindow();
            stage.setTitle("Chat Application");
            stage.setScene(new Scene(loginView, 600, 400));
            stage.centerOnScreen();
        } catch (final IOException e) {
            setStatus("Erreur lors de la déconnexion: " + e.getMessage());
        }
    }

    private void openMediaFileChooser(final String description, final String... extensions) {
        final FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Sélectionner un fichier");
        fileChooser.getExtensionFilters().add(
                new FileChooser.ExtensionFilter(description, extensions));

        final File selectedFile = fileChooser.showOpenDialog(mediaButton.getScene().getWindow());
        if (selectedFile != null) {
            selectedMediaFile = selectedFile;
            selectedMediaType = fileService.detectMessageType(selectedFile.getName());

            attachmentNameLabel.setText(selectedFile.getName());
            attachmentPreviewContainer.setManaged(true);
            attachmentPreviewContainer.setVisible(true);

            messageField.clear();
            messageField.setPromptText("Appuyez sur Envoyer pour envoyer le fichier");
        }
    }

    @FXML
    private void handleRemoveAttachment() {
        clearMediaSelection();
    }

    private void clearMediaSelection() {
        selectedMediaFile = null;
        selectedMediaType = null;
        attachmentPreviewContainer.setManaged(false);
        attachmentPreviewContainer.setVisible(false);
        messageField.setPromptText("Écrire un message...");
    }

    @FXML
    private void handleAudioRecordButtonClick() {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    }

    private void startRecording() {
        try {
            audioRecorderService.startRecording();
            isRecording = true;

            audioRecordButton.setText("■");
            audioRecordButton.getStyleClass().add("recording");
            recordingIndicatorContainer.setManaged(true);
            recordingIndicatorContainer.setVisible(true);

            messageField.setDisable(true);
            mediaButton.setDisable(true);

            recordingSeconds = 0;
            recordingTimeLabel.setText("00:00");
            recordingTimer = new Timer();
            recordingTimer.scheduleAtFixedRate(new TimerTask() {
                @Override
                public void run() {
                    recordingSeconds++;
                    Platform.runLater(() -> {
                        final int minutes = recordingSeconds / 60;
                        final int seconds = recordingSeconds % 60;
                        recordingTimeLabel.setText(String.format("%02d:%02d", minutes, seconds));
                    });
                }
            }, 1000, 1000);

            setStatus("Enregistrement audio démarré");
        } catch (final LineUnavailableException e) {
            setStatus("Erreur lors du démarrage de l'enregistrement: " + e.getMessage());
        }
    }

    private void stopRecording() {
        try {
            if (recordingTimer != null) {
                recordingTimer.cancel();
                recordingTimer = null;
            }

            final File audioFile = audioRecorderService.stopRecording();
            isRecording = false;

            audioRecordButton.setText("🎤");
            audioRecordButton.getStyleClass().remove("recording");
            recordingIndicatorContainer.setManaged(false);
            recordingIndicatorContainer.setVisible(false);

            messageField.setDisable(false);
            mediaButton.setDisable(false);

            if (audioFile != null && audioFile.exists()) {
                selectedMediaFile = audioFile;
                selectedMediaType = MessageType.AUDIO;

                attachmentNameLabel.setText("Enregistrement audio (" + formatDuration(recordingSeconds) + ")");
                attachmentPreviewContainer.setManaged(true);
                attachmentPreviewContainer.setVisible(true);

                setStatus("Enregistrement audio terminé");
            } else {
                setStatus("L'enregistrement audio a échoué");
            }
        } catch (final IOException e) {
            setStatus("Erreur lors de l'arrêt de l'enregistrement: " + e.getMessage());
        }
    }

    private String formatDuration(int seconds) {
        final int minutes = seconds / 60;
        seconds = seconds % 60;
        return String.format("%02d:%02d", minutes, seconds);
    }

    @FXML
    private void handleOpenMediaGallery(final ActionEvent event) {
        try {
            if (selectedContactUser == null && selectedGroup == null) {
                setStatus("Veuillez sélectionner un contact ou un groupe pour voir la galerie média");
                return;
            }

            List<Message> mediaMessages;
            String conversationName;
            boolean isGroup;

            if (selectedContactUser != null) {
                final long myId = userService.getUserByEmail(userEmail).getId();
                final long contactId = selectedContactUser.getId();
                mediaMessages = localRepo.loadContactMessages(userEmail, myId, contactId)
                        .stream()
                        .filter(Message::isMediaMessage)
                        .collect(Collectors.toList());
                conversationName = selectedContactUser.getDisplayNameOrEmail();
                isGroup = false;
            } else {
                mediaMessages = localRepo.loadGroupMessages(userEmail, selectedGroup.getId())
                        .stream()
                        .filter(Message::isMediaMessage)
                        .collect(Collectors.toList());
                conversationName = selectedGroup.getName();
                isGroup = true;
            }

            if (mediaMessages.isEmpty()) {
                setStatus("Aucun média trouvé dans cette conversation");
                return;
            }

            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/media_gallery.fxml"));
            final Parent root = loader.load();

            final MediaGalleryController galleryController = loader.getController();
            galleryController.setData(chatService, userService, mediaMessages, conversationName, isGroup);

            final Stage galleryStage = new Stage();
            galleryStage.setTitle("Galerie média - " + conversationName);
            galleryStage.initModality(Modality.WINDOW_MODAL);
            galleryStage.initOwner(mediaGalleryButton.getScene().getWindow());
            galleryStage.setScene(new Scene(root));
            galleryStage.show();

        } catch (final IOException e) {
            setStatus("Erreur lors de l'ouverture de la galerie média: " + e.getMessage());
        }
    }

    @FXML
    private void handleMediaButtonClick(final ActionEvent event) {
        try {
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/media_dialog.fxml"));
            final Parent root = loader.load();

            final MediaDialogController dialogController = loader.getController();
            dialogController.setSendHandler((file, type) -> {
                selectedMediaFile = file;
                selectedMediaType = type;

                attachmentNameLabel.setText(file.getName());
                attachmentPreviewContainer.setManaged(true);
                attachmentPreviewContainer.setVisible(true);

                messageField.clear();
                messageField.setPromptText("Appuyez sur Envoyer pour envoyer le fichier");
                // this.sendMediaMessage();
            });

            final Stage dialogStage = new Stage();
            dialogStage.setTitle("Envoyer un média");
            dialogStage.initModality(Modality.WINDOW_MODAL);
            dialogStage.initOwner(mediaButton.getScene().getWindow());
            dialogStage.setScene(new Scene(root));
            dialogStage.showAndWait();

        } catch (final IOException e) {
            setStatus("Erreur lors de l'ouverture du dialogue média: " + e.getMessage());
        }
    }

    private void startContactStatusUpdater() {
        final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.scheduleAtFixedRate(() -> {
            try {
                for (final User user : contacts) {
                    final boolean isOnline = contactService.isUserOnline(user.getId());
                    Platform.runLater(() -> user.setOnline(isOnline));
                }
            } catch (final IOException e) {
                Platform.runLater(() -> setStatus("Erreur mise à jour des statuts: " + e.getMessage()));
            }
        }, 0, 5, TimeUnit.SECONDS);

        Platform.runLater(() -> {
            final Stage stage = (Stage) userEmailLabel.getScene().getWindow();
            stage.setOnCloseRequest(event -> scheduler.shutdown());
        });
    }
}



// File: src/main/java/org/example/client/gui/controllers/LoginController.java
package org.example.client.gui.controllers;

import java.io.IOException;

import org.example.client.gui.security.KeyManager;
import org.example.client.gui.service.ChatService;
import org.example.shared.dto.Credentials;

import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.stage.Stage;

public class LoginController {

    @FXML
    private TextField emailField;

    @FXML
    private PasswordField passwordField;

    @FXML
    private Button loginButton;

    private KeyManager keyManager;

    private ChatService chatService;

    @FXML
    public void initialize() {
        // --- AJOUT POUR E2EE ---
        // Initialiser KeyManager en passant l'email saisi dans emailField (même s'il est initialement vide)
        this.keyManager = new KeyManager(emailField.getText().trim());

        // --- FIN AJOUT ---

        // Instancier ChatService EN PASSANT KeyManager
        this.chatService = new ChatService(this.keyManager);
        // Activer le bouton de connexion seulement si des valeurs sont entrées
        loginButton.disableProperty().bind(
                emailField.textProperty().isEmpty().or(
                        passwordField.textProperty().isEmpty()));
    }

    // this function takes in the login event from the view extracts credentials and
    // calls connect from chat service
    @FXML
    private void handleLogin(final ActionEvent event) {
        // here we get credentials
        final String email = emailField.getText().trim();
        final String password = passwordField.getText();

        // Débinder la propriété disable avant de la modifier
        loginButton.disableProperty().unbind();
        loginButton.setDisable(true); // Désactiver le bouton

        new Thread(() -> {
            try {
                final Credentials credentials = new Credentials(email, password);
                // here we call connect() in chat service
                // connect does the following :
                // - establishes connection with server socket (a client socket is created in
                // server side for further communication)
                // - it send credentials using the output stream and waits for response the
                // server creates a client handler and checks authenticates client
                // - if authenticated we run code in a thread (to load messages sent to the
                // client offline using loadMessages() ), and we return "true".
                final boolean success = chatService.connect(credentials);

                Platform.runLater(() -> {
                    if (success) {
                        try {
                            // if authentication is successful we open the chat view
                            openChatWindow(email);
                        } catch (final IOException e) {
                            showError("Erreur d'interface",
                                    "Impossible d'ouvrir la fenêtre de chat: " + e.getMessage());
                            rebindLoginButton();
                        }
                    } else {
                        showError("Échec de connexion", "Email ou mot de passe incorrect");
                        rebindLoginButton();
                    }
                });
            } catch (final IOException e) {
                Platform.runLater(() -> {
                    showError("Erreur de connexion", "Impossible de se connecter au serveur: " + e.getMessage());
                    rebindLoginButton();
                });
            }
        }).start();
    }

    /**
     * Rétablit le binding du bouton de login
     */
    private void rebindLoginButton() {
        loginButton.disableProperty().unbind(); // S'assurer qu'il n'y a pas de binding actif
        loginButton.setDisable(false); // Réactiver le bouton
        // Rebinder le bouton avec la condition initiale
        loginButton.disableProperty().bind(
                emailField.textProperty().isEmpty().or(
                        passwordField.textProperty().isEmpty()));
    }

    /**
     * Gère le clic sur le lien "Créer un compte" pour naviguer vers la page
     * d'inscription
     */
    @FXML
    private void handleRegisterLink(final ActionEvent event) {
        try {
            // Charger la vue d'inscription
            final FXMLLoader loader = new FXMLLoader(LoginController.class.getResource("/fxml/register.fxml"));
            final Parent registerView = loader.load();

            // Créer et afficher la nouvelle scène
            final Scene registerScene = new Scene(registerView, 600, 500);
            final Stage currentStage = (Stage) loginButton.getScene().getWindow();

            currentStage.setTitle("Inscription");
            currentStage.setScene(registerScene);
            currentStage.centerOnScreen();
        } catch (final IOException e) {
            showError("Erreur d'interface", "Impossible d'ouvrir la fenêtre d'inscription: " + e.getMessage());
        }
    }

    // this function loads chat.fxml and configures it with a controller
    // chatController
    private void openChatWindow(final String userEmail) throws IOException {
        // Charger la vue de chat
        final FXMLLoader loader = new FXMLLoader(LoginController.class.getResource("/fxml/chat.fxml"));
        final Parent chatView = loader.load();

        // Configurer le contrôleur de chat
        final ChatController chatController = loader.getController();
        chatController.initData(chatService, userEmail, keyManager);

        // Créer et afficher la nouvelle scène
        final Scene chatScene = new Scene(chatView, 800, 600);
        final Stage currentStage = (Stage) loginButton.getScene().getWindow();

        currentStage.setTitle("Chat - " + userEmail);
        currentStage.setScene(chatScene);
        currentStage.setMinWidth(800);
        currentStage.setMinHeight(600);
        currentStage.centerOnScreen();
    }

    private void showError(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}



// File: src/main/java/org/example/client/gui/controllers/MediaDialogController.java
package org.example.client.gui.controllers;

import java.io.File;
import java.io.IOException;
import java.util.Timer;
import java.util.TimerTask;

import org.example.client.gui.service.AudioRecorderService;
import org.example.shared.model.enums.MessageType;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import javafx.scene.media.MediaView;
import javafx.stage.FileChooser;
import javafx.stage.Stage;

import javax.sound.sampled.LineUnavailableException;

public class MediaDialogController {

    @FXML
    private ComboBox<String> mediaTypeComboBox;

    @FXML
    private TextField filePathField;

    @FXML
    private VBox previewContainer;

    @FXML
    private HBox recordAudioContainer;

    @FXML
    private Button recordButton;

    @FXML
    private Label recordingTimeLabel;

    @FXML
    private ProgressBar audioLevelIndicator;

    @FXML
    private Button sendButton;

    private File selectedFile;
    private MessageType selectedType;
    private boolean isRecording = false;
    private Timer recordingTimer;
    private int recordingSeconds = 0;

    private final AudioRecorderService audioRecorderService = new AudioRecorderService();

    // Interface for handling send action
    public interface MediaSendHandler {
        void onMediaSelected(File file, MessageType type);
    }

    private MediaSendHandler sendHandler;

    @FXML
    public void initialize() {
        // Initialize media type combo box
        mediaTypeComboBox.setItems(FXCollections.observableArrayList(
                "Image", "Vidéo", "Document", "Audio"
        ));

        // Add listener to the combo box
        mediaTypeComboBox.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                switch (newVal) {
                    case "Image":
                        selectedType = MessageType.IMAGE;
                        recordAudioContainer.setVisible(false);
                        recordAudioContainer.setManaged(false);
                        break;
                    case "Vidéo":
                        selectedType = MessageType.VIDEO;
                        recordAudioContainer.setVisible(false);
                        recordAudioContainer.setManaged(false);
                        break;
                    case "Document":
                        selectedType = MessageType.DOCUMENT;
                        recordAudioContainer.setVisible(false);
                        recordAudioContainer.setManaged(false);
                        break;
                    case "Audio":
                        selectedType = MessageType.AUDIO;
                        recordAudioContainer.setVisible(true);
                        recordAudioContainer.setManaged(true);
                        break;
                }

                // Clear the file selection when changing type
                selectedFile = null;
                filePathField.clear();
                updatePreview();
            }
        });

        // Set default selected type
        mediaTypeComboBox.getSelectionModel().select(0);

        // Disable send button initially
        sendButton.setDisable(true);
    }

    /**
     * Sets the handler for send actions.
     *
     * @param handler The handler
     */
    public void setSendHandler(MediaSendHandler handler) {
        this.sendHandler = handler;
    }

    @FXML
    private void handleBrowseFile(ActionEvent event) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Sélectionner un fichier");

        // Set extension filters based on selected type
        switch (selectedType) {
            case IMAGE:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Images", "*.png", "*.jpg", "*.jpeg", "*.gif", "*.bmp"));
                break;
            case VIDEO:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Vidéos", "*.mp4", "*.avi", "*.mov", "*.wmv", "*.flv", "*.mkv"));
                break;
            case AUDIO:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Fichiers audio", "*.mp3", "*.wav", "*.ogg", "*.aac", "*.wma", "*.flac"));
                break;
            case DOCUMENT:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Tous les fichiers", "*.*"));
                break;
        }

        // Show file chooser dialog
        File file = fileChooser.showOpenDialog(filePathField.getScene().getWindow());
        if (file != null) {
            selectedFile = file;
            filePathField.setText(file.getAbsolutePath());
            sendButton.setDisable(false);
            updatePreview();
        }
    }

    @FXML
    private void handleRecordAudio(ActionEvent event) {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    }

    private void startRecording() {
        try {
            // Start recording
            audioRecorderService.startRecording();
            isRecording = true;

            // Update UI
            recordButton.setText("■ Arrêter");
            recordingTimeLabel.setText("00:00");

            // Start timer
            recordingSeconds = 0;
            recordingTimer = new Timer();
            recordingTimer.scheduleAtFixedRate(new TimerTask() {
                @Override
                public void run() {
                    recordingSeconds++;
                    Platform.runLater(() -> {
                        int minutes = recordingSeconds / 60;
                        int seconds = recordingSeconds % 60;
                        recordingTimeLabel.setText(String.format("%02d:%02d", minutes, seconds));
                    });
                }
            }, 1000, 1000);

        } catch (LineUnavailableException e) {
            System.err.println("Error starting recording: " + e.getMessage());
        }
    }

    private void stopRecording() {
        try {
            // Stop the timer
            if (recordingTimer != null) {
                recordingTimer.cancel();
                recordingTimer = null;
            }

            // Stop recording and get the recorded file
            File audioFile = audioRecorderService.stopRecording();
            isRecording = false;

            // Update UI
            recordButton.setText("🎤 Enregistrer");

            // If we have a valid audio file, set it as the selected file
            if (audioFile != null && audioFile.exists()) {
                selectedFile = audioFile;
                filePathField.setText("Enregistrement audio (" + formatDuration(recordingSeconds) + ")");
                sendButton.setDisable(false);
                updatePreview();
            }
        } catch (IOException e) {
            System.err.println("Error stopping recording: " + e.getMessage());
        }
    }

    private String formatDuration(int seconds) {
        int minutes = seconds / 60;
        seconds = seconds % 60;
        return String.format("%02d:%02d", minutes, seconds);
    }

    private void updatePreview() {
        previewContainer.getChildren().clear();

        if (selectedFile == null) {
            return;
        }

        switch (selectedType) {
            case IMAGE:
                try {
                    Image image = new Image(selectedFile.toURI().toString());
                    ImageView imageView = new ImageView(image);

                    // Limit preview size
                    imageView.setFitWidth(300);
                    imageView.setFitHeight(200);
                    imageView.setPreserveRatio(true);

                    previewContainer.getChildren().add(imageView);
                } catch (Exception e) {
                    previewContainer.getChildren().add(new Label("Erreur de chargement de l'image"));
                }
                break;

            case VIDEO:
                try {
                    Media media = new Media(selectedFile.toURI().toString());
                    MediaPlayer mediaPlayer = new MediaPlayer(media);
                    MediaView mediaView = new MediaView(mediaPlayer);

                    // Limit preview size
                    mediaView.setFitWidth(300);
                    mediaView.setFitHeight(200);
                    mediaView.setPreserveRatio(true);

                    // Add play/pause button
                    Button playButton = new Button("▶ Play");
                    playButton.setOnAction(e -> {
                        if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                            mediaPlayer.pause();
                            playButton.setText("▶ Play");
                        } else {
                            mediaPlayer.play();
                            playButton.setText("⏸ Pause");
                        }
                    });

                    VBox videoBox = new VBox(10, mediaView, playButton);
                    previewContainer.getChildren().add(videoBox);
                } catch (Exception e) {
                    previewContainer.getChildren().add(new Label("Erreur de chargement de la vidéo"));
                }
                break;

            case AUDIO:
                try {
                    HBox audioPlayer = new HBox(10);
                    audioPlayer.setAlignment(javafx.geometry.Pos.CENTER_LEFT);

                    Button playButton = new Button("▶");

                    if (selectedFile.exists() && selectedFile.getName().toLowerCase().endsWith(".wav")) {
                        Media media = new Media(selectedFile.toURI().toString());
                        MediaPlayer mediaPlayer = new MediaPlayer(media);

                        playButton.setOnAction(e -> {
                            if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                                mediaPlayer.pause();
                                playButton.setText("▶");
                            } else {
                                mediaPlayer.play();
                                playButton.setText("⏸");
                            }
                        });
                    } else {
                        // For non-playable files, just show a placeholder
                        playButton.setDisable(true);
                    }

                    Label audioLabel = new Label(selectedFile.getName());

                    audioPlayer.getChildren().addAll(playButton, audioLabel);
                    previewContainer.getChildren().add(audioPlayer);
                } catch (Exception e) {
                    previewContainer.getChildren().add(new Label("Erreur de chargement de l'audio"));
                }
                break;

            case DOCUMENT:
                Label docIcon = new Label("📄");
                docIcon.setStyle("-fx-font-size: 32px;");

                Label docName = new Label(selectedFile.getName());

                Label docSize = new Label(formatFileSize(selectedFile.length()));
                docSize.setStyle("-fx-text-fill: #888;");

                VBox docBox = new VBox(5, docIcon, docName, docSize);
                docBox.setAlignment(javafx.geometry.Pos.CENTER);

                previewContainer.getChildren().add(docBox);
                break;
        }
    }

    private String formatFileSize(long size) {
        if (size < 1024) {
            return size + " octets";
        } else if (size < 1024 * 1024) {
            return String.format("%.1f KB", size / 1024.0);
        } else if (size < 1024 * 1024 * 1024) {
            return String.format("%.1f MB", size / (1024.0 * 1024));
        } else {
            return String.format("%.1f GB", size / (1024.0 * 1024 * 1024));
        }
    }

    @FXML
    private void handleSend(ActionEvent event) {
        if (selectedFile != null && sendHandler != null) {
            sendHandler.onMediaSelected(selectedFile, selectedType);
        }
        closeDialog(); // Ensures the dialog is closed regardless
    }

    @FXML
    private void handleCancel(ActionEvent event) {
        // Stop recording if in progress
        if (isRecording) {
            try {
                audioRecorderService.stopRecording();
                if (recordingTimer != null) {
                    recordingTimer.cancel();
                }
            } catch (IOException e) {
                // Ignore
            }
        }

        closeDialog();
    }

    private void closeDialog() {
        Stage stage = (Stage) sendButton.getScene().getWindow();
        stage.close();
    }
}


// File: src/main/java/org/example/client/gui/controllers/MediaGalleryController.java
package org.example.client.gui.controllers;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.example.client.gui.service.ChatService;
import org.example.client.gui.service.UserService;
import org.example.shared.model.Message;
import org.example.shared.model.User;
import org.example.shared.model.enums.MessageType;

import javafx.collections.FXCollections;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.geometry.Pos;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class MediaGalleryController {

    @FXML
    private Label titleLabel;

    @FXML
    private ComboBox<String> mediaTypeFilter;

    @FXML
    private FlowPane mediaContainer;

    @FXML
    private Label statsLabel;

    private ChatService chatService;
    private UserService userService;
    private List<Message> mediaMessages;
    private String conversationName;
    private boolean isGroup;

    /**
     * Initializes the controller.
     */
    @FXML
    public void initialize() {
        // Initialize media type filter
        mediaTypeFilter.setItems(FXCollections.observableArrayList(
                "Tous", "Images", "Vidéos", "Documents", "Audio"
        ));

        // Add listener to filter media by type
        mediaTypeFilter.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                filterMediaByType(newVal);
            }
        });

        // Set default selection
        mediaTypeFilter.getSelectionModel().select(0);
    }

    /**
     * Sets the data for the gallery.
     *
     * @param chatService The chat service
     * @param userService The user service
     * @param mediaMessages The list of media messages
     * @param conversationName The name of the conversation
     * @param isGroup Whether the conversation is a group
     */
    public void setData(ChatService chatService, UserService userService, List<Message> mediaMessages,
                        String conversationName, boolean isGroup) {
        this.chatService = chatService;
        this.userService = userService;
        this.mediaMessages = new ArrayList<>(mediaMessages);
        this.conversationName = conversationName;
        this.isGroup = isGroup;

        // Update title
        titleLabel.setText("Galerie média - " + conversationName);

        // Load all media initially
        filterMediaByType("Tous");
    }

    /**
     * Filters the media by type.
     *
     * @param filterType The filter type
     */
    private void filterMediaByType(String filterType) {
        List<Message> filteredMessages;

        switch (filterType) {
            case "Images":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isImageMessage)
                        .collect(Collectors.toList());
                break;
            case "Vidéos":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isVideoMessage)
                        .collect(Collectors.toList());
                break;
            case "Documents":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isDocumentMessage)
                        .collect(Collectors.toList());
                break;
            case "Audio":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isAudioMessage)
                        .collect(Collectors.toList());
                break;
            default:
                filteredMessages = mediaMessages;
                break;
        }

        displayMedia(filteredMessages);
        updateStats(filteredMessages.size());
    }

    /**
     * Displays the media in the gallery.
     *
     * @param messages The messages to display
     */
    private void displayMedia(List<Message> messages) {
        mediaContainer.getChildren().clear();

        for (Message message : messages) {
            try {
                // Get the file
                File mediaFile = chatService.getMediaFile(message);

                // Create the media item based on type
                VBox mediaItem = createMediaItem(message, mediaFile);

                mediaContainer.getChildren().add(mediaItem);
            } catch (Exception e) {
                System.err.println("Error displaying media: " + e.getMessage());
            }
        }
    }

    /**
     * Creates a media item for the gallery.
     *
     * @param message The message
     * @param mediaFile The media file
     * @return The media item
     */
    private VBox createMediaItem(Message message, File mediaFile) throws IOException {
        VBox item = new VBox(5);
        item.setAlignment(Pos.CENTER);
        item.setStyle("-fx-background-color: #f5f5f5; -fx-padding: 10px; -fx-border-radius: 5px; " +
                "-fx-background-radius: 5px; -fx-border-color: #ddd;");
        item.setPrefWidth(150);
        item.setPrefHeight(180);

        // Create the preview based on media type
        switch (message.getType()) {
            case IMAGE:
                createImagePreview(item, mediaFile);
                break;
            case VIDEO:
                createVideoPreview(item);
                break;
            case AUDIO:
                createAudioPreview(item);
                break;
            case DOCUMENT:
                createDocumentPreview(item, message);
                break;
            default:
                item.getChildren().add(new Label("Type non pris en charge"));
                break;
        }

        // Add sender name
        try {
            User sender = userService.getUserById(message.getSenderUserId());
            Label senderLabel = new Label(sender.getDisplayNameOrEmail());
            senderLabel.setStyle("-fx-font-size: 10px; -fx-text-fill: #888;");
            item.getChildren().add(senderLabel);
        } catch (IOException e) {
            // Ignore
        }

        // Make the item clickable to open the media
        item.setOnMouseClicked(e -> openMedia(message, mediaFile));

        return item;
    }

    private void createImagePreview(VBox item, File mediaFile) {
        try {
            Image image = new Image(mediaFile.toURI().toString(), 130, 130, true, true);
            ImageView imageView = new ImageView(image);
            imageView.setFitWidth(130);
            imageView.setFitHeight(130);
            imageView.setPreserveRatio(true);

            item.getChildren().add(imageView);
        } catch (Exception e) {
            Label errorLabel = new Label("Erreur image");
            item.getChildren().add(errorLabel);
        }
    }

    private void createVideoPreview(VBox item) {
        Label videoIcon = new Label("🎬");
        videoIcon.setStyle("-fx-font-size: 48px;");

        Label videoLabel = new Label("Vidéo");

        item.getChildren().addAll(videoIcon, videoLabel);
    }

    private void createAudioPreview(VBox item) {
        Label audioIcon = new Label("🔊");
        audioIcon.setStyle("-fx-font-size: 48px;");

        Label audioLabel = new Label("Audio");

        item.getChildren().addAll(audioIcon, audioLabel);
    }

    private void createDocumentPreview(VBox item, Message message) {
        Label docIcon = new Label("📄");
        docIcon.setStyle("-fx-font-size: 48px;");

        Label docName = new Label(message.getFileName() != null ?
                truncateText(message.getFileName(), 15) : "Document");

        item.getChildren().addAll(docIcon, docName);
    }

    /**
     * Opens the media in an appropriate viewer.
     *
     * @param message The message
     * @param mediaFile The media file
     */
    private void openMedia(Message message, File mediaFile) {
        if (!mediaFile.exists()) {
            return;
        }

        switch (message.getType()) {
            case IMAGE:
                openImageViewer(mediaFile);
                break;
            case VIDEO:
                openVideoPlayer(mediaFile);
                break;
            case AUDIO:
                openAudioPlayer(mediaFile);
                break;
            case DOCUMENT:
                openDocument(mediaFile);
                break;
        }
    }

    private void openImageViewer(File imageFile) {
        try {
            // Create a new stage with an image viewer
            Stage imageStage = new Stage();
            imageStage.setTitle("Visionneuse d'image");

            Image image = new Image(imageFile.toURI().toString());
            ImageView imageView = new ImageView(image);
            imageView.setPreserveRatio(true);

            // Limit size to fit screen
            imageView.setFitWidth(Math.min(image.getWidth(), 800));
            imageView.setFitHeight(Math.min(image.getHeight(), 600));

            javafx.scene.control.ScrollPane scrollPane = new javafx.scene.control.ScrollPane(imageView);
            scrollPane.setPannable(true);
            scrollPane.setFitToWidth(true);
            scrollPane.setFitToHeight(true);

            javafx.scene.Scene scene = new javafx.scene.Scene(scrollPane);
            imageStage.setScene(scene);
            imageStage.show();
        } catch (Exception e) {
            System.err.println("Error opening image: " + e.getMessage());
        }
    }

    private void openVideoPlayer(File videoFile) {
        try {
            // Create a new stage with a video player
            Stage videoStage = new Stage();
            videoStage.setTitle("Lecteur vidéo");

            javafx.scene.media.Media media = new javafx.scene.media.Media(videoFile.toURI().toString());
            javafx.scene.media.MediaPlayer mediaPlayer = new javafx.scene.media.MediaPlayer(media);
            javafx.scene.media.MediaView mediaView = new javafx.scene.media.MediaView(mediaPlayer);

            // Set up controls
            javafx.scene.control.Button playButton = new javafx.scene.control.Button("▶ Play");
            playButton.setOnAction(e -> {
                if (mediaPlayer.getStatus() == javafx.scene.media.MediaPlayer.Status.PLAYING) {
                    mediaPlayer.pause();
                    playButton.setText("▶ Play");
                } else {
                    mediaPlayer.play();
                    playButton.setText("⏸ Pause");
                }
            });

            javafx.scene.control.ProgressBar progressBar = new javafx.scene.control.ProgressBar(0);
            progressBar.setPrefWidth(300);

            mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
                double progress = newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds();
                javafx.application.Platform.runLater(() -> progressBar.setProgress(progress));
            });

            // Add seek functionality
            progressBar.setOnMouseClicked(e -> {
                double percent = e.getX() / progressBar.getWidth();
                mediaPlayer.seek(mediaPlayer.getTotalDuration().multiply(percent));
            });

            HBox controls = new HBox(10, playButton, progressBar);
            controls.setAlignment(Pos.CENTER);
            controls.setPadding(new javafx.geometry.Insets(10));

            VBox root = new VBox(10, mediaView, controls);
            root.setAlignment(Pos.CENTER);

            javafx.scene.Scene scene = new javafx.scene.Scene(root, 640, 480);
            videoStage.setScene(scene);

            videoStage.setOnCloseRequest(e -> mediaPlayer.stop());

            videoStage.show();
            mediaPlayer.play();
        } catch (Exception e) {
            System.err.println("Error opening video: " + e.getMessage());
        }
    }

    private void openAudioPlayer(File audioFile) {
        try {
            // Create a new stage with an audio player
            Stage audioStage = new Stage();
            audioStage.setTitle("Lecteur audio");

            javafx.scene.media.Media media = new javafx.scene.media.Media(audioFile.toURI().toString());
            javafx.scene.media.MediaPlayer mediaPlayer = new javafx.scene.media.MediaPlayer(media);

            // Create controls
            javafx.scene.control.Button playButton = new javafx.scene.control.Button("▶ Play");
            javafx.scene.control.Slider timeSlider = new javafx.scene.control.Slider();
            javafx.scene.control.Label timeLabel = new javafx.scene.control.Label("00:00 / 00:00");

            // Configure play button
            playButton.setOnAction(e -> {
                if (mediaPlayer.getStatus() == javafx.scene.media.MediaPlayer.Status.PLAYING) {
                    mediaPlayer.pause();
                    playButton.setText("▶ Play");
                } else {
                    mediaPlayer.play();
                    playButton.setText("⏸ Pause");
                }
            });

            // Configure time slider
            timeSlider.setMin(0);
            timeSlider.setMax(1);
            timeSlider.setValue(0);
            timeSlider.setPrefWidth(300);

            timeSlider.valueProperty().addListener((obs, oldVal, newVal) -> {
                if (timeSlider.isValueChanging()) {
                    mediaPlayer.seek(mediaPlayer.getTotalDuration().multiply(newVal.doubleValue()));
                }
            });

            // Update time label and slider
            mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
                if (!timeSlider.isValueChanging()) {
                    timeSlider.setValue(newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds());

                    int currentMinutes = (int) newVal.toMinutes();
                    int currentSeconds = (int) newVal.toSeconds() % 60;

                    int totalMinutes = (int) mediaPlayer.getTotalDuration().toMinutes();
                    int totalSeconds = (int) mediaPlayer.getTotalDuration().toSeconds() % 60;

                    timeLabel.setText(String.format("%02d:%02d / %02d:%02d",
                            currentMinutes, currentSeconds, totalMinutes, totalSeconds));
                }
            });

            // Layout
            HBox controls = new HBox(10, playButton, timeSlider, timeLabel);
            controls.setAlignment(Pos.CENTER);
            controls.setPadding(new javafx.geometry.Insets(20));

            audioStage.setScene(new javafx.scene.Scene(controls, 500, 100));
            audioStage.setOnCloseRequest(e -> mediaPlayer.stop());
            audioStage.show();
        } catch (Exception e) {
            System.err.println("Error opening audio: " + e.getMessage());
        }
    }

    private void openDocument(File documentFile) {
        try {
            java.awt.Desktop.getDesktop().open(documentFile);
        } catch (Exception e) {
            System.err.println("Error opening document: " + e.getMessage());
        }
    }

    /**
     * Updates the statistics label.
     *
     * @param count The number of media items
     */
    private void updateStats(int count) {
        statsLabel.setText("Total: " + count + " média" + (count > 1 ? "s" : ""));
    }

    /**
     * Truncates a text to a maximum length.
     *
     * @param text The text to truncate
     * @param maxLength The maximum length
     * @return The truncated text
     */
    private String truncateText(String text, int maxLength) {
        if (text.length() <= maxLength) {
            return text;
        }
        return text.substring(0, maxLength - 3) + "...";
    }

    /**
     * Handles the close button action.
     *
     * @param event The action event
     */
    @FXML
    private void handleClose(ActionEvent event) {
        Stage stage = (Stage) mediaContainer.getScene().getWindow();
        stage.close();
    }
}


// File: src/main/java/org/example/client/gui/controllers/RegisterController.java
package org.example.client.gui.controllers;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;
import java.util.concurrent.CompletableFuture;

import org.example.shared.dto.RegistrationDTO;
import org.example.shared.util.ValidationUtils;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.stage.Stage;

public class RegisterController {

    private static final String SERVER_ADDRESS = "localhost";
    private static final int SERVER_PORT = 5000;

    @FXML
    private TextField emailField;
    
    @FXML
    private PasswordField passwordField;
    
    @FXML
    private PasswordField confirmPasswordField;
    
    @FXML
    private Button registerButton;
    
    @FXML
    private Label emailErrorLabel;
    
    @FXML
    private Label passwordErrorLabel;
    
    @FXML
    private Label confirmPasswordErrorLabel;
    
    private final ObjectMapper mapper;
    
    public RegisterController() {
        this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
    }
    
    @FXML
    public void initialize() {
        // Activer le bouton d'inscription seulement si tous les champs sont remplis
        registerButton.disableProperty().bind(
            emailField.textProperty().isEmpty().or(
            passwordField.textProperty().isEmpty().or(
            confirmPasswordField.textProperty().isEmpty()))
        );
        
        // Réinitialiser les messages d'erreur lorsque l'utilisateur modifie les champs
        emailField.textProperty().addListener((observable, oldValue, newValue) -> {
            emailErrorLabel.setVisible(false);
        });
        
        passwordField.textProperty().addListener((observable, oldValue, newValue) -> {
            passwordErrorLabel.setVisible(false);
        });
        
        confirmPasswordField.textProperty().addListener((observable, oldValue, newValue) -> {
            confirmPasswordErrorLabel.setVisible(false);
        });
    }
    
    @FXML
    private void handleRegister(final ActionEvent event) {
        // Réinitialiser les messages d'erreur
        emailErrorLabel.setVisible(false);
        passwordErrorLabel.setVisible(false);
        confirmPasswordErrorLabel.setVisible(false);
        
        // Récupérer les valeurs des champs
        final String email = emailField.getText().trim();
        final String password = passwordField.getText();
        final String confirmPassword = confirmPasswordField.getText();
        
        // Valider l'email
        if (!ValidationUtils.isValidEmail(email)) {
            emailErrorLabel.setText("Format d'email invalide");
            emailErrorLabel.setVisible(true);
            return;
        }
        
        // Valider le mot de passe
        if (!ValidationUtils.isStrongPassword(password)) {
            passwordErrorLabel.setText("Le mot de passe ne respecte pas les critères de sécurité");
            passwordErrorLabel.setVisible(true);
            return;
        }
        
        // Vérifier que les mots de passe correspondent
        if (!ValidationUtils.doPasswordsMatch(password, confirmPassword)) {
            confirmPasswordErrorLabel.setText("Les mots de passe ne correspondent pas");
            confirmPasswordErrorLabel.setVisible(true);
            return;
        }
        
        // Débinder la propriété disable avant de la modifier
        registerButton.disableProperty().unbind();
        registerButton.setDisable(true);
        
        // Créer le DTO d'inscription
        final RegistrationDTO registrationDTO = new RegistrationDTO(email, password, confirmPassword);
        
        // Envoyer la requête d'inscription au serveur
        CompletableFuture.runAsync(() -> {
            Socket socket = null;
            PrintWriter out = null;
            Scanner scanner = null;
            
            try {
                socket = new Socket(SERVER_ADDRESS, SERVER_PORT);
                out = new PrintWriter(socket.getOutputStream(), true);
                scanner = new Scanner(socket.getInputStream());
                
                // Envoyer une commande spécifique pour indiquer qu'il s'agit d'une inscription
                out.println("REGISTER");
                
                // Envoyer les données d'inscription
                out.println(mapper.writeValueAsString(registrationDTO));
                
                // Lire la réponse du serveur
                final String response = scanner.nextLine();
                
                Platform.runLater(() -> {
                    if ("REGISTER_SUCCESS".equals(response)) {
                        showSuccess("Inscription réussie", "Votre compte a été créé avec succès. Vous pouvez maintenant vous connecter.");
                        try {
                            openLoginWindow();
                        } catch (final IOException e) {
                            showError("Erreur d'interface", "Impossible d'ouvrir la fenêtre de connexion: " + e.getMessage());
                            rebindRegisterButton();
                        }
                    } else {
                        showError("Échec de l'inscription", response);
                        rebindRegisterButton();
                    }
                });
            } catch (final IOException e) {
                Platform.runLater(() -> {
                    showError("Erreur de connexion", "Impossible de se connecter au serveur: " + e.getMessage());
                    rebindRegisterButton();
                });
            } finally {
                if (scanner != null) scanner.close();
                if (out != null) out.close();
                if (socket != null) {
                    try {
                        socket.close();
                    } catch (IOException e) {
                        // Ignorer l'exception lors de la fermeture
                    }
                }
            }
        });
    }
    
    @FXML
    private void handleLoginLink(final ActionEvent event) {
        try {
            openLoginWindow();
        } catch (final IOException e) {
            showError("Erreur d'interface", "Impossible d'ouvrir la fenêtre de connexion: " + e.getMessage());
        }
    }
    
    private void openLoginWindow() throws IOException {
        // Charger la vue de connexion
        final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
        final Parent loginView = loader.load();
        
        // Créer et afficher la nouvelle scène
        final Scene loginScene = new Scene(loginView, 600, 400);
        final Stage currentStage = (Stage) registerButton.getScene().getWindow();
        
        currentStage.setTitle("Connexion");
        currentStage.setScene(loginScene);
        currentStage.centerOnScreen();
    }
    
    private void rebindRegisterButton() {
        registerButton.disableProperty().unbind(); // S'assurer qu'il n'y a pas de binding actif
        registerButton.setDisable(false); // Réactiver le bouton
        // Rebinder le bouton avec la condition initiale
        registerButton.disableProperty().bind(
            emailField.textProperty().isEmpty().or(
            passwordField.textProperty().isEmpty().or(
            confirmPasswordField.textProperty().isEmpty()))
        );
    }
    
    private void showError(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
    
    private void showSuccess(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}



// File: src/main/java/org/example/client/gui/Launcher.java
package org.example.client.gui;

/**
 * Classe de lancement pour l'application JavaFX.
 * Cette classe sert de point d'entrée principal pour éviter les problèmes
 * de modules JavaFX lors de l'exécution à partir d'un JAR.
 */
public class Launcher {
    /**
     * Point d'entrée principal de l'application.
     * @param args Arguments de ligne de commande
     */
    public static void main(final String[] args) {
        // Lance l'application JavaFX
        ChatClientApplication.main(args);
    }
}




// File: src/main/java/org/example/client/gui/repository/JsonLocalMessageRepository.java
package org.example.client.gui.repository;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.example.shared.model.Message;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

/**
 * Classe de persistance locale pour l'historique des messages d'un utilisateur.
 * L'historique est stocké sous forme de fichier JSON dans le dossier
 * "src/main/resources/client_data".
 */
public class JsonLocalMessageRepository {
    // Utilisation du répertoire de projet pour stocker les données clients
    private static final String LOCAL_FOLDER = System.getProperty("user.dir") + File.separator + "client_messages";
    private final ObjectMapper objectMapper;

    public JsonLocalMessageRepository() {
        this.objectMapper = new ObjectMapper();
        // Register the JavaTimeModule for date-time support
        this.objectMapper.registerModule(new JavaTimeModule());
        // Pretty-print output
        this.objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        ensureLocalFolderExists();
    }

    private void ensureLocalFolderExists() {
        final Path folderPath = Paths.get(LOCAL_FOLDER);
        if (!folderPath.toFile().exists()) {
            try {
                folderPath.toFile().mkdirs();
            } catch (final Exception e) {
                System.err.println("Erreur lors de la création du dossier client_data : " + e.getMessage());
            }
        }
    }

    /**
     * Renvoie le chemin complet du fichier de l'utilisateur.
     */
    private String getUserFilePath(final String userEmail) {
        // Remplacer les caractères spéciaux pour créer un nom de fichier valide
        return LOCAL_FOLDER + File.separator + userEmail.replace("@", "_at_") + "_messages.json";
    }

    /**
     * Charge la liste des messages locaux pour l'utilisateur.
     */
    public List<Message> loadLocalMessages(final String userEmail) throws IOException {
        final String filePath = getUserFilePath(userEmail);
        final File file = new File(filePath);
        if (!file.exists()) {
            return new ArrayList<>();
        }
        final CollectionType listType = objectMapper.getTypeFactory()
                .constructCollectionType(ArrayList.class, Message.class);
        return objectMapper.readValue(file, listType);
    }

    /**
     * Enregistre la liste des messages locaux pour l'utilisateur.
     */
    public void saveLocalMessages(final String userEmail, final List<Message> messages) throws IOException {
        final String filePath = getUserFilePath(userEmail);
        objectMapper.writeValue(new File(filePath), messages);
    }

    /**
     * Ajoute un nouveau message dans l'historique local pour l'utilisateur.
     * message envoyé et recue
     */
    public void addLocalMessage(final String userEmail, final Message message) throws IOException {
        final List<Message> messages = loadLocalMessages(userEmail);
        messages.add(message);
        saveLocalMessages(userEmail, messages);
    }

    /**
     * Retourne la conversation entre deux utilisateurs en filtrant les messages
     * directs (sans groupId).
     */
    public List<Message> loadContactMessages(final String userEmail, final long myId, final long contactId)
            throws IOException {
        final List<Message> allMessages = loadLocalMessages(userEmail);
        final List<Message> contactMessages = allMessages.stream()
                .filter(msg -> msg.getGroupId() == null
                        && ((msg.getSenderUserId() == myId && msg.getReceiverUserId() != null
                                && msg.getReceiverUserId() == contactId)
                                || (msg.getSenderUserId() == contactId && msg.getReceiverUserId() != null
                                        && msg.getReceiverUserId() == myId)))
                .distinct()
                .collect(Collectors.toList());
        return contactMessages;
    }

    /**
     * Retourne la conversation de groupe en filtrant les messages dont le groupId
     * correspond
     * au groupe passé.
     */
    public List<Message> loadGroupMessages(final String userEmail, final long groupId) throws IOException {
        final List<Message> allMessages = loadLocalMessages(userEmail);
        final List<Message> groupMessages = new ArrayList<>();
        for (final Message msg : allMessages) {
            if (msg.getGroupId() != null && msg.getGroupId() == groupId) {
                groupMessages.add(msg);
            }
        }
        return groupMessages;
    }

    /**
     * Supprime un message de l'historique local pour l'utilisateur.
     */
    public void removeConversation(final String userEmail, final long myId, final long contactId) throws IOException {
        final List<Message> messages = loadLocalMessages(userEmail);
        messages.removeIf(m -> (m.getSenderUserId() == myId && m.getReceiverUserId() != null
                && m.getReceiverUserId() == contactId)
                || (m.getSenderUserId() == contactId && m.getReceiverUserId() != null
                        && m.getReceiverUserId() == myId));
        saveLocalMessages(userEmail, messages);
    }

    /**
     * Récupère le dernier message échangé avec un contact spécifique.
     */
    public Optional<Message> getLastContactMessage(final String userEmail, final long myId, final long contactId) throws IOException {
        return loadContactMessages(userEmail, myId, contactId).stream()
                .max(Comparator.comparing(Message::getTimestamp));
    }

    /**
     * Récupère le dernier message d'un groupe spécifique.
     */
    public Optional<Message> getLastGroupMessage(final String userEmail, final long groupId) throws IOException {
        return loadGroupMessages(userEmail, groupId).stream()
                .max(Comparator.comparing(Message::getTimestamp));
    }
}


// File: src/main/java/org/example/client/gui/security/EncryptionUtils.java
package org.example.client.gui.security;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class EncryptionUtils {

    private static final String RSA_ALGORITHM = "RSA";
    private static final String RC4_ALGORITHM = "RC4"; // !! Utiliser "AES" en production !!
    private static final int RSA_KEY_SIZE = 2048;
    private static final int RC4_KEY_SIZE = 128; // Pour AES, utiliser 128, 192 ou 256

    // Génère une paire de clés RSA
    public static KeyPair generateRsaKeyPair() throws NoSuchAlgorithmException {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(RSA_ALGORITHM);
        generator.initialize(RSA_KEY_SIZE);
        return generator.generateKeyPair();
    }

    // Génère une clé secrète RC4 (ou AES)
    public static SecretKey generateRc4SessionKey() throws NoSuchAlgorithmException {
         // Pour RC4, on peut créer directement depuis des bytes, mais utilisons KeyGenerator pour la forme
         // KeyGenerator keyGen = KeyGenerator.getInstance(RC4_ALGORITHM);
         // keyGen.init(RC4_KEY_SIZE);
         // return keyGen.generateKey();

         // Alternative simple pour RC4 (taille variable, ici 128 bits / 16 bytes)
         SecureRandom random = new SecureRandom();
         byte[] keyBytes = new byte[RC4_KEY_SIZE / 8];
         random.nextBytes(keyBytes);
         return new SecretKeySpec(keyBytes, RC4_ALGORITHM);

        /* Pour AES:
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(256); // Ou 128, 192
        return keyGen.generateKey();
        */
    }

    // Chiffre des données avec une clé publique RSA
    public static byte[] encryptWithRsaPublicKey(byte[] data, PublicKey publicKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RSA_ALGORITHM); // Utiliser "RSA/ECB/PKCS1Padding" est souvent plus explicite
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        return cipher.doFinal(data);
    }

    // Déchiffre des données avec une clé privée RSA
    public static byte[] decryptWithRsaPrivateKey(byte[] data, PrivateKey privateKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RSA_ALGORITHM); // Utiliser "RSA/ECB/PKCS1Padding"
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        return cipher.doFinal(data);
    }

     // Chiffre des données avec une clé RC4 (ou AES)
    public static byte[] encryptWithRc4(byte[] data, SecretKey sessionKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RC4_ALGORITHM); // Pour AES: "AES/GCM/NoPadding" (nécessite IvParameterSpec) ou "AES/ECB/PKCS5Padding" (plus simple mais moins sûr)
        cipher.init(Cipher.ENCRYPT_MODE, sessionKey);
        return cipher.doFinal(data);
        // Pour AES/GCM, il faudrait gérer l'IV (Initialization Vector)
    }

    // Déchiffre des données avec une clé RC4 (ou AES)
    public static byte[] decryptWithRc4(byte[] encryptedData, SecretKey sessionKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RC4_ALGORITHM); // Pour AES: "AES/GCM/NoPadding" ou "AES/ECB/PKCS5Padding"
        cipher.init(Cipher.DECRYPT_MODE, sessionKey);
        return cipher.doFinal(encryptedData);
         // Pour AES/GCM, il faudrait fournir l'IV utilisé lors du chiffrement
    }

    // --- Méthodes utilitaires pour convertir les clés en String (Base64) pour stockage/transmission ---

    public static String keyToString(Key key) {
        return Base64.getEncoder().encodeToString(key.getEncoded());
    }

    public static PublicKey stringToPublicKey(String keyString) throws Exception {
        byte[] keyBytes = Base64.getDecoder().decode(keyString);
        X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(RSA_ALGORITHM);
        return keyFactory.generatePublic(spec);
    }

     public static PrivateKey stringToPrivateKey(String keyString) throws Exception {
        byte[] keyBytes = Base64.getDecoder().decode(keyString);
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(RSA_ALGORITHM);
        return keyFactory.generatePrivate(spec);
    }

     public static SecretKey stringToRc4SecretKey(String keyString) {
         byte[] keyBytes = Base64.getDecoder().decode(keyString);
         return new SecretKeySpec(keyBytes, RC4_ALGORITHM);
     }

      /* Pour AES:
     public static SecretKey stringToAesSecretKey(String keyString) {
         byte[] keyBytes = Base64.getDecoder().decode(keyString);
         return new SecretKeySpec(keyBytes, "AES");
     }
     */
}


// File: src/main/java/org/example/client/gui/security/KeyManager.java
package org.example.client.gui.security;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

import javax.crypto.SecretKey;

// Gère les clés RSA du client, les clés publiques des contacts et les clés de session
public class KeyManager {

    private static final String KEYS_DIR = System.getProperty("user.dir")
            + File.separator + "keys";
    private String KEY_PAIR_FILE = KEYS_DIR + File.separator + "rsa_keys.properties";
    private static final String PUBLIC_KEYS_FILE = KEYS_DIR + File.separator + "public_keys.properties";
    private static final String SESSION_KEYS_FILE = KEYS_DIR + File.separator + "session_keys.properties";

    private KeyPair userKeyPair;
    private Map<String, PublicKey> contactPublicKeys = new ConcurrentHashMap<>(); // userId -> PublicKey
    private Map<String, SecretKey> sessionKeys = new ConcurrentHashMap<>(); // userId -> SessionKey (RC4/AES)

    public KeyManager() {
        init();
        loadKeys();
    }
    
    // Nouveau constructeur acceptant l'email de l'utilisateur
    public KeyManager(String currentUserEmail) {
        if (currentUserEmail == null || currentUserEmail.trim().isEmpty()) {
            currentUserEmail = "default";
        }
        // Construire le nom de fichier de la paire de clés avec l'identifiant utilisateur
        this.KEY_PAIR_FILE = KEYS_DIR + File.separator + "rsa_keys_" 
                + currentUserEmail.replace("@", "_at_") + ".properties";
        init();
        loadKeys();
    }
    
    private void init() {
        try {
            Files.createDirectories(Paths.get(KEYS_DIR));
        } catch (IOException ioEx) {
            System.err.println("Erreur création dossier clés: " + ioEx.getMessage());
        }
    }
    
    private void loadKeys() {
        try {
            File keyPairFile = new File(KEY_PAIR_FILE);
            if (!keyPairFile.exists()) {
                System.out.println("Aucune paire de clés trouvée, génération...");
                generateAndSaveKeyPair();
            } else {
                loadKeyPair();
            }
            loadContactPublicKeys();
            loadSessionKeys();
        } catch (final Exception e) {
            System.err.println("Erreur lors du chargement des clés: " + e.getMessage());
            if (userKeyPair == null) {
                generateAndSaveKeyPair();
            }
        }
    }

    private void loadKeyPair() throws Exception {
        File f = new File(KEY_PAIR_FILE);
        if (!f.exists())
            return;

        Properties props = new Properties();
        try (InputStream input = new FileInputStream(f)) {
            props.load(input);
            String pubKeyStr = props.getProperty("publicKey");
            String privKeyStr = props.getProperty("privateKey");
            if (pubKeyStr != null && privKeyStr != null) {
                PublicKey publicKey = EncryptionUtils.stringToPublicKey(pubKeyStr);
                PrivateKey privateKey = EncryptionUtils.stringToPrivateKey(privKeyStr);
                userKeyPair = new KeyPair(publicKey, privateKey);
                System.out.println("Paire de clés RSA chargée.");
            }
        }
    }

    private void loadContactPublicKeys() {
        File f = new File(PUBLIC_KEYS_FILE);
        if (!f.exists())
            return;
        Properties props = new Properties();
        try (InputStream input = new FileInputStream(f)) {
            props.load(input);
            for (String userId : props.stringPropertyNames()) {
                try {
                    PublicKey pubKey = EncryptionUtils.stringToPublicKey(props.getProperty(userId));
                    contactPublicKeys.put(userId, pubKey);
                } catch (Exception e) {
                    System.err.println("Erreur chargement clé publique pour " + userId + ": " + e.getMessage());
                }
            }
            System.out.println("Clés publiques des contacts chargées.");
        } catch (IOException e) {
            System.err.println("Erreur lecture fichier clés publiques: " + e.getMessage());
        }
    }

    private void loadSessionKeys() {
        File f = new File(SESSION_KEYS_FILE);
        if (!f.exists())
            return;
        Properties props = new Properties();
        try (InputStream input = new FileInputStream(f)) {
            props.load(input);
            for (String userId : props.stringPropertyNames()) {
                try {
                    // !! Attention: Stocker les clés de session n'est pas idéal pour la Perfect
                    // Forward Secrecy
                    // Il vaut mieux les regénérer à chaque session. Ceci est un exemple simple.
                    SecretKey sessionKey = EncryptionUtils.stringToRc4SecretKey(props.getProperty(userId)); // Adapter
                                                                                                            // pour AES
                                                                                                            // si besoin
                    sessionKeys.put(userId, sessionKey);
                } catch (Exception e) {
                    System.err.println("Erreur chargement clé session pour " + userId + ": " + e.getMessage());
                }
            }
            System.out.println("Clés de session (persistées) chargées.");
        } catch (IOException e) {
            System.err.println("Erreur lecture fichier clés session: " + e.getMessage());
        }
    }

    private void generateAndSaveKeyPair() {
        try {
            userKeyPair = EncryptionUtils.generateRsaKeyPair();
            saveKeyPair();
            System.out.println("Nouvelle paire de clés RSA générée et sauvegardée.");
        } catch (Exception e) {
            System.err.println("Impossible de générer/sauvegarder la paire de clés RSA: " + e.getMessage());
            // Gérer l'erreur critique - l'application ne peut pas fonctionner sans clés
        }
    }

    private void saveKeyPair() throws IOException {
        if (userKeyPair == null)
            return;
        Properties props = new Properties();
        props.setProperty("publicKey", EncryptionUtils.keyToString(userKeyPair.getPublic()));
        props.setProperty("privateKey", EncryptionUtils.keyToString(userKeyPair.getPrivate())); // !! Sécurité: Stockage
                                                                                                // non chiffré !!

        try (OutputStream output = new FileOutputStream(KEY_PAIR_FILE)) {
            props.store(output, "RSA Key Pair - NE PAS MODIFIER");
        }
    }

    private void saveContactPublicKeys() {
        Properties props = new Properties();
        contactPublicKeys.forEach((userId, key) -> {
            props.setProperty(userId, EncryptionUtils.keyToString(key));
        });
        try (OutputStream output = new FileOutputStream(PUBLIC_KEYS_FILE)) {
            props.store(output, "Contact Public Keys");
        } catch (IOException e) {
            System.err.println("Erreur sauvegarde clés publiques contacts: " + e.getMessage());
        }
    }

    private void saveSessionKeys() {
        Properties props = new Properties();
        sessionKeys.forEach((userId, key) -> {
            props.setProperty(userId, EncryptionUtils.keyToString(key));
        });
        try (OutputStream output = new FileOutputStream(SESSION_KEYS_FILE)) {
            props.store(output, "Session Keys (RC4/AES) - Pour débogage/persistance simple");
        } catch (IOException e) {
            System.err.println("Erreur sauvegarde clés session: " + e.getMessage());
        }
    }

    public PublicKey getUserPublicKey() {
        return (userKeyPair != null) ? userKeyPair.getPublic() : null;
    }

    public PrivateKey getUserPrivateKey() {
        return (userKeyPair != null) ? userKeyPair.getPrivate() : null;
    }

    public String getUserPublicKeyString() {
        PublicKey key = getUserPublicKey();
        return (key != null) ? EncryptionUtils.keyToString(key) : null;
    }

    public void storeContactPublicKey(String userId, PublicKey key) {
        contactPublicKeys.put(userId, key);
        saveContactPublicKeys(); // Sauvegarder immédiatement
    }

    public PublicKey getContactPublicKey(String userId) {
        return contactPublicKeys.get(userId);
    }

    public void storeSessionKey(String userId, SecretKey key) {
        sessionKeys.put(userId, key);
        // saveSessionKeys(); // Décider si on persiste les clés de session
    }

    public SecretKey getSessionKey(String userId) {
        return sessionKeys.get(userId);
    }

    public void clearSessionKey(String userId) {
        sessionKeys.remove(userId);
        // saveSessionKeys();
    }

    public void clearAllSessionKeys() {
        sessionKeys.clear();
        // saveSessionKeys();
    }
}


// File: src/main/java/org/example/client/gui/service/AudioRecorderService.java
package org.example.client.gui.service;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.UUID;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.TargetDataLine;

/**
 * Service for recording audio messages.
 */
public class AudioRecorderService {

    private TargetDataLine targetLine;
    private boolean isRecording = false;
    private Thread recordingThread;
    private ByteArrayOutputStream byteOutputStream;

    // Audio format settings
    private static final float SAMPLE_RATE = 44100;
    private static final int SAMPLE_SIZE_BITS = 16;
    private static final int CHANNELS = 1;
    private static final boolean SIGNED = true;
    private static final boolean BIG_ENDIAN = false;
    private static final AudioFormat.Encoding ENCODING = AudioFormat.Encoding.PCM_SIGNED;

    /**
     * Starts recording audio.
     *
     * @throws LineUnavailableException If the audio line is unavailable
     */
    public void startRecording() throws LineUnavailableException {
        if (isRecording) {
            return;
        }

        // Create audio format
        AudioFormat format = new AudioFormat(
                ENCODING,
                SAMPLE_RATE,
                SAMPLE_SIZE_BITS,
                CHANNELS,
                (SAMPLE_SIZE_BITS / 8) * CHANNELS,
                SAMPLE_RATE,
                BIG_ENDIAN);

        // Get the target data line
        DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);
        if (!AudioSystem.isLineSupported(info)) {
            throw new LineUnavailableException("The system does not support the specified audio format");
        }

        targetLine = (TargetDataLine) AudioSystem.getLine(info);
        targetLine.open(format);
        targetLine.start();

        byteOutputStream = new ByteArrayOutputStream();
        isRecording = true;

        // Create a thread to read audio data
        recordingThread = new Thread(() -> {
            byte[] buffer = new byte[4096];
            int bytesRead;

            while (isRecording) {
                bytesRead = targetLine.read(buffer, 0, buffer.length);
                if (bytesRead > 0) {
                    byteOutputStream.write(buffer, 0, bytesRead);
                }
            }
        });

        recordingThread.start();
    }

    /**
     * Stops recording and returns the recorded audio file.
     *
     * @return The recorded audio file
     * @throws IOException If an I/O error occurs
     */
    public File stopRecording() throws IOException {
        if (!isRecording) {
            return null;
        }

        isRecording = false;

        try {
            // Wait for the recording thread to finish
            recordingThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        targetLine.stop();
        targetLine.close();

        // Create a WAV file from the recorded bytes
        byte[] audioBytes = byteOutputStream.toByteArray();
        AudioFormat format = new AudioFormat(
                ENCODING,
                SAMPLE_RATE,
                SAMPLE_SIZE_BITS,
                CHANNELS,
                (SAMPLE_SIZE_BITS / 8) * CHANNELS,
                SAMPLE_RATE,
                BIG_ENDIAN);

        ByteArrayInputStream byteInputStream = new ByteArrayInputStream(audioBytes);
        AudioInputStream audioInputStream = new AudioInputStream(byteInputStream, format, audioBytes.length / format.getFrameSize());

        // Create a temporary file
        File tempFile = File.createTempFile("audio_" + UUID.randomUUID().toString(), ".wav");
        try (FileOutputStream fos = new FileOutputStream(tempFile)) {
            AudioSystem.write(audioInputStream, AudioFileFormat.Type.WAVE, tempFile);
        } catch (IOException e) {
            throw new IOException("Failed to save audio file: " + e.getMessage(), e);
        }

        return tempFile;
    }

    /**
     * Checks if the system supports audio recording.
     *
     * @return true if audio recording is supported, false otherwise
     */
    public boolean isAudioRecordingSupported() {
        try {
            AudioFormat format = new AudioFormat(
                    ENCODING,
                    SAMPLE_RATE,
                    SAMPLE_SIZE_BITS,
                    CHANNELS,
                    (SAMPLE_SIZE_BITS / 8) * CHANNELS,
                    SAMPLE_RATE,
                    BIG_ENDIAN);

            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);
            return AudioSystem.isLineSupported(info);
        } catch (Exception e) {
            return false;
        }
    }
}


// File: src/main/java/org/example/client/gui/service/CallManager.java
package org.example.client.gui.service;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import javax.sound.sampled.TargetDataLine;

import org.example.shared.model.CallSession;
import org.example.shared.model.User;

import javafx.application.Platform;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;

/**
 * Gère les appels audio via UDP pour l'application de chat.
 */
public class CallManager {
    // Paramètres audio
    private static final float SAMPLE_RATE = 44100.0f;
    private static final int SAMPLE_SIZE_BITS = 16;
    private static final int CHANNELS = 1;
    private static final boolean SIGNED = true;
    private static final boolean BIG_ENDIAN = false;
    private static final AudioFormat AUDIO_FORMAT = new AudioFormat(
            SAMPLE_RATE, SAMPLE_SIZE_BITS, CHANNELS, SIGNED, BIG_ENDIAN);
    private static final int BUFFER_SIZE = 4096;

    // État de l'appel
    private final AtomicBoolean isCallActive = new AtomicBoolean(false);
    private final AtomicBoolean isMicrophoneMuted = new AtomicBoolean(false);
    private final StringProperty callStatus = new SimpleStringProperty("Aucun appel en cours");
    
    // Informations sur l'appel en cours
    private CallSession currentSession;
    private User remoteUser;
    private InetAddress remoteAddress;
    private int remotePort;
    
    // Sockets et threads pour la communication UDP
    private DatagramSocket audioSocket;
    private Thread audioSenderThread;
    private Thread audioReceiverThread;
    private int localPort;
    
    // Lignes audio pour la capture et la lecture
    private TargetDataLine microphoneLine;
    private SourceDataLine speakerLine;
    
    // Singleton
    private static CallManager instance;
    
    private CallManager() {
        // Constructeur privé pour le singleton
    }
    
    public static synchronized CallManager getInstance() {
        if (instance == null) {
            instance = new CallManager();
        }
        return instance;
    }
    
    /**
     * Initialise un appel sortant vers un utilisateur.
     * 
     * @param targetUser L'utilisateur à appeler
     * @param session Les informations de session d'appel
     * @return true si l'initialisation a réussi
     */
    public boolean initiateCall(User targetUser, CallSession session) {
        if (isCallActive.get()) {
            return false; // Un appel est déjà en cours
        }
        
        try {
            this.remoteUser = targetUser;
            this.currentSession = session;
            
            // Initialiser le socket UDP pour être prêt à envoyer/recevoir
            initializeUdpSocket();
            
            // Le port et l'adresse seront définis lors de l'acceptation de l'appel
            updateCallStatus("Appel en cours vers " + targetUser.getDisplayNameOrEmail());
            return true;
        } catch (Exception e) {
            updateCallStatus("Erreur lors de l'initialisation de l'appel: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Initialise le socket UDP et récupère le port local.
     */
    private void initializeUdpSocket() {
        try {
            // Fermer l'ancien socket s'il existe
            if (audioSocket != null && !audioSocket.isClosed()) {
                audioSocket.close();
            }
            
            // Créer un nouveau socket avec un port spécifique
            audioSocket = new DatagramSocket(0); // 0 = port aléatoire attribué par le système
            localPort = audioSocket.getLocalPort();
            
            System.out.println("Socket UDP initialisé sur le port local: " + localPort);
        } catch (SocketException e) {
            System.err.println("Erreur lors de l'initialisation du socket UDP: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Obtient le port local utilisé par le socket UDP.
     * 
     * @return le port local
     */
    public int getLocalPort() {
        return localPort;
    }
    
    /**
     * Accepte un appel entrant et démarre la communication audio.
     * 
     * @param session Les informations de session d'appel
     * @param callerIp L'adresse IP de l'appelant
     * @param callerPort Le port UDP de l'appelant
     * @return true si l'acceptation a réussi
     */
    public boolean acceptCall(CallSession session, String callerIp, int callerPort) {
        if (isCallActive.get()) {
            return false; // Un appel est déjà en cours
        }
        
        try {
            this.currentSession = session;
            
            // Initialiser le socket UDP
            initializeUdpSocket();
            
            // Configurer l'adresse et le port distant
            this.remoteAddress = InetAddress.getByName(callerIp);
            this.remotePort = callerPort;
            
            System.out.println("Acceptation d'appel de " + callerIp + ":" + callerPort + 
                               " avec socket local sur port " + localPort);
            
            // Démarrer la communication audio
            startAudioCommunication();
            isCallActive.set(true);
            updateCallStatus("En appel avec " + remoteUser.getDisplayNameOrEmail());
            return true;
        } catch (Exception e) {
            updateCallStatus("Erreur lors de l'acceptation de l'appel: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Configure la connexion après que l'autre partie a accepté l'appel.
     * 
     * @param remoteIp L'adresse IP distante
     * @param remotePort Le port UDP distant
     * @return true si la configuration a réussi
     */
    public boolean setupCallConnection(String remoteIp, int remotePort) {
        try {
            if (remotePort <= 0) {
                updateCallStatus("Erreur: Port distant invalide (" + remotePort + ")");
                return false;
            }
            
            this.remoteAddress = InetAddress.getByName(remoteIp);
            this.remotePort = remotePort;
            
            System.out.println("Configuration de la connexion d'appel avec " + remoteIp + ":" + remotePort + 
                               " depuis le port local " + localPort);
            
            // Démarrer la communication audio
            startAudioCommunication();
            isCallActive.set(true);
            updateCallStatus("En appel avec " + remoteUser.getDisplayNameOrEmail());
            return true;
        } catch (UnknownHostException e) {
            updateCallStatus("Adresse IP invalide: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Termine l'appel en cours.
     */
    public void endCall() {
        if (!isCallActive.get()) {
            return;
        }
        
        isCallActive.set(false);
        
        // Arrêter les threads audio
        if (audioSenderThread != null) {
            audioSenderThread.interrupt();
        }
        if (audioReceiverThread != null) {
            audioReceiverThread.interrupt();
        }
        
        // Fermer les lignes audio
        if (microphoneLine != null && microphoneLine.isOpen()) {
            microphoneLine.stop();
            microphoneLine.close();
        }
        if (speakerLine != null && speakerLine.isOpen()) {
            speakerLine.stop();
            speakerLine.close();
        }
        
        // Fermer le socket
        if (audioSocket != null && !audioSocket.isClosed()) {
            audioSocket.close();
        }
        
        // Réinitialiser les variables
        currentSession = null;
        remoteUser = null;
        remoteAddress = null;
        remotePort = 0;
        
        updateCallStatus("Appel terminé");
    }
    
    /**
     * Active/désactive le microphone pendant l'appel.
     * 
     * @param muted true pour couper le micro, false pour l'activer
     */
    public void setMicrophoneMuted(boolean muted) {
        isMicrophoneMuted.set(muted);
        if (microphoneLine != null && microphoneLine.isOpen()) {
            if (muted) {
                microphoneLine.stop();
            } else {
                microphoneLine.start();
            }
        }
    }
    
    /**
     * Démarre la communication audio (envoi et réception).
     */
    private void startAudioCommunication() {
        try {
            // Vérifier que le socket est initialisé
            if (audioSocket == null || audioSocket.isClosed()) {
                initializeUdpSocket();
            }
            
            // Initialiser les lignes audio
            initAudioLines();
            
            // Démarrer les threads d'envoi et de réception
            startAudioSender();
            startAudioReceiver();
        } catch (LineUnavailableException e) {
            updateCallStatus("Erreur lors de l'initialisation des lignes audio: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Initialise les lignes audio pour la capture et la lecture.
     */
    private void initAudioLines() throws LineUnavailableException {
        // Ligne pour capturer l'audio du microphone
        DataLine.Info micInfo = new DataLine.Info(TargetDataLine.class, AUDIO_FORMAT);
        if (!AudioSystem.isLineSupported(micInfo)) {
            throw new LineUnavailableException("Le format audio n'est pas supporté pour la capture");
        }
        microphoneLine = (TargetDataLine) AudioSystem.getLine(micInfo);
        microphoneLine.open(AUDIO_FORMAT, BUFFER_SIZE);
        microphoneLine.start();
        
        // Ligne pour jouer l'audio reçu
        DataLine.Info speakerInfo = new DataLine.Info(SourceDataLine.class, AUDIO_FORMAT);
        if (!AudioSystem.isLineSupported(speakerInfo)) {
            throw new LineUnavailableException("Le format audio n'est pas supporté pour la lecture");
        }
        speakerLine = (SourceDataLine) AudioSystem.getLine(speakerInfo);
        speakerLine.open(AUDIO_FORMAT, BUFFER_SIZE);
        speakerLine.start();
    }
    
    /**
     * Démarre le thread d'envoi audio.
     */
    private void startAudioSender() {
        audioSenderThread = new Thread(() -> {
            try {
                byte[] buffer = new byte[BUFFER_SIZE];
                
                while (isCallActive.get()) {
                    if (microphoneLine != null && microphoneLine.isOpen()) {
                        int bytesRead = microphoneLine.read(buffer, 0, buffer.length);
                        if (bytesRead > 0) {
                            // Envoyer les données audio
                            sendAudioPacket(buffer);
                        }
                    }
                    Thread.sleep(5); // Petite pause pour éviter de surcharger le CPU
                }
            } catch (InterruptedException e) {
                // L'interruption est normale lors de la fin de l'appel
                if (isCallActive.get()) {
                    updateCallStatus("Erreur d'envoi audio: " + e.getMessage());
                }
            }
        });
        audioSenderThread.setDaemon(true);
        audioSenderThread.start();
    }
    
    /**
     * Démarre le thread de réception audio.
     */
    private void startAudioReceiver() {
        audioReceiverThread = new Thread(() -> {
            byte[] buffer = new byte[BUFFER_SIZE];
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
            
            try {
                while (isCallActive.get() && !Thread.currentThread().isInterrupted()) {
                    // Recevoir les données audio
                    audioSocket.receive(packet);
                    
                    // Jouer les données audio reçues
                    speakerLine.write(packet.getData(), 0, packet.getLength());
                }
            } catch (IOException e) {
                // L'interruption est normale lors de la fin de l'appel
                if (isCallActive.get()) {
                    updateCallStatus("Erreur de réception audio: " + e.getMessage());
                }
            }
        });
        audioReceiverThread.setDaemon(true);
        audioReceiverThread.start();
    }
    
    /**
     * Envoie un paquet audio à l'adresse distante.
     * 
     * @param audioData Les données audio à envoyer
     */
    private void sendAudioPacket(byte[] audioData) {
        if (audioSocket == null || audioSocket.isClosed()) {
            updateCallStatus("Erreur: Socket UDP non initialisé");
            return;
        }
        
        if (remoteAddress == null) {
            updateCallStatus("Erreur: Adresse distante non définie");
            return;
        }
        
        if (remotePort <= 0) {
            updateCallStatus("Erreur d'envoi audio: Can't send to port " + remotePort);
            return;
        }
        
        try {
            DatagramPacket packet = new DatagramPacket(
                    audioData, audioData.length, remoteAddress, remotePort);
            
            audioSocket.send(packet);
            
            // Débogage - Afficher périodiquement des informations sur l'envoi
            if (Math.random() < 0.01) { // ~1% des paquets pour éviter de spammer la console
                System.out.println("Envoi d'un paquet audio de " + audioData.length + 
                                  " octets vers " + remoteAddress + ":" + remotePort + 
                                  " depuis le port local " + localPort);
            }
        } catch (IOException e) {
            // Afficher l'erreur complète pour le débogage
            System.err.println("Erreur lors de l'envoi du paquet audio: " + e.getMessage());
            e.printStackTrace();
            
            // Mettre à jour le statut de l'appel avec un message d'erreur plus précis
            updateCallStatus("Erreur d'envoi audio: " + e.getMessage());
        }
    }
    
    /**
     * Met à jour le statut de l'appel.
     */
    private void updateCallStatus(String status) {
        Platform.runLater(() -> callStatus.set(status));
    }
    
    /**
     * Vérifie si un appel est en cours.
     */
    public boolean isCallActive() {
        return isCallActive.get();
    }
    
    /**
     * Obtient la propriété de statut d'appel pour la liaison UI.
     */
    public StringProperty callStatusProperty() {
        return callStatus;
    }
    
    /**
     * Obtient la session d'appel en cours.
     */
    public CallSession getCurrentSession() {
        return currentSession;
    }
    
    /**
     * Obtient l'utilisateur distant de l'appel en cours.
     */
    public User getRemoteUser() {
        return remoteUser;
    }
    
    /**
     * Définit l'utilisateur distant pour l'appel en cours.
     */
    public void setRemoteUser(User remoteUser) {
        this.remoteUser = remoteUser;
    }
}



// File: src/main/java/org/example/client/gui/service/ChatService.java
// filepath: src/main/java/org/example/client/gui/service/ChatService.java
package org.example.client.gui.service;

// ... autres imports ...
import org.example.client.gui.security.EncryptionUtils;
import org.example.client.gui.security.KeyManager;
import org.example.shared.model.Message;
import org.example.shared.model.User;
import org.example.shared.dto.Credentials;
import org.example.shared.model.CallSession;
import org.example.shared.model.CallSignal;
import org.example.shared.model.enums.MessageType;
import org.example.shared.dao.UserDAO; // Importer UserDAO
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.DeserializationFeature; // Pour ignorer props inconnues
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import javafx.application.Platform;

import java.io.*;
import java.net.Socket;
import java.net.ConnectException;
import java.net.SocketException;
import java.nio.charset.StandardCharsets;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.function.Consumer;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class ChatService {
    private static final String SERVER_ADDRESS = "localhost";
    private static final int SERVER_PORT = 5000;

    private Socket socket;
    private PrintWriter out;
    private BufferedReader in;
    private String userEmail;
    private long currentUserId = -1; // ID de l'utilisateur connecté
    private final ObjectMapper objectMapper;
    private Consumer<Message> messageConsumer;
    private Consumer<CallSignal> callSignalConsumer;
    private Thread listenerThread;
    private volatile boolean isRunning = false; // Remplacer 'running' par 'isRunning'

    // Instances DAO pour la persistance locale (si nécessaire côté client)
    // private final MessageDAO messageDAO;
    // private final GroupDAO groupDAO;
    private final UserDAO userDAO; // Pour obtenir l'ID utilisateur

    // New file service for handling multimedia
    private final FileService fileService;

    // --- AJOUTS POUR E2EE ---
    private final KeyManager keyManager;
    // --- FIN AJOUTS POUR E2EE ---

    // Constructeur modifié
    public ChatService(KeyManager keyManager) { // Accepter KeyManager
        this.keyManager = keyManager; // Stocker KeyManager
        this.objectMapper = new ObjectMapper()
            .registerModule(new JavaTimeModule())
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // Important
        // this.messageDAO = new MessageDAO(); // Si besoin côté client
        // this.groupDAO = new GroupDAO(); // Si besoin côté client
        this.userDAO = new UserDAO(); // Initialiser UserDAO
        this.fileService = new FileService();
    }

    public void setMessageConsumer(Consumer<Message> consumer) {
        this.messageConsumer = consumer;
    }

    public void setCallSignalConsumer(Consumer<CallSignal> consumer) {
        this.callSignalConsumer = consumer;
    }

    public long getCurrentUserId() {
        // Assurer que l'ID est chargé après la connexion
        if (currentUserId == -1 && userEmail != null) {
            try {
                User user = userDAO.findUserByEmail(userEmail);
                if (user != null) {
                    currentUserId = user.getId();
                }
            } catch (Exception e) {
                System.err.println("Erreur récupération ID utilisateur: " + e.getMessage());
            }
        }
        return currentUserId;
    }

    // resp : initie la connexion avec le serveur / l'authentification
    public boolean connect(final Credentials credentials) throws IOException {
        try {
            // resp 1 : etablissement de la connexion avec le serveur (creation de la socket coté serveur)
            System.out.println("Connexion au serveur " + SERVER_ADDRESS + ":" + SERVER_PORT);
            socket = new Socket(SERVER_ADDRESS, SERVER_PORT);
            out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8), true);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));

            // Envoyer la commande de connexion pour différencier des requêtes d'inscription
            out.println("LOGIN"); // Commande texte simple

            // Envoyer les identifiants en JSON
            final String jsonCredentials = objectMapper.writeValueAsString(credentials);
            out.println(jsonCredentials);

            // Attendre la réponse du serveur
            final String response = in.readLine();
            final boolean success = "AUTH_SUCCESS".equals(response);

            if (success) {
                this.userEmail = credentials.getEmail();
                this.currentUserId = getCurrentUserId(); // Charger l'ID utilisateur
                if (this.currentUserId == -1) {
                     throw new IOException("Impossible de récupérer l'ID utilisateur pour " + this.userEmail);
                }
                isRunning = true; // Mettre à jour isRunning
                startMessageListener();
                System.out.println("Authentification réussie pour " + userEmail + " (ID: " + currentUserId + ")");
                // Envoyer la clé publique APRÈS succès de l'authentification
                sendPublicKeyToServer();
            } else {
                System.out.println("Échec de l'authentification: " + (response != null ? response : "Réponse nulle"));
                disconnect(); // Utiliser la méthode disconnect existante
            }

            return success;
        } catch (final ConnectException e) {
            throw new IOException(
                    "Impossible de se connecter au serveur. Assurez-vous que le serveur est démarré et accessible sur "
                            + SERVER_ADDRESS + ":" + SERVER_PORT,
                    e);
        } catch (final Exception e) {
             System.err.println("Erreur détaillée connexion: " + e);
             e.printStackTrace();
            throw new IOException("Erreur lors de la connexion ou authentification: " + e.getMessage(), e);
        }
    }

    // --- GESTION E2EE ---

    /** Envoie la clé publique de l'utilisateur actuel au serveur. */
    public void sendPublicKeyToServer() {
        if (!isConnected() || getCurrentUserId() == -1 || keyManager.getUserPublicKeyString() == null) {
            System.err.println("Impossible d'envoyer la clé publique: non connecté, ID utilisateur ou clé manquante.");
            return;
        }
        try {
            System.out.println("Envoi de la clé publique au serveur...");
            // Utiliser un objet Message pour la clé publique pour une meilleure structure
            Message pubKeyMsg = new Message();
            pubKeyMsg.setSenderUserId(getCurrentUserId());
            pubKeyMsg.setType(MessageType.PUBLIC_KEY_RESPONSE); // On utilise ce type pour envoyer notre clé
            pubKeyMsg.setContent(keyManager.getUserPublicKeyString());

            sendMessage(pubKeyMsg); // Utiliser la méthode existante pour envoyer l'objet Message

            // Alternative avec commande texte simple (si ClientHandler est adapté)
            // String command = "PUB_KEY " + getCurrentUserId() + " " + keyManager.getUserPublicKeyString();
            // out.println(command);

        } catch (Exception e) {
            System.err.println("Erreur lors de l'envoi de la clé publique: " + e.getMessage());
        }
    }

    /** Demande la clé publique d'un autre utilisateur au serveur. */
    public void requestPublicKey(long targetUserId) {
         if (!isConnected()) return;
         try {
             System.out.println("Demande de la clé publique pour l'utilisateur ID: " + targetUserId);
             // Utiliser la factory pour créer le message de requête
             Message request = Message.newPublicKeyRequestMessage(getCurrentUserId(), targetUserId);
             sendMessage(request); // Envoyer l'objet Message
         } catch (IOException e) {
             System.err.println("Erreur demande clé publique pour ID " + targetUserId + ": " + e.getMessage());
         }
     }

    /**
     * Assure qu'une session E2EE est établie avec le destinataire.
     * Demande la clé publique si nécessaire et envoie la clé de session RC4/AES.
     * @param recipientUserId L'ID du destinataire.
     * @throws IllegalStateException si la clé publique n'est pas disponible immédiatement.
     * @throws Exception pour toute autre erreur de chiffrement ou réseau.
     */
    private void ensureSession(long recipientUserId) throws Exception {
        // Si on n'a pas de clé de session pour ce contact, il faut l'établir
        if (keyManager.getSessionKey(String.valueOf(recipientUserId)) == null) { // Utiliser l'ID comme clé de map
            System.out.println("Pas de clé de session pour ID " + recipientUserId + ". Tentative d'établissement...");

            // 1. A-t-on la clé publique du destinataire ?
            PublicKey recipientPublicKey = keyManager.getContactPublicKey(String.valueOf(recipientUserId));
            if (recipientPublicKey == null) {
                System.out.println("Clé publique pour ID " + recipientUserId + " non trouvée localement. Demande au serveur...");
                requestPublicKey(recipientUserId);
                // Il faut attendre la réponse. Pour l'instant, on lève une exception.
                // Une meilleure gestion impliquerait une attente asynchrone ou une mise en file d'attente du message.
                throw new IllegalStateException("Clé publique pour l'utilisateur ID " + recipientUserId + " non disponible. Demande envoyée. Réessayez d'envoyer le message.");
            }

            // 2. On a la clé publique, générer et envoyer la clé de session
            System.out.println("Clé publique trouvée pour ID " + recipientUserId + ". Génération et envoi de la clé de session...");
            // Générer une nouvelle clé de session RC4 (ou AES)
            SecretKey sessionKey = EncryptionUtils.generateRc4SessionKey(); // !! Changer pour AES !!
            String sessionKeyId = String.valueOf(System.currentTimeMillis()); // ID simple basé sur le temps

            // Chiffrer la clé de session avec la clé publique RSA du destinataire
            byte[] encryptedSessionKeyBytes = EncryptionUtils.encryptWithRsaPublicKey(sessionKey.getEncoded(), recipientPublicKey);

            // Créer le message d'initialisation de session
            Message initMessage = Message.newSessionInitMessage(
                    getCurrentUserId(),
                    recipientUserId,
                    encryptedSessionKeyBytes
            );
            // initMessage.setSessionKeyId(sessionKeyId); // Optionnel: envoyer l'ID de clé

            // Envoyer le message d'init
            sendMessage(initMessage);

            // Stocker la clé de session localement associée à l'ID utilisateur
            keyManager.storeSessionKey(String.valueOf(recipientUserId), sessionKey);
            System.out.println("Message d'initialisation de session envoyé à ID " + recipientUserId);

        } else {
             System.out.println("Clé de session existante pour ID " + recipientUserId);
        }
    }

    /**
     * Envoie un message texte chiffré E2EE.
     * Gère l'établissement de session si nécessaire.
     * @param recipientUserId L'ID du destinataire.
     * @param textContent Le contenu texte à chiffrer et envoyer.
     * @throws Exception Si l'envoi ou le chiffrement échoue.
     */
    public void sendEncryptedTextMessage(long recipientUserId, String textContent) throws Exception {
        if (!isConnected() || recipientUserId <= 0 || textContent == null || textContent.isEmpty()) {
            throw new IllegalArgumentException("Paramètres invalides pour sendEncryptedTextMessage");
        }

        // 1. Assurer que la session E2EE est prête (peut lever une exception si clé publique manque)
        ensureSession(recipientUserId);

        // 2. Récupérer la clé de session (devrait exister après ensureSession)
        SecretKey sessionKey = keyManager.getSessionKey(String.valueOf(recipientUserId));
        if (sessionKey == null) {
            // Ne devrait pas arriver si ensureSession a réussi, mais sécurité
            throw new IllegalStateException("Échec critique: Clé de session non trouvée après ensureSession pour ID " + recipientUserId);
        }
        String sessionKeyId = null; // Récupérer l'ID si on l'a stocké/généré

        // 3. Chiffrer le contenu avec la clé de session RC4 (ou AES)
        byte[] encryptedBytes = EncryptionUtils.encryptWithRc4(textContent.getBytes(StandardCharsets.UTF_8), sessionKey); // !! Changer pour AES !!

        // 4. Créer l'objet Message chiffré
        Message message = Message.newEncryptedTextMessage(
                getCurrentUserId(),
                recipientUserId,
                encryptedBytes,
                sessionKeyId // Passer l'ID de session si utilisé
        );

        // 5. Envoyer l'objet Message via la méthode existante
        sendMessage(message);
        System.out.println("Message texte chiffré envoyé à ID " + recipientUserId);
    }

    // --- FIN GESTION E2EE ---


    // Méthode existante pour envoyer un objet Message (adaptée pour JSON)
    public void sendMessage(final Message message) throws IOException {
        if (out == null || socket == null || socket.isClosed()) {
            throw new IOException("Non connecté au serveur.");
        }
        // Assigner l'expéditeur si ce n'est pas déjà fait
        if (message.getSenderUserId() <= 0) {
             message.setSenderUserId(getCurrentUserId());
        }
        try {
            final String jsonMessage = objectMapper.writeValueAsString(message);
            out.println(jsonMessage);
        } catch (JsonProcessingException e) {
            throw new IOException("Erreur lors de la sérialisation du message en JSON", e);
        }
    }

    // Méthode pour envoyer un objet CallSignal (adaptée pour JSON)
    public void sendCallSignal(final CallSignal signal) throws IOException {
         if (out == null || socket == null || socket.isClosed()) {
            throw new IOException("Non connecté au serveur.");
        }
         // Assigner l'expéditeur si ce n'est pas déjà fait
         if (signal.getSenderUserId() <= 0) { // Assumant un champ senderUserId dans CallSignal
             signal.setSenderUserId(getCurrentUserId());
         }
         try {
            final String jsonSignal = objectMapper.writeValueAsString(signal);
            out.println(jsonSignal);
        } catch (JsonProcessingException e) {
            throw new IOException("Erreur lors de la sérialisation du signal d'appel en JSON", e);
        }
    }


    private void startMessageListener() {
        if (listenerThread != null && listenerThread.isAlive()) {
            return; // Déjà en cours d'écoute
        }
        isRunning = true;
        listenerThread = new Thread(() -> {
            try {
                String line;
                while (isRunning && (line = in.readLine()) != null) {
                    handleReceivedJson(line); // Traiter la ligne JSON reçue
                }
            } catch (SocketException e) {
                if (isRunning) {
                    System.err.println("Connexion perdue avec le serveur (SocketException): " + e.getMessage());
                } else {
                    System.out.println("Socket fermé normalement.");
                }
            } catch (IOException e) {
                if (isRunning) {
                    System.err.println("Erreur de lecture du serveur: " + e.getMessage());
                    e.printStackTrace();
                }
            } catch (Exception e) { // Capturer autres exceptions (ex: JSON parsing)
                 if (isRunning) {
                    System.err.println("Erreur inattendue dans le listener: " + e.getMessage());
                    e.printStackTrace();
                }
            } finally {
                isRunning = false;
                // Ne pas appeler disconnect() ici pour éviter boucle infinie si disconnect cause l'erreur
                System.out.println("Thread d'écoute arrêté.");
                // Notifier l'UI de la déconnexion ?
            }
        });
        listenerThread.start();
    }

    // Traite une ligne JSON reçue du serveur
    private void handleReceivedJson(String jsonLine) {
        try {
            // Essayer de déterminer si c'est un Message ou un CallSignal (ou autre)
            // On peut regarder des champs clés ou utiliser une approche plus robuste
            if (jsonLine.contains("\"type\"") && (jsonLine.contains("\"senderUserId\"") || jsonLine.contains("\"encryptedContentBase64\""))) { // Heuristique simple pour Message
                Message message = objectMapper.readValue(jsonLine, Message.class);
                handleReceivedMessage(message);
            } else if (jsonLine.contains("\"type\"") && jsonLine.contains("\"sessionId\"")) { // Heuristique simple pour CallSignal
                CallSignal signal = objectMapper.readValue(jsonLine, CallSignal.class);
                if (callSignalConsumer != null) {
                    Platform.runLater(() -> callSignalConsumer.accept(signal));
                }
            }
             // Gérer d'autres types d'objets JSON si nécessaire (ex: UserStatusUpdate)
             else if (jsonLine.contains("\"online\"") && jsonLine.contains("\"userId\"")) { // Heuristique pour UserStatusUpdate
                 // Supposons une classe UserStatusUpdate comme dans l'exemple précédent
                 // UserStatusUpdate update = objectMapper.readValue(jsonLine, UserStatusUpdate.class);
                 // if (userStatusListener != null) {
                 //     Platform.runLater(() -> userStatusListener.updateUserStatus(update.getUserId(), update.isOnline()));
                 // }
                 System.out.println("Mise à jour de statut reçue (non traitée) : " + jsonLine);
             }
            else {
                System.out.println("JSON reçu non reconnu: " + jsonLine);
            }
        } catch (JsonProcessingException e) {
            System.err.println("Erreur de parsing JSON: " + e.getMessage() + " | JSON: " + jsonLine);
        } catch (Exception e) {
             System.err.println("Erreur traitement JSON reçu: " + e.getMessage() + " | JSON: " + jsonLine);
             e.printStackTrace();
        }
    }

    // Traite un objet Message désérialisé
    private void handleReceivedMessage(Message message) {
        System.out.println("Message reçu: " + message); // Log brut

        switch (message.getType()) {
            case PUBLIC_KEY_RESPONSE:
                handlePublicKeyResponse(message);
                break;
            case E2E_SESSION_INIT:
                handleSessionInit(message);
                break;
            case TEXT:
                // Vérifier si le message TEXT est chiffré ou non
                if (message.getEncryptedContent() != null) {
                    handleEncryptedTextMessage(message);
                } else if (message.getContent() != null && messageConsumer != null) {
                    // Message texte simple non chiffré (ou système)
                    Platform.runLater(() -> messageConsumer.accept(message));
                }
                break;
            case SYSTEM:
                // Afficher directement les messages système
                if (messageConsumer != null && message.getContent() != null) {
                     Platform.runLater(() -> messageConsumer.accept(message));
                }
                break;
            // Gérer les types MEDIA (pour l'instant, on les passe au consumer)
            case IMAGE:
            case VIDEO:
            case AUDIO:
            case DOCUMENT:
                 if (messageConsumer != null) {
                     // TODO: Gérer le téléchargement/déchiffrement E2EE des médias ici si nécessaire
                     Platform.runLater(() -> messageConsumer.accept(message));
                 }
                 break;
            default:
                System.out.println("Type de message non géré: " + message.getType());
        }
    }

    // --- Méthodes de traitement E2EE spécifiques ---

    private void handlePublicKeyResponse(Message message) {
        // Le contenu contient la clé publique en Base64
        String publicKeyString = message.getContent();
        long keyOwnerUserId = message.getSenderUserId(); // L'ID de l'utilisateur dont c'est la clé

        if (publicKeyString != null && !publicKeyString.isEmpty() && keyOwnerUserId > 0) {
            try {
                PublicKey publicKey = EncryptionUtils.stringToPublicKey(publicKeyString);
                keyManager.storeContactPublicKey(String.valueOf(keyOwnerUserId), publicKey); // Utiliser ID comme clé
                System.out.println("Clé publique pour ID " + keyOwnerUserId + " stockée.");
                // Informer l'UI ou déclencher une action (ex: réessayer d'envoyer un message en attente) ?
            } catch (Exception e) {
                System.err.println("Erreur conversion/stockage clé publique reçue pour ID " + keyOwnerUserId + ": " + e.getMessage());
            }
        } else {
             System.err.println("Réponse de clé publique invalide reçue: " + message);
        }
    }

    private void handleSessionInit(Message message) {
        // Ce message contient la clé de session RC4/AES, chiffrée avec NOTRE clé publique RSA
        byte[] encryptedSessionKey = message.getEncryptedContent(); // Vient de getEncryptedContentBase64 via Jackson
        long senderId = message.getSenderUserId();
        PrivateKey myPrivateKey = keyManager.getUserPrivateKey();

        if (encryptedSessionKey != null && senderId > 0 && myPrivateKey != null) {
            try {
                // Déchiffrer la clé de session avec notre clé privée RSA
                byte[] sessionKeyBytes = EncryptionUtils.decryptWithRsaPrivateKey(encryptedSessionKey, myPrivateKey);
                // Recréer la clé secrète (utiliser l'algo approprié)
                SecretKey sessionKey = new SecretKeySpec(sessionKeyBytes, "RC4"); // !! Changer pour AES !!

                // Stocker la clé de session associée à l'expéditeur (utiliser ID)
                keyManager.storeSessionKey(String.valueOf(senderId), sessionKey);
                System.out.println("Clé de session E2EE établie avec ID " + senderId);

                // Optionnel: Confirmer l'établissement de la session à l'autre client ?
                // Optionnel: Déclencher l'envoi de messages en attente ?

            } catch (Exception e) {
                System.err.println("Échec déchiffrement/stockage clé de session de ID " + senderId + ": " + e.getMessage());
                e.printStackTrace();
            }
        } else {
             System.err.println("Message d'initialisation de session invalide reçu: " + message);
        }
    }

    private void handleEncryptedTextMessage(Message message) {
        // Message texte chiffré avec la clé de session RC4/AES
        byte[] encryptedContent = message.getEncryptedContent();
        long senderId = message.getSenderUserId();
        SecretKey sessionKey = keyManager.getSessionKey(String.valueOf(senderId)); // Utiliser ID

        if (encryptedContent != null && senderId > 0 && sessionKey != null) {
            try {
                // Déchiffrer le contenu avec la clé de session
                byte[] decryptedBytes = EncryptionUtils.decryptWithRc4(encryptedContent, sessionKey); // !! Changer pour AES !!
                String decryptedContent = new String(decryptedBytes, StandardCharsets.UTF_8);

                // Créer un nouveau message (ou modifier l'existant) avec le contenu déchiffré
                // pour le passer au consumer standard de l'UI.
                Message decryptedMessage = new Message();
                decryptedMessage.setId(message.getId()); // Garder les métadonnées
                decryptedMessage.setSenderUserId(senderId);
                decryptedMessage.setReceiverUserId(message.getReceiverUserId());
                decryptedMessage.setGroupId(message.getGroupId());
                decryptedMessage.setTimestamp(message.getTimestamp());
                decryptedMessage.setStatus(message.getStatus());
                decryptedMessage.setType(MessageType.TEXT); // C'est redevenu un message texte simple
                decryptedMessage.setContent(decryptedContent); // Mettre le contenu déchiffré

                // Notifier l'UI avec le message déchiffré
                if (messageConsumer != null) {
                    Platform.runLater(() -> messageConsumer.accept(decryptedMessage));
                }

            } catch (Exception e) {
                System.err.println("Échec du déchiffrement du message de ID " + senderId + ": " + e.getMessage());
                // Afficher un message d'erreur dans l'UI ?
                Message errorMsg = createErrorMessage(message, "[Erreur de déchiffrement]");
                 if (messageConsumer != null) {
                     Platform.runLater(() -> messageConsumer.accept(errorMsg));
                 }
            }
        } else {
             System.err.println("Message texte chiffré invalide ou clé de session manquante pour ID " + senderId + ": " + message);
             Message errorMsg = createErrorMessage(message, "[Message illisible - Session E2EE non établie?]");
              if (messageConsumer != null) {
                  Platform.runLater(() -> messageConsumer.accept(errorMsg));
              }
        }
    }

    // Helper pour créer un message d'erreur à afficher dans l'UI
    private Message createErrorMessage(Message original, String errorText) {
         Message errorMsg = new Message();
         errorMsg.setId(original.getId());
         errorMsg.setSenderUserId(original.getSenderUserId());
         errorMsg.setReceiverUserId(original.getReceiverUserId());
         errorMsg.setGroupId(original.getGroupId());
         errorMsg.setTimestamp(original.getTimestamp());
         errorMsg.setStatus(original.getStatus());
         errorMsg.setType(MessageType.SYSTEM); // Marquer comme système/erreur
         errorMsg.setContent(errorText);
         return errorMsg;
    }


    // --- Méthodes utilitaires et existantes ---

    public void disconnect() { // Surcharge pour correspondre à l'appel dans ChatController
         // Pas besoin de envoyer LOGOUT ici si closeResources le fait via le finally du thread
         closeResources();
    }

    private void closeResources() {
         isRunning = false; // Arrêter la boucle d'écoute
         if (listenerThread != null) {
             listenerThread.interrupt(); // Interrompre le thread s'il est bloqué sur readLine
         }
         try {
             if (out != null) out.close();
         } catch (Exception e) { /* Ignorer */ }
         try {
             if (in != null) in.close();
         } catch (Exception e) { /* Ignorer */ }
         try {
             if (socket != null && !socket.isClosed()) socket.close();
         } catch (IOException e) { /* Ignorer */ }
         out = null;
         in = null;
         socket = null;
         listenerThread = null; // Permettre la recréation
         // Ne pas effacer userEmail/currentUserId ici, utile pour savoir qui était connecté
         System.out.println("Ressources réseau fermées.");
         // Effacer les clés de session ? Bonne pratique pour la sécurité.
         // keyManager.clearAllSessionKeys();
    }

    public boolean isConnected() {
        return socket != null && socket.isConnected() && !socket.isClosed() && isRunning;
    }

    // --- Méthodes pour la gestion des médias ---
    public File getMediaFile(final Message message) {
        if (!message.isMediaMessage()) {
            throw new IllegalArgumentException("Not a media message");
        }
        File file = fileService.getFile(message.getContent());
        System.out.println("Looking for media file at: " + file.getAbsolutePath());
        System.out.println("File exists: " + file.exists());
        return file;
    }

    // Adapter ces méthodes pour utiliser l'ID utilisateur (long)
    public Message createDirectMediaMessage(final String senderEmail, final String receiverEmail, final File mediaFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);
        final User receiver = userDAO.findUserByEmail(receiverEmail);

        // Detect file type and save the file
        final MessageType type = fileService.detectMessageType(mediaFile.getName());
        // relative path of the media
        final String filePath = fileService.saveFile(mediaFile, type, mediaFile.getName());
        final String mimeType = fileService.getMimeType(mediaFile);

        return Message.newDirectMediaMessage(
                sender.getId(),
                receiver.getId(),
                filePath,
                type,
                mediaFile.getName(),
                mediaFile.length(),
                mimeType);
    }

    public Message createGroupMediaMessage(final String senderEmail, final long groupId, final File mediaFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);

        // Detect file type and save the file
        final MessageType type = fileService.detectMessageType(mediaFile.getName());
        final String filePath = fileService.saveFile(mediaFile, type, mediaFile.getName());
        final String mimeType = fileService.getMimeType(mediaFile);

        return Message.newGroupMediaMessage(
                sender.getId(),
                groupId,
                filePath,
                type,
                mediaFile.getName(),
                mediaFile.length(),
                mimeType);
    }

    public Message createDirectAudioMessage(final String senderEmail, final String receiverEmail, final File audioFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);
        final User receiver = userDAO.findUserByEmail(receiverEmail);

        // Save the audio file
        final String filePath = fileService.saveFile(audioFile, MessageType.AUDIO, audioFile.getName());
        final String mimeType = fileService.getMimeType(audioFile);

        return Message.newDirectMediaMessage(
                sender.getId(),
                receiver.getId(),
                filePath,
                MessageType.AUDIO,
                audioFile.getName(),
                audioFile.length(),
                mimeType);
    }

    public Message createGroupAudioMessage(final String senderEmail, final long groupId, final File audioFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);

        // Save the audio file
        final String filePath = fileService.saveFile(audioFile, MessageType.AUDIO, audioFile.getName());
        final String mimeType = fileService.getMimeType(audioFile);

        return Message.newGroupMediaMessage(
                sender.getId(),
                groupId,
                filePath,
                MessageType.AUDIO,
                audioFile.getName(),
                audioFile.length(),
                mimeType);
    }

     // --- Méthodes pour les appels (existantes, adaptées pour JSON/ID) ---
     public CallSignal createCallRequest(CallSession session, String targetEmail) throws IOException {
         long targetId = userDAO.findUserByEmail(targetEmail).getId();
         return CallSignal.createCallRequest(session.getSessionId(), getCurrentUserId(), targetId);
     }
     public CallSignal createCallAccept(String sessionId, long targetUserId, int localPort) throws IOException {
         // L'IP locale peut être ajoutée ici ou côté serveur
         String localIp = socket.getLocalAddress().getHostAddress(); // Utiliser l'IP de la socket connectée
         return CallSignal.createCallAccept(sessionId, getCurrentUserId(), targetUserId, localIp, localPort);
     }
     public CallSignal createCallReject(String sessionId, long targetUserId) throws IOException {
         return CallSignal.createCallReject(sessionId, getCurrentUserId(), targetUserId);
     }
     public CallSignal createCallEnd(String sessionId, long targetUserId) throws IOException {
         return CallSignal.createCallEnd(sessionId, getCurrentUserId(), targetUserId);
     }

}


// File: src/main/java/org/example/client/gui/service/ContactService.java
package org.example.client.gui.service;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.dao.ContactDAO;
import org.example.shared.dao.UserDAO;
import org.example.shared.model.Contact;
import org.example.shared.model.User;

/**
 * Service dédié à la gestion des contacts.
 */
public class ContactService {

    private final UserDAO userDAO;
    private final ContactDAO contactDAO;
    private final UserService userService = new UserService();

    public ContactService() {
        this.userDAO = new UserDAO();
        this.contactDAO = new ContactDAO();
    }

    /**
     * Récupère la liste des emails des contacts
     */
    public List<String> getContacts(final String userEmail) throws IOException {
        final User user = userDAO.findUserByEmail(userEmail);
        if (user == null) {
            throw new IOException("Utilisateur non trouvé: " + userEmail);
        }
        return contactDAO.getContactsByUserId(user.getId());
    }

    /**
     * Récupère la liste des objets User complets pour les contacts
     */
    public List<User> getContactUsers(final String userEmail) throws IOException {
        final List<String> contactEmails = getContacts(userEmail);
        final List<User> users = new ArrayList<>();
        
        for (final String email : contactEmails) {
            final User user = userService.getUserByEmail(email);
            if (user != null) {
                users.add(user);
            }
        }
        
        return users;
    }

    /**
     * Ajoute un contact et retourne l'objet User correspondant
     */
    public User addContactUser(final String userEmail, final String contactEmail) throws IOException {
        final boolean added = addContact(userEmail, contactEmail);
        if (added) {
            return userService.getUserByEmail(contactEmail);
        }
        return null;
    }

    /**
     * Ajoute un contact par email
     */
    public boolean addContact(final String userEmail, final String contactEmail) throws IOException {
        final User user = userDAO.findUserByEmail(userEmail);
        final User contactUser = userDAO.findUserByEmail(contactEmail);

        if (user == null) {
            throw new IOException("Utilisateur non trouvé: " + userEmail);
        }
        if (contactUser == null) {
            throw new IOException("Contact non trouvé: " + contactEmail);
        }
        if (user.getId() == contactUser.getId()) {
            throw new IllegalArgumentException("Vous ne pouvez pas vous ajouter vous-même comme contact.");
        }

        final Contact first_Contact = new Contact(user.getId(), contactUser.getId());
        final Contact second_Contact = new Contact(contactUser.getId(), user.getId());


        contactDAO.createContact(first_Contact);
        contactDAO.createContact(second_Contact);
        return true;
    }

    /**
     * Supprime un contact
     */
    public boolean removeContact(final String userEmail, final String contactEmail) throws IOException {
        final User user = userDAO.findUserByEmail(userEmail);
        final User contactUser = userDAO.findUserByEmail(contactEmail);

        if (user == null) {
            throw new IOException("Utilisateur non trouvé: " + userEmail);
        }
        if (contactUser == null) {
            return false;
        }

        return contactDAO.deleteContact(user.getId(), contactUser.getId());
    }

    /**
     * Vérifie si un utilisateur est en ligne.
     */
    public boolean isUserOnline(final long userId) throws IOException {
        final User user = userService.getUserById(userId);
        if (user == null) {
            throw new IOException("Utilisateur non trouvé avec l'ID: " + userId);
        }
        return user.isOnline();
    }
}



// File: src/main/java/org/example/client/gui/service/FileService.java
package org.example.client.gui.service;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

import org.example.shared.model.Message;
import org.example.shared.model.enums.MessageType;

/**
 * Service for handling file operations for multimedia messages.
 */
public class FileService {

    // Base directory for storing media files
    private static final String MEDIA_DIR = System.getProperty("user.dir") + File.separator +
            "media_files";

    // Subdirectories for different media types
    private static final String IMAGES_DIR = MEDIA_DIR + File.separator + "images";
    private static final String VIDEOS_DIR = MEDIA_DIR + File.separator + "videos";
    private static final String DOCUMENTS_DIR = MEDIA_DIR + File.separator + "documents";
    private static final String AUDIO_DIR = MEDIA_DIR + File.separator + "audio";

    // Maximum file size (20MB)
    private static final long MAX_FILE_SIZE = 20 * 1024 * 1024;

    /**
     * Constructor - creates necessary directories if they don't exist.
     */
    public FileService() {
        createDirectories();
    }

    /**
     * Creates all necessary directories for storing media files.
     */

    private void createDirectories() {
        try {
            File mediaDir = new File(MEDIA_DIR);
            if (!mediaDir.exists()) {
                boolean created = mediaDir.mkdirs();
                System.out.println("Created main media directory: " + created + " at " + mediaDir.getAbsolutePath());
            } else {
                System.out.println("Main media directory already exists at: " + mediaDir.getAbsolutePath());
            }

            // Create each subdirectory individually and log results
            File imagesDir = new File(IMAGES_DIR);
            if (!imagesDir.exists()) {
                boolean created = imagesDir.mkdirs();
                System.out.println("Created images directory: " + created + " at " + imagesDir.getAbsolutePath());
            } else {
                System.out.println("Images directory already exists at: " + imagesDir.getAbsolutePath());
            }

            File videosDir = new File(VIDEOS_DIR);
            if (!videosDir.exists()) {
                boolean created = videosDir.mkdirs();
                System.out.println("Created videos directory: " + created + " at " + videosDir.getAbsolutePath());
            } else {
                System.out.println("Videos directory already exists at: " + videosDir.getAbsolutePath());
            }

            File documentsDir = new File(DOCUMENTS_DIR);
            if (!documentsDir.exists()) {
                boolean created = documentsDir.mkdirs();
                System.out.println("Created documents directory: " + created + " at " + documentsDir.getAbsolutePath());
            } else {
                System.out.println("Documents directory already exists at: " + documentsDir.getAbsolutePath());
            }

            File audioDir = new File(AUDIO_DIR);
            if (!audioDir.exists()) {
                boolean created = audioDir.mkdirs();
                System.out.println("Created audio directory: " + created + " at " + audioDir.getAbsolutePath());
            } else {
                System.out.println("Audio directory already exists at: " + audioDir.getAbsolutePath());
            }

            // Log summary
            System.out.println("Directory structure setup complete. Media files will be stored in: " + MEDIA_DIR);
        } catch (Exception e) {
            System.err.println("Error creating directories: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Saves a file to the appropriate directory and returns the path where it was saved.
     */
    public String saveFile(File file, MessageType type, String originalFilename) throws IOException {
        System.out.println("//// Saving file of type " + type);
        // Check file size
        if (file.length() > MAX_FILE_SIZE) {
            throw new IllegalArgumentException("File is too large. Maximum size is " +
                    (MAX_FILE_SIZE / (1024 * 1024)) + "MB");
        }

        // Get the appropriate directory
        String directory;
        switch (type) {
            case IMAGE:
                directory = IMAGES_DIR;
                break;
            case VIDEO:
                directory = VIDEOS_DIR;
                break;
            case DOCUMENT:
                directory = DOCUMENTS_DIR;
                break;
            case AUDIO:
                directory = AUDIO_DIR;
                break;
            default:
                throw new IllegalArgumentException("Invalid file type: " + type);
        }

        // Generate a unique filename to avoid collisions
        String fileExtension = getFileExtension(originalFilename);
        String uniqueFilename = UUID.randomUUID().toString() + fileExtension;
        String fullPath = directory + File.separator + uniqueFilename;

        System.out.println("Full path for saving: " + fullPath);

        // Copy the file
        try (InputStream in = new FileInputStream(file);
             OutputStream out = new FileOutputStream(fullPath)) {
            byte[] buffer = new byte[4096];
            int length;
            while ((length = in.read(buffer)) > 0) {
                out.write(buffer, 0, length);
            }
        }

        // IMPORTANT: Always use the same separator character (/) for storage in the database
        // We'll handle the platform-specific conversion when retrieving the file
        return type.name().toLowerCase() + "/" + uniqueFilename;
    }

    /**
     * Gets the full path to a media file from its relative path.
     */
    public File getFile(String relativePath) {
        if (relativePath == null || relativePath.isEmpty()) {
            throw new IllegalArgumentException("Relative path cannot be null or empty");
        }

        // Debug the input path
        System.out.println("Original relative path: " + relativePath);

        // Split the path into type and filename
        String[] parts = relativePath.split("/");
        if (parts.length < 2) {
            parts = relativePath.split("\\\\"); // Try Windows separator
        }

        // If we can't split, use the raw path (suboptimal but better than failing)
        if (parts.length < 2) {
            System.out.println("Warning: Cannot split path properly: " + relativePath);
            String normalizedPath = relativePath.replace('/', File.separatorChar).replace('\\', File.separatorChar);
            File file = new File(MEDIA_DIR + File.separator + normalizedPath);
            System.out.println("Falling back to direct path: " + file.getAbsolutePath());
            return file;
        }

        String typeDir = parts[0];
        String filename = parts[1];

        // Construct proper directory based on media type
        String typeDirectory;
        switch (typeDir.toLowerCase()) {
            case "image":
                typeDirectory = IMAGES_DIR;
                break;
            case "video":
                typeDirectory = VIDEOS_DIR;
                break;
            case "document":
                typeDirectory = DOCUMENTS_DIR;
                break;
            case "audio":
                typeDirectory = AUDIO_DIR;
                break;
            default:
                // Fallback to base directory with the original relative path
                System.out.println("Unknown media type: " + typeDir);
                String normalizedPath = relativePath.replace('/', File.separatorChar).replace('\\', File.separatorChar);
                File file = new File(MEDIA_DIR + File.separator + normalizedPath);
                System.out.println("Falling back to direct path: " + file.getAbsolutePath());
                return file;
        }

        // Construct the full path
        File file = new File(typeDirectory + File.separator + filename);
        System.out.println("Getting media file at: " + file.getAbsolutePath());
        System.out.println("File exists: " + file.exists());

        return file;
    }
    /**
     * Detects the message type based on the file extension.
     *
     * @param filename The name of the file
     * @return The detected message type
     */
    public MessageType detectMessageType(String filename) {
        String extension = getFileExtension(filename).toLowerCase();

        // Image formats
        if (extension.matches("\\.(jpg|jpeg|png|gif|bmp|webp)$")) {
            return MessageType.IMAGE;
        }

        // Video formats
        if (extension.matches("\\.(mp4|avi|mov|wmv|flv|mkv|webm)$")) {
            return MessageType.VIDEO;
        }

        // Audio formats
        if (extension.matches("\\.(mp3|wav|ogg|aac|wma|flac)$")) {
            return MessageType.AUDIO;
        }

        // Default to document for all other types
        return MessageType.DOCUMENT;
    }

    /**
     * Gets the MIME type for a file.
     *
     * @param file The file
     * @return The MIME type
     */
    public String getMimeType(File file) throws IOException {
        return Files.probeContentType(file.toPath());
    }

    /**
     * Gets the file extension from a filename.
     *
     * @param filename The filename
     * @return The file extension (including the dot)
     */
    private String getFileExtension(String filename) {
        int lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex >= 0) {
            return filename.substring(lastDotIndex);
        }
        return "";
    }

    /**
     * Deletes a file if it exists.
     *
     * @param relativePath The relative path to the file
     * @return true if the file was deleted, false otherwise
     */
    public boolean deleteFile(String relativePath) {
        File file = getFile(relativePath);
        if (file.exists()) {
            return file.delete();
        }
        return false;
    }
}


// File: src/main/java/org/example/client/gui/service/GroupService.java
package org.example.client.gui.service;

import java.io.IOException;
import java.util.List;

import org.example.shared.dao.GroupDAO;
import org.example.shared.dao.GroupMembershipDAO;
import org.example.shared.model.Group;
import org.example.shared.model.GroupMembership;

public class GroupService {

    private final GroupDAO groupDAO;
    private final GroupMembershipDAO groupMembershipDAO;

    public GroupService() {
        this.groupDAO = new GroupDAO();
        this.groupMembershipDAO = new GroupMembershipDAO();
    }

    public Group createGroup(final String groupName, final long ownerUserId) {
        final Group group = new Group(groupName, ownerUserId); // constructeur qui initialise aussi createdAt
        groupDAO.createGroup(group);
        if (group.getId() > 0) {
            final GroupMembership membership = new GroupMembership(ownerUserId, group.getId());
            groupMembershipDAO.createGroupMembership(membership);
        }
        return group;
    }

    public boolean addMemberToGroup(final long groupId, final long userId) {
        if (groupMembershipDAO.findGroupMembership(userId, groupId) == null) {
            final GroupMembership membership = new GroupMembership(userId, groupId);
            groupMembershipDAO.createGroupMembership(membership);
            return true;
        }
        return false;
    }
    
    public List<Group> getGroupsForUser(final long userId) throws IOException {
        return groupDAO.getGroupsForUser(userId);
    }

    /**
     * Récupère les identifiants des membres d'un groupe
     */
    public List<Long> getMembersForGroup(final long groupId) {
        return groupDAO.getMembersForGroup(groupId);
    }

    /**
     * Supprime un membre d'un groupe
     */
    public boolean removeMemberFromGroup(final long groupId, final long userId) {
        return groupMembershipDAO.removeGroupMembership(userId, groupId);
    }
}



// File: src/main/java/org/example/client/gui/service/UserService.java
package org.example.client.gui.service;

import java.io.IOException;

import org.example.shared.dao.UserDAO;
import org.example.shared.model.User;

/**
 * Service pour gérer les utilisateurs avec cache
 */
public class UserService {
    private final UserDAO userDAO;

    public UserService() {
        this.userDAO = new UserDAO();
    }
    
    /**
     * Récupère un utilisateur par email 
     */
    public User getUserByEmail(final String email) throws IOException {
        if (email == null || email.trim().isEmpty()) {
            throw new IllegalArgumentException("L'email ne peut pas être vide");
        }
        
        // Sinon, interroger la base de données
        final User user = userDAO.findUserByEmail(email);
        if (user == null) {
            throw new IOException("Utilisateur non trouvé: " + email);
        }
        
        return user;
    }
    
    /**
     * Récupère un utilisateur par ID
     */
    public User getUserById(final long userId) throws IOException {
        if (userId <= 0) {
            throw new IllegalArgumentException("L'ID utilisateur doit être positif");
        }
        
        // Sinon, interroger la base de données
        final User user = userDAO.findUserById(userId);
        if (user == null) {
            throw new IOException("Utilisateur non trouvé avec l'ID: " + userId);
        }
        
        return user;
    }
    
    /**
     * Met à jour un utilisateur dans la base de données et le cache
     */
    public void updateUser(final User user) throws IOException {
        if (user == null) {
            throw new IllegalArgumentException("L'utilisateur ne peut pas être null");
        }
        
        userDAO.updateUser(user);
    }
}



// File: src/main/java/org/example/server/broker/MessageBroker.java
package org.example.server.broker;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;

import org.example.server.ClientHandler;
import org.example.server.UdpCallServer;
import org.example.shared.dao.GroupDAO;
import org.example.shared.dao.MessageDAO;
import org.example.shared.model.CallSignal;
import org.example.shared.model.Message;
import org.example.shared.model.enums.MessageStatus;

public class MessageBroker {
    private static MessageBroker instance;
    private final Map<Long, MessageQueue> userQueues;
    private final MessageDAO messageDAO;
    final GroupDAO groupDAO;

    public static synchronized MessageBroker getInstance() {
        if (instance == null) {
            instance = new MessageBroker();
        }
        return instance;
    }

    private MessageBroker() {
        this.userQueues = new ConcurrentHashMap<>();
        this.messageDAO = new MessageDAO();
        this.groupDAO = new GroupDAO();
    }

    public void registerListener(final long userId, final ClientHandler listener) {
        final MessageQueue queue = getOrCreateQueue(userId);
        queue.setListener(listener);
        queue.loadPersistedMessages();
        queue.deliverPendingMessages();
    }

    public void unregisterListener(final long userId) {
        final MessageQueue queue = userQueues.remove(userId);
        if (queue != null) {
            queue.setListener(null);
            queue.clearQueue();
        }
    }

    public void sendMessage(final Message message) {
        if (message.isGroupMessage()) {
            final List<Long> groupMemberIds = groupDAO.getMembersForGroup(message.getGroupId());
            for (final Long memberId : groupMemberIds) {
                // Ignorer l'expéditeur
                if (!memberId.equals(message.getSenderUserId())) {
                    final MessageQueue queue = getOrCreateQueue(memberId);
                    // Créer une copie du message pour ce destinataire
                    Message messageForRecipient = Message.copyForReceiver(message, memberId);
                    // Essayer de délivrer et, si ça échoue, persister le message
                    if (!queue.tryDeliver(messageForRecipient)) {
                        persistMessage(messageForRecipient);
                    } else {
                        messageForRecipient.setStatus(MessageStatus.DELIVERED);
                    }
                }
            }
        } else {
            final MessageQueue queue = userQueues.get(message.getReceiverUserId());
            if (queue != null && queue.tryDeliver(message)) {
                message.setStatus(MessageStatus.DELIVERED);
            } else {
                persistMessage(message);
            }
        }
    }

    /**
     * Achemine un signal d'appel vers le destinataire approprié.
     * 
     * @param signal Le signal d'appel à acheminer
     */
    public void routeCallSignal(final CallSignal signal) {
        try {
            // Traiter les signaux selon leur type
            switch (signal.getType()) {
                case CALL_REQUEST:
                    // Enregistrer la session d'appel dans le serveur UDP pour un éventuel relais
                    UdpCallServer.getInstance().registerSession(signal.getSessionId());
                    // Transmettre la demande d'appel au destinataire
                    deliverCallSignal(signal.getReceiverUserId(), signal);
                    break;

                case CALL_ACCEPT:
                    // Enregistrer le point de terminaison du destinataire dans le serveur UDP
                    UdpCallServer.getInstance().registerEndpoint(
                            signal.getSessionId(),
                            false,
                            java.net.InetAddress.getByName(signal.getIpAddress()),
                            signal.getPort());
                    // Transmettre l'acceptation à l'appelant
                    deliverCallSignal(signal.getReceiverUserId(), signal);
                    break;

                case CALL_REJECT:
                case CALL_BUSY:
                    // Supprimer la session d'appel du serveur UDP
                    UdpCallServer.getInstance().removeSession(signal.getSessionId());
                    // Transmettre le rejet à l'appelant
                    deliverCallSignal(signal.getReceiverUserId(), signal);
                    break;

                case CALL_END:
                    // Supprimer la session d'appel du serveur UDP
                    UdpCallServer.getInstance().removeSession(signal.getSessionId());
                    // Transmettre la fin d'appel à l'autre partie
                    deliverCallSignal(signal.getReceiverUserId(), signal);
                    break;
            }
        } catch (final Exception e) {
            System.err.println("Erreur lors du routage du signal d'appel: " + e.getMessage());
        }
    }

    /**
     * Délivre un signal d'appel à un utilisateur spécifique.
     * 
     * @param userId L'ID de l'utilisateur destinataire
     * @param signal Le signal d'appel à délivrer
     */
    private void deliverCallSignal(final long userId, final CallSignal signal) {
        final MessageQueue queue = userQueues.get(userId);
        if (queue != null) {
            queue.tryDeliverCallSignal(signal);
        }
    }

    private void persistMessage(final Message message) {
        message.setStatus(MessageStatus.QUEUED);
        try {
            messageDAO.createMessage(message);
        } catch (final Exception e) {
            System.err.println("Failed to queue message: " + e.getMessage());
        }
    }

    private MessageQueue getOrCreateQueue(final long userId) {
        return userQueues.computeIfAbsent(userId, MessageQueue::new);
    }

    private class MessageQueue {
        private final long userId;
        private final BlockingQueue<Message> messages;
        private ClientHandler listener;

        MessageQueue(final long userId) {
            this.userId = userId;
            this.messages = new LinkedBlockingQueue<>();
        }

        synchronized void setListener(final ClientHandler listener) {
            this.listener = listener;
        }

        void addMessageToQueue(final Message message) {
            messages.offer(message);
        }

        synchronized void clearQueue() {
            messages.clear();
        }

        synchronized void loadPersistedMessages() {
            try {
                final List<Message> pendingMessages = messageDAO.getPendingMessagesForUser(userId);
                pendingMessages.forEach(this::addMessageToQueue);
            } catch (final Exception e) {
                System.err.println("Error reloading persisted messages for user " + userId + ": " + e.getMessage());
            }
        }

        boolean tryDeliver(final Message message) {
            if (listener != null) {
                try {
                    listener.onMessageReceived(message);
                    return true;
                } catch (final IOException e) {
                    System.err.println("Delivery failed for message " + message.getId());
                }
            }
            return false;
        }

        /**
         * Tente de délivrer un signal d'appel au client.
         * 
         * @param signal Le signal d'appel à délivrer
         * @return true si la livraison a réussi
         */
        boolean tryDeliverCallSignal(final CallSignal signal) {
            if (listener != null) {
                try {
                    listener.onCallSignalReceived(signal);
                    return true;
                } catch (final IOException e) {
                    System.err.println("Delivery failed for call signal to user " + userId);
                }
            }
            return false;
        }

        void deliverPendingMessages() {
            int initialSize = messages.size();
            for (int i = 0; i < initialSize; i++) {
                Message message = messages.poll();
                if (message == null) {
                    break;
                }
                if (tryDeliver(message)) {
                    try {
                        messageDAO.deleteMessage(message.getId());
                    } catch (Exception e) {
                        System.err.println("Failed to delete message " + message.getId() + ", re-adding to queue");
                        messages.offer(message);
                    }
                } else {
                    messages.offer(message);
                }
            }
        }
    }
}


// File: src/main/java/org/example/server/ChatServer.java
package org.example.server;

import java.net.ServerSocket;
import java.net.Socket;

public class ChatServer {
    private static final int PORT = 5000;
    public static void main(final String[] args) throws Exception {
        // Démarrer le serveur UDP pour les appels audio
        UdpCallServer.getInstance().start();
        
        final ServerSocket server = new ServerSocket(PORT);
        System.out.println("Server TCP started on port " + PORT);
        System.out.println("Waiting for clients...");

        while (true) {
            final Socket client = server.accept();
            final ClientHandler clientHandler = new ClientHandler(client);
            new Thread(clientHandler).start();
        }
    }
}


// File: src/main/java/org/example/server/ClientHandler.java
package org.example.server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.Optional;

import org.example.server.broker.MessageBroker;
import org.example.shared.dao.UserDAO;
import org.example.shared.dto.Credentials;
import org.example.shared.dto.RegistrationDTO;
import org.example.shared.model.CallSignal;
import org.example.shared.model.Message;
import org.example.shared.model.User;
import org.example.shared.model.enums.MessageType;
import org.example.shared.util.PasswordUtils;
import org.example.shared.util.ValidationUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final MessageBroker broker;
    private final UserDAO userDAO;
    private final ObjectMapper mapper;
    private final ServerFileService fileService;

    private String clientEmail;
    private long clientId;
    private PrintWriter output;
    private BufferedReader input;
    private volatile boolean isConnected;

    public ClientHandler(final Socket socket) {
        this.clientSocket = socket;
        this.broker = MessageBroker.getInstance();
        this.userDAO = new UserDAO();
        this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
        this.fileService = new ServerFileService();
    }

    @Override
    public void run() {
        try (
                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream(), StandardCharsets.UTF_8));
                PrintWriter out = new PrintWriter(new OutputStreamWriter(clientSocket.getOutputStream(), StandardCharsets.UTF_8), true)) {
            this.input = in;
            this.output = out;

            final String requestType = input.readLine();
            if (requestType == null) return;

            if ("REGISTER".equals(requestType)) {
                handleRegistration();
                return;
            } else if ("LOGIN".equals(requestType)) {
                if (!authenticateUser()) {
                    sendResponse("AUTH_FAILED");
                    return;
                }
                sendResponse("AUTH_SUCCESS");

                handleUserLogin(clientEmail);
                initializeSubscription();
                processMessages();
            } else {
                System.out.println("Unknown request type: " + requestType);
                sendResponse("UNKNOWN_REQUEST_TYPE");
                return;
            }
        } catch (final IOException e) {
            System.out.println("Client connection error for " + (clientEmail != null ? clientEmail : clientSocket.getInetAddress()) + ": " + e.getMessage());
        } finally {
            cleanup();
        }
    }

    private void handleRegistration() throws IOException {
        try {
            final RegistrationDTO registrationDTO = mapper.readValue(input.readLine(), RegistrationDTO.class);

            if (!ValidationUtils.isValidEmail(registrationDTO.getEmail())) {
                sendResponse("Invalid email format");
                return;
            }

            if (!ValidationUtils.isStrongPassword(registrationDTO.getPassword())) {
                sendResponse("Password does not meet security criteria");
                return;
            }

            if (!ValidationUtils.doPasswordsMatch(registrationDTO.getPassword(), registrationDTO.getPasswordConfirmation())) {
                sendResponse("Passwords do not match");
                return;
            }

            final User existingUser = userDAO.findUserByEmail(registrationDTO.getEmail());
            if (existingUser != null) {
                sendResponse("REGISTER_FAILURE_EMAIL_EXISTS");
                return;
            }

            final User newUser = new User();
            newUser.setEmail(registrationDTO.getEmail());
            newUser.setDisplayName(registrationDTO.getEmail().split("@")[0]);
            newUser.setPasswordHash(PasswordUtils.hashPassword(registrationDTO.getPassword()));
            newUser.setCreatedAt(LocalDateTime.now());
            newUser.setOnline(false);

            userDAO.createUser(newUser);

            sendResponse("REGISTER_SUCCESS");
        } catch (final Exception e) {
            System.out.println("Registration error: " + e.getMessage());
            e.printStackTrace();
            sendResponse("Registration error: " + e.getMessage());
        }
    }

    private boolean authenticateUser() throws IOException {
        final String jsonCredentials = input.readLine();
        if (jsonCredentials == null) return false;

        try {
            final Credentials credentials = mapper.readValue(jsonCredentials, Credentials.class);
            final User user = userDAO.findUserByEmail(credentials.getEmail());
            if (user != null && PasswordUtils.verifyPassword(credentials.getPassword(), user.getPasswordHash())) {
                this.clientEmail = user.getEmail();
                this.clientId = user.getId();
                System.out.println("Authentication successful for " + clientEmail + " (ID: " + clientId + ")");
                return true;
            } else {
                System.out.println("Authentication failed for " + credentials.getEmail());
                return false;
            }
        } catch (final JsonProcessingException e) {
            System.err.println("Error parsing JSON credentials: " + e.getMessage());
            sendResponse("AUTH_ERROR_FORMAT");
            return false;
        } catch (final Exception e) {
            System.err.println("Error during authentication: " + e.getMessage());
            sendResponse("AUTH_ERROR_SERVER");
            e.printStackTrace();
            return false;
        }
    }

    private void initializeSubscription() throws IOException {
        broker.registerListener(clientId, this);
        isConnected = true;
    }

    private void processMessages() throws IOException {
        String jsonData;
        while (isConnected && (jsonData = input.readLine()) != null) {
            try {
                // Vérifier d'abord si c'est un signal d'appel basé sur le JSON brut
                if (jsonData.contains("\"type\":\"CALL_")) {
                    final CallSignal signal = mapper.readValue(jsonData, CallSignal.class);
                    broker.routeCallSignal(signal);
                    continue; // Passer au prochain message après avoir traité le signal d'appel
                }

                // Si ce n'est pas un signal d'appel, traiter comme un Message normal
                final Message message = mapper.readValue(jsonData, Message.class);
                message.setSenderUserId(this.clientId);

                // Vérifier si c'est un message de déconnexion par son contenu
                if ("LOGOUT".equalsIgnoreCase(message.getContent()) && message.getType() == MessageType.SYSTEM) {
                    handleUserLogout(clientEmail);
                    terminateSession();
                    sendResponse("LOGOUT_SUCCESS");
                    return;
                }

                // Gérer les autres types de messages via le switch
                switch (message.getType()) {
                    case PUBLIC_KEY_REQUEST:
                        handlePublicKeyRequest(message);
                        break;
                    case PUBLIC_KEY_RESPONSE:
                        handleClientPublicKeyUpdate(message);
                        break;
                    case E2E_SESSION_INIT:
                    case TEXT:
                    case IMAGE:
                    case VIDEO:
                    case AUDIO:
                    case DOCUMENT:
                        if (message.isMediaMessage()) {
                            processMediaMessage(message);
                        }
                        broker.sendMessage(message);
                        break;
                    case SYSTEM:
                        System.out.println("SYSTEM message received from client ID " + message.getSenderUserId() + " (content: " + message.getContent() + ") - Ignored unless LOGOUT.");
                        break;
                    default:
                        System.out.println("Unknown or unhandled message type received: " + message.getType());
                }
            } catch (final JsonProcessingException e) {
                System.err.println("Error parsing JSON from " + clientEmail + ": " + e.getMessage() + " | JSON: " + jsonData);
            } catch (final IOException e) {
                System.err.println("IO error processing message from " + clientEmail + ": " + e.getMessage());
                throw e;
            } catch (final Exception e) {
                System.err.println("Unexpected error processing message from " + clientEmail + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    private void processMediaMessage(final Message message) {
        try {
            fileService.ensureMediaDirectoriesExist();
            System.out.println("Processing media message: " + message.getType() +
                    ", File: " + (message.getFileName() != null ? message.getFileName() : "Unknown"));
        } catch (final Exception e) {
            System.err.println("Error processing media message: " + e.getMessage());
        }
    }

    private void handlePublicKeyRequest(final Message requestMessage) {
        try {
            final long targetUserId = Long.parseLong(requestMessage.getContent());
            final long requesterUserId = requestMessage.getSenderUserId();

            System.out.println("Public key request for ID " + targetUserId + " by ID " + requesterUserId);

            final Optional<String> publicKeyOpt = userDAO.getPublicKey(targetUserId);

            if (publicKeyOpt.isPresent() && publicKeyOpt.get() != null && !publicKeyOpt.get().isEmpty()) {
                final Message response = new Message();
                response.setType(MessageType.PUBLIC_KEY_RESPONSE);
                response.setSenderUserId(targetUserId);
                response.setReceiverUserId(requesterUserId);
                response.setContent(publicKeyOpt.get());
                response.setTimestamp(LocalDateTime.now());

                sendMessageToClient(response);
                System.out.println("Public key for ID " + targetUserId + " sent to ID " + requesterUserId);
            } else {
                System.out.println("Public key not found or empty for ID " + targetUserId);
            }
        } catch (final NumberFormatException e) {
            System.err.println("Invalid target ID in PUBLIC_KEY_REQUEST from ID " + requestMessage.getSenderUserId() + ": " + requestMessage.getContent());
        } catch (final Exception e) {
            System.err.println("Error processing PUBLIC_KEY_REQUEST from ID " + requestMessage.getSenderUserId() + ": " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleClientPublicKeyUpdate(final Message message) {
        final String publicKeyString = message.getContent();
        final long senderId = message.getSenderUserId();

        if (senderId != this.clientId) {
            System.err.println("Attempt to update public key by ID " + senderId + " for connected client ID " + this.clientId + ". Ignored.");
            return;
        }

        if (publicKeyString != null && !publicKeyString.isEmpty()) {
            final boolean success = userDAO.updatePublicKey(this.clientId, publicKeyString);
            if (success) {
                System.out.println("Public key stored/updated for ID " + this.clientId);
            } else {
                System.err.println("Failed to store public key for ID " + this.clientId);
            }
        } else {
            System.err.println("Empty public key received from ID " + this.clientId);
        }
    }

    public void sendMessageToClient(final Message message) {
        if (output != null && !clientSocket.isClosed() && isConnected) {
            try {
                final String jsonMessage = mapper.writeValueAsString(message);
                output.println(jsonMessage);
            } catch (final JsonProcessingException e) {
                System.err.println("Error serializing JSON for direct send to ID " + clientId + ": " + e.getMessage());
            } catch (final Exception e) {
                System.err.println("Unknown error during direct send to ID " + clientId + ": " + e.getMessage());
            }
        } else {
            System.err.println("Attempt to send direct message to disconnected or uninitialized client (ID: " + clientId + ")");
        }
    }

    public void onMessageReceived(final Message message) throws IOException {
        sendMessageToClient(message);
    }

    public void onCallSignalReceived(final CallSignal signal) throws IOException {
        if (output != null && !clientSocket.isClosed() && isConnected) {
            try {
                final String jsonSignal = mapper.writeValueAsString(signal);
                output.println(jsonSignal);
            } catch (final JsonProcessingException e) {
                System.err.println("Error serializing JSON for call signal to ID " + clientId + ": " + e.getMessage());
            } catch (final Exception e) {
                System.err.println("Unknown error during call signal send to ID " + clientId + ": " + e.getMessage());
            }
        } else {
            System.err.println("Attempt to send call signal to disconnected or uninitialized client (ID: " + clientId + ")");
        }
    }

    private void sendResponse(final String response) {
        if (output != null) {
            output.println(response);
        }
    }

    private void terminateSession() {
        isConnected = false;
    }

    private void cleanup() {
        if (!isConnected) {
            return;
        }
        isConnected = false;
        System.out.println("Cleanup for " + (clientEmail != null ? clientEmail : clientSocket.getInetAddress()));

        if (clientId > 0) {
            broker.unregisterListener(clientId);
            handleUserLogout(clientEmail);
        }

        try {
            if (input != null) input.close();
        } catch (final IOException e) { }
        if (output != null) output.close();
        try {
            if (clientSocket != null && !clientSocket.isClosed()) clientSocket.close();
        } catch (final IOException e) { }
        System.out.println("Resources closed for " + (clientEmail != null ? clientEmail : "unauthenticated client"));
    }

    public void handleUserLogin(final String email) {
        try {
            final User user = userDAO.findUserByEmail(email);
            if (user != null) {
                user.setOnline(true);
                final boolean success = userDAO.updateUser(user);
                if (!success) {
                    System.err.println("Failed to update online status for: " + email);
                }
            }
        } catch (final Exception e) {
            System.err.println("Error updating online status: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void handleUserLogout(final String email) {
        try {
            final User user = userDAO.findUserByEmail(email);
            if (user != null) {
                user.setOnline(false);
                final boolean success = userDAO.updateUser(user);
                if (!success) {
                    System.err.println("Failed to update offline status for: " + email);
                }
            }
        } catch (final Exception e) {
            System.err.println("Error updating offline status: " + e.getMessage());
            e.printStackTrace();
        }
    }
}


// File: src/main/java/org/example/server/ServerFileService.java
package org.example.server;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

import org.example.shared.model.enums.MessageType;

/**
 * Service for handling file operations on the server side.
 */
public class ServerFileService {

    // Base directory for storing media files
    private static final String MEDIA_DIR = System.getProperty("user.dir") + File.separator +
            "media_files";

    // Subdirectories for different media types
    private static final String IMAGES_DIR = MEDIA_DIR + File.separator + "images";
    private static final String VIDEOS_DIR = MEDIA_DIR + File.separator + "videos";
    private static final String DOCUMENTS_DIR = MEDIA_DIR + File.separator + "documents";
    private static final String AUDIO_DIR = MEDIA_DIR + File.separator + "audio";

    /**
     * Creates all necessary directories for storing media files.
     */
    public void ensureMediaDirectoriesExist() throws IOException {
        Files.createDirectories(Paths.get(IMAGES_DIR));
        Files.createDirectories(Paths.get(VIDEOS_DIR));
        Files.createDirectories(Paths.get(DOCUMENTS_DIR));
        Files.createDirectories(Paths.get(AUDIO_DIR));
    }

    /**
     * Gets the full path to a media file from its relative path.
     *
     * @param relativePath The relative path stored in the message
     * @return The full path to the file
     */
    public File getFile(String relativePath) {
        return new File(MEDIA_DIR + File.separator + relativePath);
    }

    /**
     * Saves a file to the appropriate directory and returns the path where it was saved.
     *
     * @param inputStream The input stream of the file
     * @param type The type of media
     * @param originalFilename The original filename
     * @return The path where the file was saved (relative to the media directory)
     * @throws IOException If an I/O error occurs
     */
    public String saveFile(InputStream inputStream, MessageType type, String originalFilename) throws IOException {
        // Get the appropriate directory
        String directory;
        switch (type) {
            case IMAGE:
                directory = IMAGES_DIR;
                break;
            case VIDEO:
                directory = VIDEOS_DIR;
                break;
            case DOCUMENT:
                directory = DOCUMENTS_DIR;
                break;
            case AUDIO:
                directory = AUDIO_DIR;
                break;
            default:
                throw new IllegalArgumentException("Invalid file type: " + type);
        }

        // Generate a unique filename to avoid collisions
        String fileExtension = getFileExtension(originalFilename);
        String uniqueFilename = UUID.randomUUID().toString() + fileExtension;
        String fullPath = directory + File.separator + uniqueFilename;

        // Save the file
        try (FileOutputStream fos = new FileOutputStream(fullPath)) {
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                fos.write(buffer, 0, bytesRead);
            }
        }

        // Return the relative path to be stored in the message
        return type.name().toLowerCase() + "/" + uniqueFilename;
    }

    /**
     * Gets the file extension from a filename.
     *
     * @param filename The filename
     * @return The file extension (including the dot)
     */
    private String getFileExtension(String filename) {
        int lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex >= 0) {
            return filename.substring(lastDotIndex);
        }
        return "";
    }

    /**
     * Deletes a file if it exists.
     *
     * @param relativePath The relative path to the file
     * @return true if the file was deleted, false otherwise
     */
    public boolean deleteFile(String relativePath) {
        File file = getFile(relativePath);
        if (file.exists()) {
            return file.delete();
        }
        return false;
    }
}


// File: src/main/java/org/example/server/UdpCallServer.java
package org.example.server;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Serveur UDP pour relayer les paquets audio entre clients.
 * Utilisé comme solution de secours quand la connexion directe entre clients échoue.
 */
public class UdpCallServer {
    private static final int UDP_PORT = 5001;
    private static final int BUFFER_SIZE = 4096;
    
    private DatagramSocket socket;
    private final ExecutorService threadPool;
    private final Map<String, CallSession> activeSessions;
    private volatile boolean running;
    
    // Singleton
    private static UdpCallServer instance;
    
    /**
     * Représente une session d'appel active avec les informations des deux clients.
     */
    private static class CallSession {
        private final String sessionId;
        private InetAddress caller;
        private int callerPort;
        private InetAddress receiver;
        private int receiverPort;
        
        public CallSession(String sessionId) {
            this.sessionId = sessionId;
        }
        
        public void setCallerEndpoint(InetAddress address, int port) {
            this.caller = address;
            this.callerPort = port;
        }
        
        public void setReceiverEndpoint(InetAddress address, int port) {
            this.receiver = address;
            this.receiverPort = port;
        }
        
        public boolean isComplete() {
            return caller != null && receiver != null;
        }
        
        public boolean isFromCaller(InetAddress address, int port) {
            return address.equals(caller) && port == callerPort;
        }
        
        public boolean isFromReceiver(InetAddress address, int port) {
            return address.equals(receiver) && port == receiverPort;
        }
        
        public String getSessionId() {
            return sessionId;
        }
    }
    
    private UdpCallServer() {
        this.threadPool = Executors.newCachedThreadPool();
        this.activeSessions = new ConcurrentHashMap<>();
    }
    
    public static synchronized UdpCallServer getInstance() {
        if (instance == null) {
            instance = new UdpCallServer();
        }
        return instance;
    }
    
    /**
     * Démarre le serveur UDP.
     */
    public void start() {
        if (running) {
            return;
        }
        
        try {
            socket = new DatagramSocket(UDP_PORT);
            running = true;
            
            System.out.println("Serveur UDP démarré sur le port " + UDP_PORT);
            
            // Démarrer le thread principal pour recevoir les paquets
            threadPool.execute(this::receivePackets);
        } catch (SocketException e) {
            System.err.println("Erreur lors du démarrage du serveur UDP: " + e.getMessage());
        }
    }
    
    /**
     * Arrête le serveur UDP.
     */
    public void stop() {
        running = false;
        if (socket != null && !socket.isClosed()) {
            socket.close();
        }
        threadPool.shutdown();
        activeSessions.clear();
    }
    
    /**
     * Enregistre une nouvelle session d'appel.
     * 
     * @param sessionId ID unique de la session
     * @return true si la session a été créée avec succès
     */
    public boolean registerSession(String sessionId) {
        if (activeSessions.containsKey(sessionId)) {
            return false;
        }
        activeSessions.put(sessionId, new CallSession(sessionId));
        return true;
    }
    
    /**
     * Enregistre un point de terminaison pour une session d'appel.
     * 
     * @param sessionId ID de la session
     * @param isCaller true si c'est l'appelant, false si c'est le destinataire
     * @param address adresse IP du client
     * @param port port UDP du client
     * @return true si l'enregistrement a réussi
     */
    public boolean registerEndpoint(String sessionId, boolean isCaller, InetAddress address, int port) {
        CallSession session = activeSessions.get(sessionId);
        if (session == null) {
            return false;
        }
        
        if (isCaller) {
            session.setCallerEndpoint(address, port);
        } else {
            session.setReceiverEndpoint(address, port);
        }
        
        return true;
    }
    
    /**
     * Supprime une session d'appel.
     * 
     * @param sessionId ID de la session à supprimer
     */
    public void removeSession(String sessionId) {
        activeSessions.remove(sessionId);
    }
    
    /**
     * Boucle principale pour recevoir et relayer les paquets.
     */
    private void receivePackets() {
        byte[] buffer = new byte[BUFFER_SIZE];
        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
        
        while (running) {
            try {
                // Réinitialiser le paquet pour la prochaine réception
                packet.setLength(buffer.length);
                
                // Recevoir un paquet
                socket.receive(packet);
                
                // Traiter le paquet dans un thread séparé
                final DatagramPacket receivedPacket = new DatagramPacket(
                        packet.getData().clone(),
                        packet.getLength(),
                        packet.getAddress(),
                        packet.getPort());
                
                threadPool.execute(() -> processPacket(receivedPacket));
                
            } catch (IOException e) {
                if (running) {
                    System.err.println("Erreur lors de la réception d'un paquet UDP: " + e.getMessage());
                }
            }
        }
    }
    
    /**
     * Traite un paquet reçu et le relaie au destinataire approprié.
     * 
     * @param packet Le paquet reçu
     */
    private void processPacket(DatagramPacket packet) {
        // Extraire les informations du paquet
        InetAddress sourceAddress = packet.getAddress();
        int sourcePort = packet.getPort();
        
        // Trouver la session correspondante
        for (CallSession session : activeSessions.values()) {
            if (!session.isComplete()) {
                continue;
            }
            
            try {
                // Déterminer la destination en fonction de la source
                if (session.isFromCaller(sourceAddress, sourcePort)) {
                    // Relayer du caller vers le receiver
                    DatagramPacket forwardPacket = new DatagramPacket(
                            packet.getData(),
                            packet.getLength(),
                            session.receiver,
                            session.receiverPort);
                    socket.send(forwardPacket);
                    return;
                } else if (session.isFromReceiver(sourceAddress, sourcePort)) {
                    // Relayer du receiver vers le caller
                    DatagramPacket forwardPacket = new DatagramPacket(
                            packet.getData(),
                            packet.getLength(),
                            session.caller,
                            session.callerPort);
                    socket.send(forwardPacket);
                    return;
                }
            } catch (IOException e) {
                System.err.println("Erreur lors du relais d'un paquet UDP: " + e.getMessage());
            }
        }
    }
}



// File: src/main/java/org/example/shared/dao/ContactDAO.java
package org.example.shared.dao;

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLIntegrityConstraintViolationException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.model.Contact;

public class ContactDAO {

    public void createContact(final Contact contact) {
        final String sql = "INSERT INTO contacts (user_id, contact_user_id, added_at) VALUES (?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, contact.getUserId());
            stmt.setLong(2, contact.getContactUserId());
            stmt.setTimestamp(3, Timestamp.valueOf(contact.getAddedAt()));
            stmt.executeUpdate();
        } catch (final SQLIntegrityConstraintViolationException ex) {
            System.err.println("Contact déjà existant: " + ex.getMessage());
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public Contact findContactById(final long id) {
        final String sql = "SELECT * FROM contacts WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    final Contact contact = new Contact();
                    // Remplacer par l'attribution des champs si un id existe dans Contact
                    contact.setUserId(rs.getLong("user_id"));
                    contact.setContactUserId(rs.getLong("contact_user_id"));
                    contact.setAddedAt(rs.getTimestamp("added_at").toLocalDateTime());
                    return contact;
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public boolean deleteContact(final long userId, final long contactId) {
        final String sql = "DELETE FROM contacts WHERE user_id = ? AND contact_user_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            stmt.setLong(2, contactId);
            final int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    public List<String> getContactsByUserId(final long userId) throws IOException {
        final List<String> contactEmails = new ArrayList<>();
        final String sql = "SELECT u.email FROM contacts c JOIN users u ON c.contact_user_id = u.id WHERE c.user_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    contactEmails.add(rs.getString("email"));
                }
            }
        } catch (final SQLException e) {
            throw new IOException("Erreur lors de la récupération des contacts", e);
        }
        return contactEmails;
    }
}



// File: src/main/java/org/example/shared/dao/GroupDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.model.Group;

public class GroupDAO {

    public void createGroup(final Group group) {
        // Mise à jour de la requête pour inclure profile_picture_url
        final String sql = "INSERT INTO `groups` (name, owner_user_id, created_at, profile_picture_url) VALUES (?,?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setString(1, group.getName());
            stmt.setLong(2, group.getOwnerUserId());
            stmt.setTimestamp(3, Timestamp.valueOf(group.getCreatedAt()));
            stmt.setString(4, group.getProfilePictureUrl());
            stmt.executeUpdate();
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    group.setId(generatedKeys.getLong(1));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public Group findGroupById(final long id) {
        final String sql = "SELECT * FROM `groups` WHERE id = ?";
        Group group = null;
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    group = new Group();
                    group.setId(rs.getLong("id"));
                    group.setName(rs.getString("name"));
                    group.setOwnerUserId(rs.getLong("owner_user_id"));
                    group.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
                    group.setProfilePictureUrl(rs.getString("profile_picture_url"));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return group;
    }

    /**
     * Récupère les identifiants des utilisateurs membres du groupe.
     */
    public List<Long> getMembersForGroup(final long groupId) {
        final List<Long> memberIds = new ArrayList<>();
        final String sql = "SELECT user_id FROM group_memberships WHERE group_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, groupId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    memberIds.add(rs.getLong("user_id"));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return memberIds;
    }

    /**
     * Récupère les groupes auxquels un utilisateur appartient.
     */
    public List<Group> getGroupsForUser(final long userId) {
        final List<Group> groups = new ArrayList<>();
        final String sql = "SELECT g.id, g.name, g.owner_user_id, g.created_at " +
                     "FROM `groups` g " +
                     "JOIN group_memberships gm ON g.id = gm.group_id " +
                     "WHERE gm.user_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    final Group group = new Group();
                    group.setId(rs.getLong("id"));
                    group.setName(rs.getString("name"));
                    group.setOwnerUserId(rs.getLong("owner_user_id"));
                    group.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
                    groups.add(group);
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return groups;
    }
}


// File: src/main/java/org/example/shared/dao/GroupMembershipDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;

import org.example.shared.model.GroupMembership;

public class GroupMembershipDAO {

    public void createGroupMembership(final GroupMembership membership) {
        final String sql = "INSERT INTO group_memberships (user_id, group_id, joined_at) VALUES (?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, membership.getUserId());
            stmt.setLong(2, membership.getGroupId());
            stmt.setTimestamp(3, Timestamp.valueOf(membership.getJoinedAt()));
            stmt.executeUpdate();
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public GroupMembership findGroupMembership(final long userId, final long groupId) {
        final String sql = "SELECT * FROM group_memberships WHERE user_id = ? AND group_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            stmt.setLong(2, groupId);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    final GroupMembership membership = new GroupMembership();
                    membership.setUserId(rs.getLong("user_id"));
                    membership.setGroupId(rs.getLong("group_id"));
                    membership.setJoinedAt(rs.getTimestamp("joined_at").toLocalDateTime());
                    return membership;
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public boolean removeGroupMembership(final long userId, final long groupId) {
        final String sql = "DELETE FROM group_memberships WHERE user_id = ? AND group_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            stmt.setLong(2, groupId);
            final int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (final SQLException e) {
            e.printStackTrace();
            return false;
        }
    }
}



// File: src/main/java/org/example/shared/dao/JDBCUtil.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class JDBCUtil {
    private static final String URL = "jdbc:mysql://localhost:3306/chat_db";
    private static final String USER = "root";
    private static final String PASSWORD = "password";

    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(URL, USER, PASSWORD);
    }
}



// File: src/main/java/org/example/shared/dao/MessageDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.model.Message;
import org.example.shared.model.enums.MessageStatus;
import org.example.shared.model.enums.MessageType;

public class MessageDAO {

    public void createMessage(final Message message) {
        final String sql = "INSERT INTO messages (sender_user_id, receiver_user_id, group_id, content, timestamp, status, "
                + "message_type, file_name, file_size, mime_type) VALUES (?,?,?,?,?,?,?,?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setLong(1, message.getSenderUserId());
            if (message.getReceiverUserId() != null) {
                stmt.setLong(2, message.getReceiverUserId());
            } else {
                stmt.setNull(2, Types.BIGINT);
            }
            if (message.getGroupId() != null) {
                stmt.setLong(3, message.getGroupId());
            } else {
                stmt.setNull(3, Types.BIGINT);
            }
            stmt.setString(4, message.getContent());
            stmt.setTimestamp(5, Timestamp.valueOf(message.getTimestamp()));
            stmt.setString(6, message.getStatus().name());
            stmt.setString(7, message.getType().name());
            // Set multimedia fields
            if (message.getFileName() != null) {
                stmt.setString(8, message.getFileName());
            } else {
                stmt.setNull(8, Types.VARCHAR);
            }

            if (message.getFileSize() != null) {
                stmt.setLong(9, message.getFileSize());
            } else {
                stmt.setNull(9, Types.BIGINT);
            }

            if (message.getMimeType() != null) {
                stmt.setString(10, message.getMimeType());
            } else {
                stmt.setNull(10, Types.VARCHAR);
            }
            stmt.executeUpdate();
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    message.setId(generatedKeys.getLong(1));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public Message findMessageById(final long id) {
        final String sql = "SELECT * FROM messages WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return extractMessageFromResultSet(rs);
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<Message> getPendingMessagesForUser(final long receiverUserId) throws SQLException {
        final List<Message> messages = new ArrayList<>();
        // Récupérer les messages directs et les messages de groupe pour lesquels
        // l'utilisateur est membre
        final String sql = "SELECT * FROM messages " +
                "WHERE ((receiver_user_id = ? AND status = ?) " +
                "OR (group_id IS NOT NULL AND status = ? " +
                "    AND group_id IN (SELECT group_id FROM group_memberships WHERE user_id = ?)))";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, receiverUserId);
            stmt.setString(2, MessageStatus.QUEUED.name());
            stmt.setString(3, MessageStatus.QUEUED.name());
            stmt.setLong(4, receiverUserId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    final Message message = new Message();
                    message.setId(rs.getLong("id"));
                    message.setSenderUserId(rs.getLong("sender_user_id"));
                    final long rec = rs.getLong("receiver_user_id");
                    if (!rs.wasNull()) {
                        message.setReceiverUserId(rec);
                    }
                    final long grp = rs.getLong("group_id");
                    if (!rs.wasNull()) {
                        message.setGroupId(grp);
                    }
                    message.setContent(rs.getString("content"));
                    final Timestamp ts = rs.getTimestamp("timestamp");
                    if (ts != null) {
                        message.setTimestamp(ts.toLocalDateTime());
                    }
                    message.setStatus(MessageStatus.valueOf(rs.getString("status")));
                    messages.add(message);
                }
            }
        }
        return messages;
    }

    public List<Message> getConversation(final long user1Id, final long user2Id) {
        final List<Message> messages = new ArrayList<>();
        final String sql = "SELECT * FROM messages WHERE " +
                " (sender_user_id = ? AND receiver_user_id = ?) OR (sender_user_id = ? AND receiver_user_id = ?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, user1Id);
            stmt.setLong(2, user2Id);
            stmt.setLong(3, user2Id);
            stmt.setLong(4, user1Id);

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    messages.add(extractMessageFromResultSet(rs));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return messages;
    }

    public boolean deleteMessage(final long messageId) throws SQLException {
        final String sql = "DELETE FROM messages WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, messageId);
            final int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        }
    }

    public void updateMessageStatus(final long messageId, final MessageStatus status) throws SQLException {
        final String sql = "UPDATE messages SET status = ? WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, status.name());
            stmt.setLong(2, messageId);
            stmt.executeUpdate();
        }
    }

    // Helper method to extract a Message from a ResultSet
    private Message extractMessageFromResultSet(final ResultSet rs) throws SQLException {
        final Message message = new Message();
        message.setId(rs.getLong("id"));
        message.setSenderUserId(rs.getLong("sender_user_id"));

        final long receiverUserId = rs.getLong("receiver_user_id");
        if (!rs.wasNull()) {
            message.setReceiverUserId(receiverUserId);
        }

        final long groupId = rs.getLong("group_id");
        if (!rs.wasNull()) {
            message.setGroupId(groupId);
        }

        message.setContent(rs.getString("content"));
        final Timestamp ts = rs.getTimestamp("timestamp");
        if (ts != null) {
            message.setTimestamp(ts.toLocalDateTime());
        }

        message.setStatus(MessageStatus.valueOf(rs.getString("status")));

        // Extract multimedia fields
        String messageTypeStr = rs.getString("message_type");
        if (messageTypeStr != null) {
            message.setType(MessageType.valueOf(messageTypeStr));
        } else {
            message.setType(MessageType.TEXT); // Default to TEXT for backward compatibility
        }

        message.setFileName(rs.getString("file_name"));

        final long fileSize = rs.getLong("file_size");
        if (!rs.wasNull()) {
            message.setFileSize(fileSize);
        }

        message.setMimeType(rs.getString("mime_type"));

        return message;
    }
}



// File: src/main/java/org/example/shared/dao/UserDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.Optional;

import org.example.shared.model.User;

public class UserDAO {

    public void createUser(final User user) {
        final String sql = "INSERT INTO users (email, display_name, password_hash, is_online, created_at, last_login_at, profile_picture_url, public_key) VALUES (?,?,?,?,?,?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setString(1, user.getEmail());
            stmt.setString(2, user.getDisplayName());
            stmt.setString(3, user.getPasswordHash());
            stmt.setBoolean(4, user.isOnline());
            stmt.setTimestamp(5, Timestamp.valueOf(user.getCreatedAt()));
            stmt.setTimestamp(6, user.getLastLoginAt() != null ? Timestamp.valueOf(user.getLastLoginAt()) : null);
            stmt.setString(7, user.getProfilePictureUrl());
            stmt.setString(8, user.getPublicKey());

            stmt.executeUpdate();
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    user.setId(generatedKeys.getLong(1));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public User findUserById(final long id) {
        final String sql = "SELECT * FROM users WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return mapRowToUser(rs);
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public User findUserByEmail(final String email) {
        final String sql = "SELECT * FROM users WHERE email = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, email);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return mapRowToUser(rs);
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public boolean updateUser(final User user) {
        final String sql = "UPDATE users SET email=?, display_name=?, password_hash=?, is_online=?, created_at=?, last_login_at=?, profile_picture_url=?, public_key=? WHERE id=?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, user.getEmail());
            stmt.setString(2, user.getDisplayName());
            stmt.setString(3, user.getPasswordHash());
            stmt.setBoolean(4, user.isOnline());
            stmt.setTimestamp(5, Timestamp.valueOf(user.getCreatedAt()));
            stmt.setTimestamp(6, user.getLastLoginAt() != null ? Timestamp.valueOf(user.getLastLoginAt()) : null);
            stmt.setString(7, user.getProfilePictureUrl());
            stmt.setString(8, user.getPublicKey());
            stmt.setLong(9, user.getId());

            final int rowsAffected = stmt.executeUpdate();
            return rowsAffected > 0;
        } catch (final SQLException e) {
            System.err.println("Erreur lors de la mise à jour de l'utilisateur: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    public void deleteUser(final long id) {
        final String sql = "DELETE FROM users WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);
            stmt.executeUpdate();
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public boolean updatePublicKey(final long userId, final String publicKeyString) {
        final String sql = "UPDATE users SET public_key = ? WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, publicKeyString);
            pstmt.setLong(2, userId);

            final int affectedRows = pstmt.executeUpdate();
            return affectedRows > 0;
        } catch (final SQLException e) {
            System.err.println("Erreur SQL lors de la mise à jour de la clé publique pour l'ID " + userId + ": " + e.getMessage());
            return false;
        }
    }

    public Optional<String> getPublicKey(final long userId) {
        final String sql = "SELECT public_key FROM users WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setLong(1, userId);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    return Optional.ofNullable(rs.getString("public_key"));
                }
            }
        } catch (final SQLException e) {
            System.err.println("Erreur SQL lors de la récupération de la clé publique pour l'ID " + userId + ": " + e.getMessage());
        }
        return Optional.empty();
    }

    private User mapRowToUser(final ResultSet rs) throws SQLException {
        final User user = new User();
        user.setId(rs.getLong("id"));
        user.setEmail(rs.getString("email"));
        user.setDisplayName(rs.getString("display_name"));
        user.setPasswordHash(rs.getString("password_hash"));
        user.setOnline(rs.getBoolean("is_online"));
        user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
        final Timestamp ts = rs.getTimestamp("last_login_at");
        if (ts != null) {
            user.setLastLoginAt(ts.toLocalDateTime());
        }
        user.setProfilePictureUrl(rs.getString("profile_picture_url"));
        user.setPublicKey(rs.getString("public_key"));
        return user;
    }
}



// File: src/main/java/org/example/shared/dto/Credentials.java
package org.example.shared.dto;

/**
 * Classe DTO pour les informations d'authentification.
 */
public class Credentials {
    private String email;
    private String password;
    
    // Constructeur par défaut requis pour Jackson
    public Credentials() {
    }
    
    public Credentials(final String email, final String password) {
        this.email = email;
        this.password = password;
    }
    
    // Getters et Setters
    public String getEmail() {
        return email;
    }
    
    public void setEmail(final String email) {
        this.email = email;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(final String password) {
        this.password = password;
    }
}


// File: src/main/java/org/example/shared/dto/RegistrationDTO.java
package org.example.shared.dto;

import java.io.Serializable;

public class RegistrationDTO implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String email;
    private String password;
    private String passwordConfirmation;
    
    // Constructeur par défaut pour Jackson
    public RegistrationDTO() {
    }
    
    public RegistrationDTO(String email, String password, String passwordConfirmation) {
        this.email = email;
        this.password = password;
        this.passwordConfirmation = passwordConfirmation;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
    
    public String getPasswordConfirmation() {
        return passwordConfirmation;
    }
    
    public void setPasswordConfirmation(String passwordConfirmation) {
        this.passwordConfirmation = passwordConfirmation;
    }
}



// File: src/main/java/org/example/shared/model/CallSession.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Représente une session d'appel audio entre deux utilisateurs.
 */
public class CallSession {
    private String sessionId;
    private long callerUserId;
    private long receiverUserId;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private CallStatus status;
    
    /**
     * Statut possible d'un appel.
     */
    public enum CallStatus {
        INITIATING,    // L'appel est en cours d'initialisation
        RINGING,       // L'appel sonne chez le destinataire
        ACCEPTED,      // L'appel a été accepté
        REJECTED,      // L'appel a été rejeté
        ENDED,         // L'appel s'est terminé normalement
        MISSED,        // L'appel a été manqué
        ERROR          // Une erreur s'est produite pendant l'appel
    }
    
    /**
     * Constructeur par défaut pour la sérialisation JSON.
     */
    public CallSession() {
    }
    
    /**
     * Crée une nouvelle session d'appel.
     * 
     * @param callerUserId ID de l'utilisateur qui appelle
     * @param receiverUserId ID de l'utilisateur qui reçoit l'appel
     */
    public CallSession(long callerUserId, long receiverUserId) {
        this.sessionId = UUID.randomUUID().toString();
        this.callerUserId = callerUserId;
        this.receiverUserId = receiverUserId;
        this.startTime = LocalDateTime.now();
        this.status = CallStatus.INITIATING;
    }
    
    /**
     * Marque l'appel comme terminé.
     */
    public void endCall() {
        this.endTime = LocalDateTime.now();
        if (this.status == CallStatus.ACCEPTED) {
            this.status = CallStatus.ENDED;
        } else if (this.status == CallStatus.RINGING) {
            this.status = CallStatus.MISSED;
        }
    }
    
    /**
     * Calcule la durée de l'appel en secondes.
     * 
     * @return La durée de l'appel en secondes, ou 0 si l'appel n'est pas terminé
     */
    public long getDurationSeconds() {
        if (startTime != null && endTime != null && status == CallStatus.ENDED) {
            return java.time.Duration.between(startTime, endTime).getSeconds();
        }
        return 0;
    }

    // Getters et setters
    
    public String getSessionId() {
        return sessionId;
    }

    public void setSessionId(String sessionId) {
        this.sessionId = sessionId;
    }

    public long getCallerUserId() {
        return callerUserId;
    }

    public void setCallerUserId(long callerUserId) {
        this.callerUserId = callerUserId;
    }

    public long getReceiverUserId() {
        return receiverUserId;
    }

    public void setReceiverUserId(long receiverUserId) {
        this.receiverUserId = receiverUserId;
    }

    public LocalDateTime getStartTime() {
        return startTime;
    }

    public void setStartTime(LocalDateTime startTime) {
        this.startTime = startTime;
    }

    public LocalDateTime getEndTime() {
        return endTime;
    }

    public void setEndTime(LocalDateTime endTime) {
        this.endTime = endTime;
    }

    public CallStatus getStatus() {
        return status;
    }

    public void setStatus(CallStatus status) {
        this.status = status;
    }
}



// File: src/main/java/org/example/shared/model/CallSignal.java
package org.example.shared.model;

import java.time.LocalDateTime;

/**
 * Représente un signal de contrôle pour les appels audio.
 * Ces signaux sont envoyés via TCP pour la signalisation des appels.
 */
public class CallSignal {
    private String sessionId;
    private long senderUserId;
    private long receiverUserId;
    private SignalType type;
    private String ipAddress;
    private int port;
    private LocalDateTime timestamp;
    
    /**
     * Types de signaux pour la gestion des appels.
     */
    public enum SignalType {
        CALL_REQUEST,   // Demande d'appel
        CALL_ACCEPT,    // Acceptation d'appel
        CALL_REJECT,    // Rejet d'appel
        CALL_END,       // Fin d'appel
        CALL_BUSY       // Destinataire occupé
    }
    
    /**
     * Constructeur par défaut pour la sérialisation JSON.
     */
    public CallSignal() {
        this.timestamp = LocalDateTime.now();
    }
    
    /**
     * Crée un nouveau signal d'appel.
     * 
     * @param sessionId ID de la session d'appel
     * @param senderUserId ID de l'utilisateur qui envoie le signal
     * @param receiverUserId ID de l'utilisateur qui reçoit le signal
     * @param type Type de signal
     */
    public CallSignal(String sessionId, long senderUserId, long receiverUserId, SignalType type) {
        this();
        this.sessionId = sessionId;
        this.senderUserId = senderUserId;
        this.receiverUserId = receiverUserId;
        this.type = type;
    }
    
    /**
     * Crée un signal de demande d'appel.
     * 
     * @param sessionId ID de la session d'appel
     * @param callerUserId ID de l'appelant
     * @param receiverUserId ID du destinataire
     * @return Un nouveau signal de demande d'appel
     */
    public static CallSignal createCallRequest(String sessionId, long callerUserId, long receiverUserId) {
        return new CallSignal(sessionId, callerUserId, receiverUserId, SignalType.CALL_REQUEST);
    }
    
    /**
     * Crée un signal d'acceptation d'appel.
     * 
     * @param sessionId ID de la session d'appel
     * @param receiverUserId ID du destinataire qui accepte l'appel
     * @param callerUserId ID de l'appelant
     * @param ipAddress Adresse IP du destinataire pour la communication UDP
     * @param port Port UDP du destinataire
     * @return Un nouveau signal d'acceptation d'appel
     */
    public static CallSignal createCallAccept(String sessionId, long receiverUserId, long callerUserId, 
                                             String ipAddress, int port) {
        CallSignal signal = new CallSignal(sessionId, receiverUserId, callerUserId, SignalType.CALL_ACCEPT);
        signal.setIpAddress(ipAddress);
        signal.setPort(port);
        return signal;
    }
    
    /**
     * Crée un signal de rejet d'appel.
     * 
     * @param sessionId ID de la session d'appel
     * @param receiverUserId ID du destinataire qui rejette l'appel
     * @param callerUserId ID de l'appelant
     * @return Un nouveau signal de rejet d'appel
     */
    public static CallSignal createCallReject(String sessionId, long receiverUserId, long callerUserId) {
        return new CallSignal(sessionId, receiverUserId, callerUserId, SignalType.CALL_REJECT);
    }
    
    /**
     * Crée un signal de fin d'appel.
     * 
     * @param sessionId ID de la session d'appel
     * @param endingUserId ID de l'utilisateur qui termine l'appel
     * @param otherUserId ID de l'autre utilisateur
     * @return Un nouveau signal de fin d'appel
     */
    public static CallSignal createCallEnd(String sessionId, long endingUserId, long otherUserId) {
        return new CallSignal(sessionId, endingUserId, otherUserId, SignalType.CALL_END);
    }
    
    /**
     * Crée un signal d'occupation.
     * 
     * @param sessionId ID de la session d'appel
     * @param busyUserId ID de l'utilisateur occupé
     * @param callerUserId ID de l'appelant
     * @return Un nouveau signal d'occupation
     */
    public static CallSignal createCallBusy(String sessionId, long busyUserId, long callerUserId) {
        return new CallSignal(sessionId, busyUserId, callerUserId, SignalType.CALL_BUSY);
    }

    // Getters et setters
    
    public String getSessionId() {
        return sessionId;
    }

    public void setSessionId(String sessionId) {
        this.sessionId = sessionId;
    }

    public long getSenderUserId() {
        return senderUserId;
    }

    public void setSenderUserId(long senderUserId) {
        this.senderUserId = senderUserId;
    }

    public long getReceiverUserId() {
        return receiverUserId;
    }

    public void setReceiverUserId(long receiverUserId) {
        this.receiverUserId = receiverUserId;
    }

    public SignalType getType() {
        return type;
    }

    public void setType(SignalType type) {
        this.type = type;
    }

    public String getIpAddress() {
        return ipAddress;
    }

    public void setIpAddress(String ipAddress) {
        this.ipAddress = ipAddress;
    }

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }
}



// File: src/main/java/org/example/shared/model/Contact.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;

public class Contact {

    private long userId;        // FK vers User.id (celui qui ajoute)
    private long contactUserId; // FK vers User.id (celui qui est ajouté)
    private LocalDateTime addedAt;

    // Constructeur par défaut
    public Contact() {
        this.addedAt = LocalDateTime.now();
    }

    // Constructeur principal
    public Contact(final long userId, final long contactUserId) {
        this();
        this.userId = userId;
        this.contactUserId = contactUserId;
    }

    // ...existing getters and setters...
    public long getUserId() { return userId; }
    public void setUserId(final long userId) { this.userId = userId; }
    public long getContactUserId() { return contactUserId; }
    public void setContactUserId(final long contactUserId) { this.contactUserId = contactUserId; }
    public LocalDateTime getAddedAt() { return addedAt; }
    public void setAddedAt(final LocalDateTime addedAt) { this.addedAt = addedAt; }

    // ...equals, hashCode, toString...
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final Contact contact = (Contact) o;
        return userId == contact.userId && contactUserId == contact.contactUserId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(userId, contactUserId);
    }

    @Override
    public String toString() {
        return "Contact{" + "userId=" + userId + ", contactUserId=" + contactUserId + ", addedAt=" + addedAt + '}';
    }
}



// File: src/main/java/org/example/shared/model/enums/MessageStatus.java
package org.example.shared.model.enums;

/**
 * Définit les statuts possibles d'un message.
 * 
 * Les statuts permettent de suivre l'état d'un message dans le système.
 */
public enum MessageStatus {
    SENT,       // Envoyé par le client, potentiellement en transit vers le destinataire/groupe
    DELIVERED,  // Confirmé comme reçu par le serveur/broker du destinataire (pas forcément lu)
    READ,       // Confirmé comme lu par le client destinataire (nécessite logique d'ACK)
    FAILED,     // Échec de l'envoi ou de la persistance
    QUEUED      // Mis en file d'attente car le destinataire était hors ligne
}



// File: src/main/java/org/example/shared/model/enums/MessageType.java
package org.example.shared.model.enums;

public enum MessageType {
    TEXT,    // Message texte simple (peut être chiffré ou non, voir champ encryptedContent)
    IMAGE,   // Message image
    VIDEO,   // Message vidéo
    AUDIO,   // Message audio
    DOCUMENT,// Message document

    // --- NOUVEAUX TYPES POUR E2EE ---
    E2E_SESSION_INIT,    // Message contenant une clé de session E2EE chiffrée
    PUBLIC_KEY_REQUEST,  // Demande de clé publique d'un utilisateur
    PUBLIC_KEY_RESPONSE, // Réponse contenant une clé publique

    // --- AUTRES TYPES POSSIBLES ---
    SYSTEM,              // Message système (ex: user joined/left, non chiffré)
    STATUS_UPDATE        // Mise à jour de statut (typing, read receipt)
    // Ajouter d'autres types si nécessaire
}


// File: src/main/java/org/example/shared/model/Group.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;

public class Group {

    private long id;
    private String name;
    private long ownerUserId; // FK vers User.id
    private LocalDateTime createdAt;
    private String profilePictureUrl; // Nouvelle propriété pour l'image

    // Constructeur par défaut
    public Group() {
        this.createdAt = LocalDateTime.now();
    }

    // Constructeur pour la création initiale
    public Group(final String name, final long ownerUserId) {
        this();
        this.name = name;
        this.ownerUserId = ownerUserId;
    }

    // ...existing getters and setters...
    public long getId() { return id; }
    public void setId(final long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(final String name) { this.name = name; }
    public long getOwnerUserId() { return ownerUserId; }
    public void setOwnerUserId(final long ownerUserId) { this.ownerUserId = ownerUserId; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(final LocalDateTime createdAt) { this.createdAt = createdAt; }

    public String getProfilePictureUrl() {
        return profilePictureUrl;
    }
    public void setProfilePictureUrl(final String profilePictureUrl) {
        this.profilePictureUrl = profilePictureUrl;
    }

    // ...equals, hashCode, toString...
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final Group group = (Group) o;
        return id > 0 && id == group.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "Group{" + "id=" + id + ", name='" + name + '\'' +
               ", ownerUserId=" + ownerUserId + '}';
    }
}



// File: src/main/java/org/example/shared/model/GroupMembership.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;

public class GroupMembership {

    private long userId;   // FK vers User.id
    private long groupId;  // FK vers Group.id
    private LocalDateTime joinedAt;

    // Constructeur par défaut
    public GroupMembership() {
        this.joinedAt = LocalDateTime.now();
    }

    // Constructeur principal
    public GroupMembership(final long userId, final long groupId) {
        this();
        this.userId = userId;
        this.groupId = groupId;
    }

    // ...existing getters and setters...
    public long getUserId() { return userId; }
    public void setUserId(final long userId) { this.userId = userId; }
    public long getGroupId() { return groupId; }
    public void setGroupId(final long groupId) { this.groupId = groupId; }
    public LocalDateTime getJoinedAt() { return joinedAt; }
    public void setJoinedAt(final LocalDateTime joinedAt) { this.joinedAt = joinedAt; }

    // ...equals, hashCode, toString...
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final GroupMembership that = (GroupMembership) o;
        return userId == that.userId && groupId == that.groupId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(userId, groupId);
    }

    @Override
    public String toString() {
        return "GroupMembership{" + "userId=" + userId + ", groupId=" + groupId + ", joinedAt=" + joinedAt + '}';
    }
}



// File: src/main/java/org/example/shared/model/Message.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;
import java.util.Base64; // Import Base64

import org.example.shared.model.enums.MessageStatus;
import org.example.shared.model.enums.MessageType;  // Assurez-vous que cet enum est mis à jour

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude; // Pour ne pas inclure les champs null

@JsonInclude(JsonInclude.Include.NON_NULL) // Ne pas inclure les champs null dans JSON
public class Message {

    private long id;
    private long senderUserId;   // FK vers User.id
    private Long receiverUserId; // FK vers User.id (Nullable pour les messages de groupe)
    private Long groupId;        // FK vers Group.id (Nullable pour les messages directs)
    private String content;      // Pour les messages TEXT non-E2EE, chemins de fichiers media, ou contenu spécial (ex: clé publique)
    private LocalDateTime timestamp;
    private MessageStatus status; // Utilise l'Enum MessageStatus

    // Champs existants pour multimedia
    private MessageType type;    // Type of message (TEXT, IMAGE, VIDEO, DOCUMENT, AUDIO, E2E_SESSION_INIT, etc.)
    private String fileName;     // Original file name
    private Long fileSize;       // Size of file in bytes
    private String mimeType;     // MIME type of the file

    // --- NOUVEAUX CHAMPS POUR E2EE ---
    private byte[] encryptedContent; // Contenu chiffré (pour TEXT E2EE, potentiellement media)
    private String sessionKeyId;     // Identifiant de la clé de session utilisée (optionnel)
    // --- FIN NOUVEAUX CHAMPS POUR E2EE ---


    // Constructeur par défaut
    public Message() {
        this.timestamp = LocalDateTime.now();
        this.status = MessageStatus.SENT; // Statut par défaut lors de la création côté client
        this.type = MessageType.TEXT;     // Type par défaut
    }

    // --- FACTORIES EXISTANTES (Peuvent rester pour compatibilité ou messages système) ---

    public static Message newDirectMessage(final long senderUserId, final long receiverUserId, final String content) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setReceiverUserId(receiverUserId);
        msg.setContent(content);
        msg.setType(MessageType.TEXT); // Message texte simple (non chiffré par défaut ici)
        return msg;
    }

    public static Message newGroupMessage(final long senderUserId, final long groupId, final String content) {
        // Les messages de groupe E2EE sont complexes, ce factory reste pour du texte simple non-E2EE
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setGroupId(groupId);
        msg.setContent(content);
        msg.setType(MessageType.TEXT);
        return msg;
    }

    // Factories pour media (content contient le chemin ou l'identifiant du fichier)
    public static Message newDirectMediaMessage(final long senderUserId, final long receiverUserId,
                                                final String filePath, final MessageType type, final String fileName,
                                                final Long fileSize, final String mimeType) {
        // Pour E2EE media, il faudrait chiffrer le fichier et potentiellement mettre les bytes dans encryptedContent
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setReceiverUserId(receiverUserId);
        msg.setContent(filePath); // Le chemin reste en clair ici
        msg.setType(type);
        msg.setFileName(fileName);
        msg.setFileSize(fileSize);
        msg.setMimeType(mimeType);
        return msg;
    }

     public static Message newGroupMediaMessage(final long senderUserId, final long groupId,
                                               final String filePath, final MessageType type, final String fileName,
                                               final Long fileSize, final String mimeType) {
        // Idem pour E2EE media groupe
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setGroupId(groupId);
        msg.setContent(filePath);
        msg.setType(type);
        msg.setFileName(fileName);
        msg.setFileSize(fileSize);
        msg.setMimeType(mimeType);
        return msg;
    }


    // --- NOUVELLES FACTORIES POUR E2EE ---

    /** Crée un message texte chiffré E2EE */
    public static Message newEncryptedTextMessage(final long senderUserId, final long receiverUserId,
                                                  final byte[] encryptedContent, final String sessionKeyId) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setReceiverUserId(receiverUserId);
        msg.setType(MessageType.TEXT); // On réutilise TEXT, mais on sait qu'il est chiffré car encryptedContent est non null
        msg.setEncryptedContent(encryptedContent);
        msg.setSessionKeyId(sessionKeyId);
        msg.setContent(null); // Le contenu clair est nul
        return msg;
    }

    /** Crée un message pour initier une session E2EE (envoi de clé symétrique chiffrée) */
    public static Message newSessionInitMessage(final long senderUserId, final long receiverUserId,
                                                final byte[] encryptedSessionKey) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setReceiverUserId(receiverUserId);
        msg.setType(MessageType.E2E_SESSION_INIT); // Nouveau type requis dans l'enum MessageType
        msg.setEncryptedContent(encryptedSessionKey); // La clé chiffrée est dans le contenu chiffré
        msg.setContent(null);
        return msg;
    }

     /** Crée un message pour demander la clé publique d'un utilisateur */
    public static Message newPublicKeyRequestMessage(final long senderUserId, final long targetUserId) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        // Pas de destinataire direct, le serveur interprète la demande
        // msg.setReceiverUserId(null); // Ou un ID spécial pour le serveur ?
        msg.setType(MessageType.PUBLIC_KEY_REQUEST); // Nouveau type requis
        msg.setContent(String.valueOf(targetUserId)); // Mettre l'ID demandé dans le contenu
        return msg;
    }

     /** Crée un message contenant une clé publique en réponse à une demande */
    public static Message newPublicKeyResponseMessage(final long keyOwnerUserId, final long recipientUserId, final String publicKeyString) {
        final Message msg = new Message();
        msg.setSenderUserId(keyOwnerUserId); // Qui possède la clé
        msg.setReceiverUserId(recipientUserId); // À qui envoyer la réponse
        msg.setType(MessageType.PUBLIC_KEY_RESPONSE); // Nouveau type requis
        msg.setContent(publicKeyString); // La clé publique (Base64) dans le contenu
        return msg;
    }

    // --- FIN NOUVELLES FACTORIES POUR E2EE ---


    // Méthode utilitaire existante pour cloner (à adapter si besoin)
    public static Message copyForReceiver(final Message original, final long receiverUserId) {
        final Message copy = new Message();
        copy.setSenderUserId(original.getSenderUserId());
        copy.setReceiverUserId(receiverUserId); // Définit le destinataire spécifique
        copy.setGroupId(original.getGroupId()); // Garde l'ID de groupe si c'est un message de groupe
        copy.setContent(original.getContent());
        copy.setTimestamp(original.getTimestamp());
        copy.setStatus(MessageStatus.QUEUED); // Le statut pour la copie est QUEUED initialement
        copy.setType(original.getType());
        copy.setFileName(original.getFileName());
        copy.setFileSize(original.getFileSize());
        copy.setMimeType(original.getMimeType());
        // Copier aussi les champs E2EE
        copy.setEncryptedContent(original.getEncryptedContent()); // Copie la référence du tableau de bytes
        copy.setSessionKeyId(original.getSessionKeyId());
        return copy;
    }

    // --- GETTERS ET SETTERS (Existants + Nouveaux) ---

    public long getId() { return id; }
    public void setId(final long id) { this.id = id; }
    public long getSenderUserId() { return senderUserId; }
    public void setSenderUserId(final long senderUserId) { this.senderUserId = senderUserId; }
    public Long getReceiverUserId() { return receiverUserId; }
    public void setReceiverUserId(final Long receiverUserId) { this.receiverUserId = receiverUserId; }
    public Long getGroupId() { return groupId; }
    public void setGroupId(final Long groupId) { this.groupId = groupId; }
    public String getContent() { return content; }
    public void setContent(final String content) { this.content = content; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(final LocalDateTime timestamp) { this.timestamp = timestamp; }
    public MessageStatus getStatus() { return status; }
    public void setStatus(final MessageStatus status) { this.status = status; }
    public MessageType getType() { return type; }
    public void setType(final MessageType type) { this.type = type; }
    public String getFileName() { return fileName; }
    public void setFileName(final String fileName) { this.fileName = fileName; }
    public Long getFileSize() { return fileSize; }
    public void setFileSize(final Long fileSize) { this.fileSize = fileSize; }
    public String getMimeType() { return mimeType; }
    public void setMimeType(final String mimeType) { this.mimeType = mimeType; }

    // Getters/Setters pour les champs E2EE
    public String getSessionKeyId() { return sessionKeyId; }
    public void setSessionKeyId(String sessionKeyId) { this.sessionKeyId = sessionKeyId; }

    // Gérer la conversion Base64 pour la sérialisation JSON de encryptedContent
    public String getEncryptedContentBase64() {
        return (encryptedContent != null) ? Base64.getEncoder().encodeToString(encryptedContent) : null;
    }

    public void setEncryptedContentBase64(String base64Data) {
        this.encryptedContent = (base64Data != null && !base64Data.isEmpty()) ? Base64.getDecoder().decode(base64Data) : null;
    }

    @JsonIgnore // Ignorer le byte[] brut pour Jackson, utiliser la version Base64
    public byte[] getEncryptedContent() { return encryptedContent; }
    @JsonIgnore
    public void setEncryptedContent(byte[] encryptedContent) { this.encryptedContent = encryptedContent; }


    // --- MÉTHODES UTILITAIRES (@JsonIgnore) ---

    @JsonIgnore
    public boolean isDirectMessage() {
        return receiverUserId != null && groupId == null;
    }

    @JsonIgnore
    public boolean isGroupMessage() {
        return groupId != null && receiverUserId == null; // Correction: receiverUserId doit être null pour groupe
    }

    @JsonIgnore
    public boolean isTextMessage() {
        // Un message TEXT est considéré comme texte simple s'il n'a pas de contenu chiffré
        return type == MessageType.TEXT && encryptedContent == null;
    }

     @JsonIgnore
    public boolean isEncryptedTextMessage() {
        // Un message TEXT est considéré comme chiffré s'il a du contenu chiffré
        return type == MessageType.TEXT && encryptedContent != null;
    }

    @JsonIgnore
    public boolean isMediaMessage() {
        // Inclut tous les types sauf TEXT et les types E2EE spécifiques
        return type != MessageType.TEXT &&
               type != MessageType.E2E_SESSION_INIT &&
               type != MessageType.PUBLIC_KEY_REQUEST &&
               type != MessageType.PUBLIC_KEY_RESPONSE; // Ajuster si d'autres types système sont ajoutés
    }

    // Les méthodes isImageMessage, isVideoMessage etc. restent valides

    @JsonIgnore
    public boolean isImageMessage() { return type == MessageType.IMAGE; }
    @JsonIgnore
    public boolean isVideoMessage() { return type == MessageType.VIDEO; }
    @JsonIgnore
    public boolean isDocumentMessage() { return type == MessageType.DOCUMENT; }
    @JsonIgnore
    public boolean isAudioMessage() { return type == MessageType.AUDIO; }

    // --- equals, hashCode, toString ---

    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final Message message = (Message) o;
        // L'égalité basée sur l'ID est ok si l'ID est généré par la DB et unique.
        // Si l'ID n'est pas encore défini (avant sauvegarde), cette égalité ne fonctionne pas.
        return id > 0 && id == message.id;
    }

    @Override
    public int hashCode() {
        // Basé sur l'ID si > 0, sinon basé sur d'autres champs immuables après création.
        return (id > 0) ? Objects.hash(id) : Objects.hash(senderUserId, receiverUserId, groupId, timestamp);
    }

    @Override
    public String toString() {
        String details = "id=" + id +
                         ", type=" + type +
                         ", senderUserId=" + senderUserId +
                         (isDirectMessage() ? ", receiverUserId=" + receiverUserId : "") +
                         (isGroupMessage() ? ", groupId=" + groupId : "") +
                         ", status=" + status +
                         ", timestamp=" + timestamp;
        if (encryptedContent != null) {
            details += ", encryptedContent=[bytes]";
        } else if (content != null) {
            details += ", content='" + content.substring(0, Math.min(content.length(), 30)) + "...'";
        }
        if (fileName != null) {
             details += ", fileName='" + fileName + "'";
        }
        return "Message{" + details + '}';
    }
}


// File: src/main/java/org/example/shared/model/User.java
package org.example.shared.model;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Objects;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;

public class User implements Serializable {
    private static final long serialVersionUID = 1L;

    private long id;
    private String email; // Unique
    private String displayName;
    private String passwordHash; // Important: C'est un HASH !
    private final BooleanProperty online = new SimpleBooleanProperty(false);
    private LocalDateTime createdAt;
    private LocalDateTime lastLoginAt; // Peut être null
    private String profilePictureUrl; // URL de l'image de profil
    private String status;
    private String publicKey; // Nouveau champ pour la clé publique

    // Constructeur par défaut
    public User() {
        this.createdAt = LocalDateTime.now();
        this.online.set(false);
        this.profilePictureUrl = "/images/default_avatar.png"; // Image par défaut
    }

    // Constructeur pour la création initiale (avant sauvegarde)
    public User(final String email, final String displayName, final String passwordHash) {
        this();
        this.email = email;
        this.displayName = displayName;
        this.passwordHash = passwordHash;
    }

    public long getId() { return id; }
    public void setId(final long id) { this.id = id; }
    public String getEmail() { return email; }
    public void setEmail(final String email) { this.email = email; }
    public String getDisplayName() { return displayName; }
    public void setDisplayName(final String displayName) { this.displayName = displayName; }
    public String getPasswordHash() { return passwordHash; }
    public void setPasswordHash(final String passwordHash) { this.passwordHash = passwordHash; }
    public boolean isOnline() { return online.get(); }
    public void setOnline(final boolean online) { this.online.set(online); }
    public BooleanProperty onlineProperty() { return online; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(final LocalDateTime createdAt) { this.createdAt = createdAt; }
    public LocalDateTime getLastLoginAt() { return lastLoginAt; }
    public void setLastLoginAt(final LocalDateTime lastLoginAt) { this.lastLoginAt = lastLoginAt; }
    public String getProfilePictureUrl() { 
        return profilePictureUrl; 
    }
    public void setProfilePictureUrl(final String profilePictureUrl) { 
        this.profilePictureUrl = profilePictureUrl; 
    }
    public String getStatus() { return status; }
    public void setStatus(final String status) { this.status = status; }
    public String getPublicKey() { return publicKey; }
    public void setPublicKey(final String publicKey) { this.publicKey = publicKey; }

    /**
     * Retourne le nom d'affichage si disponible, sinon l'email
     */
    public String getDisplayNameOrEmail() {
        return displayName != null && !displayName.isEmpty() ? displayName : email;
    }

    /**
     * Retourne l'URL de l'avatar ou une image par défaut
     */
    public String getAvatarUrl() {
        return profilePictureUrl != null && !profilePictureUrl.isEmpty() ? 
               profilePictureUrl : "/images/default_avatar.png";
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final User user = (User) o;
        if (id > 0 && user.id > 0) return id == user.id;
        return Objects.equals(email, user.email);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id > 0 ? id : email);
    }

    @Override
    public String toString() {
        return "User{" + "id=" + id + ", email='" + email + '\'' + ", displayName='" + displayName + '\'' + '}';
    }
}



// File: src/main/java/org/example/shared/util/PasswordUtils.java
package org.example.shared.util;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;

public class PasswordUtils {
    
    /**
     * Génère un hash sécurisé du mot de passe
     * Note: Dans une application réelle, on utiliserait un algorithme plus robuste comme bcrypt ou PBKDF2
     * 
     * @param password le mot de passe à hasher
     * @return le hash du mot de passe
     */
    public static String hashPassword(String password) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(password.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Erreur lors du hashage du mot de passe", e);
        }
    }
    
    /**
     * Vérifie si un mot de passe correspond à un hash
     * 
     * @param password le mot de passe en clair
     * @param storedHash le hash stocké
     * @return true si le mot de passe correspond au hash, false sinon
     */
    public static boolean verifyPassword(String password, String storedHash) {
        String passwordHash = hashPassword(password);
        return passwordHash.equals(storedHash);
    }
    
    /**
     * Génère un mot de passe aléatoire
     * 
     * @param length la longueur du mot de passe
     * @return un mot de passe aléatoire
     */
    public static String generateRandomPassword(int length) {
        final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+";
        SecureRandom random = new SecureRandom();
        StringBuilder sb = new StringBuilder();
        
        for (int i = 0; i < length; i++) {
            int randomIndex = random.nextInt(chars.length());
            sb.append(chars.charAt(randomIndex));
        }
        
        return sb.toString();
    }
}



// File: src/main/java/org/example/shared/util/ValidationUtils.java
package org.example.shared.util;

import java.util.regex.Pattern;

public class ValidationUtils {
    
    // Regex pour valider un email
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("^[A-Za-z0-9+_.-]+@(.+)$");
    
    /**
     * Vérifie si l'email est valide selon le pattern défini
     * @param email l'email à valider
     * @return true si l'email est valide, false sinon
     */
    public static boolean isValidEmail(String email) {
        if (email == null || email.trim().isEmpty()) {
            return false;
        }
        return EMAIL_PATTERN.matcher(email).matches();
    }
    
    /**
     * Vérifie si le mot de passe respecte les critères de sécurité:
     * - Au moins 8 caractères
     * - Au moins une lettre majuscule
     * - Au moins une lettre minuscule
     * - Au moins un chiffre
     * - Au moins un caractère spécial
     * 
     * @param password le mot de passe à valider
     * @return true si le mot de passe est valide, false sinon
     */
    public static boolean isStrongPassword(String password) {
        if (password == null || password.length() < 8) {
            return false;
        }
        
        boolean hasUppercase = false;
        boolean hasLowercase = false;
        boolean hasDigit = false;
        boolean hasSpecial = false;
        
        for (char c : password.toCharArray()) {
            if (Character.isUpperCase(c)) {
                hasUppercase = true;
            } else if (Character.isLowerCase(c)) {
                hasLowercase = true;
            } else if (Character.isDigit(c)) {
                hasDigit = true;
            } else {
                hasSpecial = true;
            }
        }
        
        return hasUppercase && hasLowercase && hasDigit && hasSpecial;
    }
    
    /**
     * Vérifie si les deux mots de passe correspondent
     * @param password le mot de passe
     * @param confirmPassword la confirmation du mot de passe
     * @return true si les mots de passe correspondent, false sinon
     */
    public static boolean doPasswordsMatch(String password, String confirmPassword) {
        return password != null && password.equals(confirmPassword);
    }
}



// File: src/main/resources/fxml/call-dialog.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.Font?>

<VBox xmlns="http://javafx.com/javafx"
      xmlns:fx="http://javafx.com/fxml"
      fx:controller="org.example.client.gui.controllers.CallDialogController"
      spacing="15" alignment="CENTER"
      prefWidth="350" prefHeight="200"
      style="-fx-background-color: white; -fx-border-color: #cccccc; -fx-border-radius: 5;">
    
    <padding>
        <Insets top="20" right="20" bottom="20" left="20"/>
    </padding>
    
    <Label fx:id="callerNameLabel" text="Nom de l'appelant" style="-fx-font-weight: bold;">
        <font>
            <Font size="16"/>
        </font>
    </Label>
    
    <Label fx:id="callStatusLabel" text="Appel entrant...">
        <font>
            <Font size="14"/>
        </font>
    </Label>
    
    <HBox spacing="20" alignment="CENTER">
        <Button fx:id="acceptButton" text="Accepter" onAction="#handleAcceptCall" 
                style="-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-weight: bold; -fx-min-width: 100px;"/>
        <Button fx:id="rejectButton" text="Refuser" onAction="#handleRejectCall"
                style="-fx-background-color: #F44336; -fx-text-fill: white; -fx-font-weight: bold; -fx-min-width: 100px;"/>
    </HBox>
</VBox>



// File: src/main/resources/fxml/chat.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.client.gui.controllers.ChatController"
            prefHeight="600.0" prefWidth="800.0">

    <stylesheets>
        <URL value="@../css/chat.css"/>
    </stylesheets>

    <top>
        <HBox alignment="CENTER_LEFT" spacing="10" styleClass="header">
            <Label text="Chat Application" styleClass="header-text"/>
            <Button fx:id="mediaGalleryButton" text="Galerie Média" styleClass="media-gallery-button"/>
            <Region HBox.hgrow="ALWAYS"/>
            <Label fx:id="userEmailLabel" styleClass="header-text"/>
            <Button text="Déconnexion" onAction="#handleLogout"/>
        </HBox>
    </top>

    <left>
        <VBox spacing="5" prefWidth="250">
            <padding>
                <Insets top="5" right="5" bottom="5" left="5"/>
            </padding>

            <Label text="Contacts" style="-fx-font-weight: bold;"/>
            <HBox spacing="5">
                <TextField fx:id="newContactField" promptText="Ajouter un contact" HBox.hgrow="ALWAYS"/>
                <Button text="+" onAction="#handleAddContact"/>
                <Button text="-" onAction="#handleRemoveContact"/>
            </HBox>
            <ListView fx:id="contactListView" VBox.vgrow="ALWAYS" styleClass="contact-list">
                <placeholder>
                    <Label text="Aucun contact"/>
                </placeholder>
            </ListView>

            <Separator>
                <padding>
                    <Insets top="10" bottom="10"/>
                </padding>
            </Separator>

            <Label text="Groupes" style="-fx-font-weight: bold;"/>
            <HBox spacing="5">
                <TextField fx:id="groupNameField" promptText="Nom du groupe" HBox.hgrow="ALWAYS"/>
                <Button text="+" onAction="#handleCreateGroup"/>
            </HBox>
            <ListView fx:id="groupListView" VBox.vgrow="ALWAYS" styleClass="group-list">
                <placeholder>
                    <Label text="Aucun groupe"/>
                </placeholder>
            </ListView>
            <HBox spacing="5">
                <TextField fx:id="memberEmailField" promptText="Email du membre" HBox.hgrow="ALWAYS"/>
                <Button text="+" onAction="#handleAddMemberToGroup"/>
                <Button text="-" onAction="#handleRemoveMemberFromGroup"/>
            </HBox>
        </VBox>
    </left>

    <center>
        <BorderPane>
            <top>
                <VBox spacing="2" style="-fx-background-color: #f5f5f5;">
                    <HBox alignment="CENTER_LEFT" style="-fx-padding: 5px;">
                        <Label fx:id="statusLabel" styleClass="status-label"/>
                    </HBox>
                    <HBox alignment="CENTER_LEFT" style="-fx-padding: 0 5px 5px 5px;">
                        <Label fx:id="groupMembersLabel" styleClass="group-members-label"/>
                    </HBox>
                </VBox>
            </top>
            <center>
                <ScrollPane fx:id="chatScrollPane" fitToWidth="true">
                    <VBox fx:id="chatHistoryContainer" spacing="5" styleClass="chat-history"/>
                </ScrollPane>
            </center>
            <bottom>
                <VBox spacing="5">
                    <!-- Media attachment indicator -->
                    <HBox fx:id="attachmentPreviewContainer" spacing="5" alignment="CENTER_LEFT" styleClass="attachment-preview" managed="false" visible="false">
                        <Label fx:id="attachmentNameLabel" styleClass="attachment-name"/>
                        <Region HBox.hgrow="ALWAYS"/>
                        <Button text="×" onAction="#handleRemoveAttachment" styleClass="remove-attachment-button"/>
                    </HBox>

                    <!-- Recording indicator -->
                    <HBox fx:id="recordingIndicatorContainer" spacing="5" alignment="CENTER_LEFT" styleClass="recording-indicator" managed="false" visible="false">
                        <Label text="⚫ Enregistrement en cours..." styleClass="recording-label"/>
                        <Region HBox.hgrow="ALWAYS"/>
                        <Label fx:id="recordingTimeLabel" text="00:00" styleClass="recording-time"/>
                    </HBox>

                    <!-- Message input area -->
                    <HBox spacing="5" alignment="CENTER_LEFT" style="-fx-padding: 10px;">
                        <!-- Media attachment button -->
                        <Button fx:id="mediaButton" text="📎 Media" styleClass="send-button" onAction="#handleMediaButtonClick"/>

                        <!-- Audio recording button -->
                        <Button fx:id="audioRecordButton" text="🎤 Audio" styleClass="send-button" onAction="#handleAudioRecordButtonClick"/>

                        <!-- Message text field -->
                        <TextField fx:id="messageField" promptText="Écrire un message..." HBox.hgrow="ALWAYS"/>

                        <!-- Send button -->
                        <Button text="Envoyer" styleClass="send-button" onAction="#handleSendMessage"/>
                        <Button fx:id="callButton" text="📞 Appeler" styleClass="call-button" onAction="#handleCallRequest" disable="true"/>
                    </HBox>

                    <!-- Zone d'interface d'appel (initialement cachée) -->
                    <VBox fx:id="callControlsBox" spacing="5" style="-fx-padding: 10px; -fx-background-color: #f0f0f0; -fx-border-color: #cccccc; -fx-border-radius: 5;" visible="false" managed="false">
                        <HBox alignment="CENTER_LEFT" spacing="10">
                            <Label fx:id="callStatusLabel" text="Aucun appel en cours" HBox.hgrow="ALWAYS"/>
                            <Button fx:id="acceptCallButton" text="Accepter" onAction="#handleAcceptCall" visible="false" managed="false"/>
                            <Button fx:id="rejectCallButton" text="Refuser" onAction="#handleRejectCall" visible="false" managed="false"/>
                            <Button fx:id="endCallButton" text="Terminer" onAction="#handleEndCall" visible="false" managed="false"/>
                            <ToggleButton fx:id="muteButton" text="Muet" onAction="#handleToggleMute" visible="false" managed="false"/>
                        </HBox>
                    </VBox>
                </VBox>
            </bottom>
        </BorderPane>
    </center>
</BorderPane>


// File: src/main/resources/fxml/login.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.PasswordField?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>
<?import javafx.scene.control.Hyperlink?>

<BorderPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="400.0" minWidth="600.0"
    prefHeight="400.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/17"
    xmlns:fx="http://javafx.com/fxml/1" fx:controller="org.example.client.gui.controllers.LoginController">
    <center>
        <VBox alignment="CENTER" maxWidth="400.0" spacing="15.0" BorderPane.alignment="CENTER">
            <children>
                <Label text="Chat Application" textAlignment="CENTER">
                    <font>
                        <Font name="System Bold" size="24.0" />
                    </font>
                </Label>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Email" />
                        <TextField fx:id="emailField" promptText="Entrez votre email" />
                    </children>
                </VBox>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Mot de passe" />
                        <PasswordField fx:id="passwordField" promptText="Entrez votre mot de passe" />
                    </children>
                </VBox>
                <Button fx:id="loginButton" defaultButton="true" maxWidth="1.7976931348623157E308"
                    mnemonicParsing="false" onAction="#handleLogin" text="Se connecter">
                    <VBox.margin>
                        <Insets top="10.0" />
                    </VBox.margin>
                </Button>
                <HBox alignment="CENTER" spacing="5.0">
                    <children>
                        <Label text="Pas encore de compte ?" />
                        <Hyperlink onAction="#handleRegisterLink" text="Créer un compte" />
                    </children>
                    <VBox.margin>
                        <Insets top="10.0" />
                    </VBox.margin>
                </HBox>
            </children>
            <BorderPane.margin>
                <Insets left="20.0" right="20.0" />
            </BorderPane.margin>
            <padding>
                <Insets bottom="20.0" left="20.0" right="20.0" top="20.0" />
            </padding>
        </VBox>
    </center>
    <bottom>
        <HBox alignment="CENTER" prefHeight="50.0" spacing="10.0" BorderPane.alignment="CENTER">
            <children>
                <Label text=" 2025 Chat Application" textFill="#686868" />
            </children>
        </HBox>
    </bottom>
</BorderPane>


// File: src/main/resources/fxml/media_dialog.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.Text?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.client.gui.controllers.MediaDialogController"
            prefWidth="500.0" prefHeight="400.0">

    <top>
        <HBox alignment="CENTER" spacing="10" style="-fx-background-color: #4caf50; -fx-padding: 10px;">
            <Label text="Envoyer un média" style="-fx-text-fill: white; -fx-font-size: 16px;"/>
        </HBox>
    </top>

    <center>
        <VBox spacing="15" style="-fx-padding: 20px;">
            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Type de média:" />
                <ComboBox fx:id="mediaTypeComboBox" promptText="Choisir type de média" prefWidth="200"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Fichier:" />
                <TextField fx:id="filePathField" editable="false" HBox.hgrow="ALWAYS" />
                <Button text="Parcourir..." onAction="#handleBrowseFile" />
            </HBox>

            <VBox fx:id="previewContainer" VBox.vgrow="ALWAYS" spacing="10" style="-fx-padding: 10px; -fx-border-color: #ddd; -fx-border-radius: 5px;">
                <Text text="Aperçu du média sera affiché ici" style="-fx-fill: #999;"/>
            </VBox>

            <HBox fx:id="recordAudioContainer" spacing="10" alignment="CENTER_LEFT" visible="false" managed="false">
                <Button fx:id="recordButton" text="🎤 Enregistrer" onAction="#handleRecordAudio" />
                <Label fx:id="recordingTimeLabel" text="00:00" />
                <Region HBox.hgrow="ALWAYS" />
                <ProgressBar fx:id="audioLevelIndicator" progress="0" prefWidth="100" />
            </HBox>
        </VBox>
    </center>

    <bottom>
        <HBox alignment="CENTER_RIGHT" spacing="10" style="-fx-padding: 10px; -fx-background-color: #f5f5f5;">
            <Button text="Annuler" onAction="#handleCancel" style="-fx-padding: 5px 15px;" />
            <Button fx:id="sendButton" text="Envoyer" onAction="#handleSend" style="-fx-padding: 5px 15px; -fx-background-color: #4caf50; -fx-text-fill: white;" />
        </HBox>
    </bottom>

</BorderPane>


// File: src/main/resources/fxml/media_gallery.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.client.gui.controllers.MediaGalleryController"
            prefWidth="800.0" prefHeight="600.0">

    <top>
        <HBox alignment="CENTER_LEFT" spacing="10" style="-fx-background-color: #4caf50; -fx-padding: 10px;">
            <Label fx:id="titleLabel" text="Galerie média"
                   style="-fx-text-fill: white; -fx-font-size: 18px;"/>
            <Region HBox.hgrow="ALWAYS"/>
            <ComboBox fx:id="mediaTypeFilter" prefWidth="150"/>
        </HBox>
    </top>

    <center>
        <ScrollPane fitToWidth="true" fitToHeight="true">
            <FlowPane fx:id="mediaContainer" hgap="10" vgap="10" prefWrapLength="700">
                <padding>
                    <Insets top="10" right="10" bottom="10" left="10"/>
                </padding>
            </FlowPane>
        </ScrollPane>
    </center>

    <bottom>
        <HBox alignment="CENTER_RIGHT" spacing="10" style="-fx-padding: 10px; -fx-background-color: #f5f5f5;">
            <Label fx:id="statsLabel" text="Total: 0 médias"/>
            <Region HBox.hgrow="ALWAYS"/>
            <Button text="Fermer" onAction="#handleClose"
                    style="-fx-padding: 5px 15px;"/>
        </HBox>
    </bottom>

</BorderPane>


// File: src/main/resources/fxml/register.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Hyperlink?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.PasswordField?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<BorderPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="500.0" minWidth="600.0"
    prefHeight="500.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/17"
    xmlns:fx="http://javafx.com/fxml/1" fx:controller="org.example.client.gui.controllers.RegisterController">
    <center>
        <VBox alignment="CENTER" maxWidth="400.0" spacing="15.0" BorderPane.alignment="CENTER">
            <children>
                <Label text="Créer un compte" textAlignment="CENTER">
                    <font>
                        <Font name="System Bold" size="24.0" />
                    </font>
                </Label>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Email" />
                        <TextField fx:id="emailField" promptText="Entrez votre email" />
                        <Label fx:id="emailErrorLabel" styleClass="error-label" textFill="RED" visible="false" />
                    </children>
                </VBox>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Mot de passe" />
                        <PasswordField fx:id="passwordField" promptText="Entrez votre mot de passe" />
                        <Label fx:id="passwordErrorLabel" styleClass="error-label" textFill="RED" visible="false" />
                    </children>
                </VBox>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Confirmer le mot de passe" />
                        <PasswordField fx:id="confirmPasswordField" promptText="Confirmez votre mot de passe" />
                        <Label fx:id="confirmPasswordErrorLabel" styleClass="error-label" textFill="RED" visible="false" />
                    </children>
                </VBox>
                <Label fx:id="passwordRequirementsLabel" text="Le mot de passe doit contenir au moins 8 caractères, une majuscule, une minuscule, un chiffre et un caractère spécial." textFill="#686868" wrapText="true">
                    <font>
                        <Font size="11.0" />
                    </font>
                </Label>
                <Button fx:id="registerButton" defaultButton="true" maxWidth="1.7976931348623157E308"
                    mnemonicParsing="false" onAction="#handleRegister" text="S'inscrire">
                    <VBox.margin>
                        <Insets top="10.0" />
                    </VBox.margin>
                </Button>
                <HBox alignment="CENTER" spacing="5.0">
                    <children>
                        <Label text="Vous avez déjà un compte ?" />
                        <Hyperlink onAction="#handleLoginLink" text="Se connecter" />
                    </children>
                </HBox>
            </children>
            <BorderPane.margin>
                <Insets left="20.0" right="20.0" />
            </BorderPane.margin>
            <padding>
                <Insets bottom="20.0" left="20.0" right="20.0" top="20.0" />
            </padding>
        </VBox>
    </center>
    <bottom>
        <HBox alignment="CENTER" prefHeight="50.0" spacing="10.0" BorderPane.alignment="CENTER">
            <children>
                <Label text="© 2025 Chat Application" textFill="#686868" />
            </children>
        </HBox>
    </bottom>
</BorderPane>



