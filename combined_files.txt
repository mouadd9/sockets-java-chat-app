// File: src/main/java/org/example/client/gui/ChatClientApplication.java
package org.example.client.gui;

import java.io.IOException;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.stage.Stage;

public class ChatClientApplication extends Application {

    @Override
    public void start(final Stage primaryStage) {
        try {
            // Vérification que les ressources FXML peuvent être chargées
            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            final Parent root = loader.load();
            
            primaryStage.setTitle("Chat Application");
            primaryStage.setScene(new Scene(root, 600, 400));
            primaryStage.setMinWidth(600);
            primaryStage.setMinHeight(400);
            primaryStage.show();
        } catch (final IOException e) {
            showErrorAndExit("Erreur de chargement FXML", 
                    "Impossible de charger l'interface utilisateur: " + e.getMessage());
        } catch (final Exception e) {
            showErrorAndExit("Erreur d'initialisation", 
                    "L'application n'a pas pu démarrer correctement: " + e.getMessage());
        }
    }

    /**
     * Affiche une erreur et quitte l'application
     */
    private void showErrorAndExit(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText("Erreur critique");
        alert.setContentText(message);
        alert.showAndWait();
        Platform.exit();
    }

    public static void main(final String[] args) {
        try {
            launch(args);
        } catch (final Exception e) {
            System.err.println("Erreur lors du lancement de l'application JavaFX:");
            System.err.println("Cette erreur peut être due à l'absence de modules JavaFX.");
            System.err.println("Veuillez lancer l'application avec les arguments VM suivants:");
            System.err.println("--module-path <chemin/vers/javafx-sdk>/lib --add-modules javafx.controls,javafx.fxml");
            e.printStackTrace();
        }
    }
    
    @Override
    public void stop() {
        // Nettoyage des ressources lors de la fermeture de l'application
        System.out.println("Application fermée");
    }
}



// File: src/main/java/org/example/client/gui/controllers/ChatController.java
package org.example.client.gui.controllers;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;
import java.util.Timer;
import java.util.TimerTask;
import java.util.stream.Collectors;

import org.example.client.gui.repository.JsonLocalMessageRepository;
import org.example.client.gui.service.AudioRecorderService;
import org.example.client.gui.service.ChatService;
import org.example.client.gui.service.ContactService;
import org.example.client.gui.service.FileService;
import org.example.client.gui.service.GroupService;
import org.example.client.gui.service.UserService;
import org.example.shared.model.Group;
import org.example.shared.model.Message;
import org.example.shared.model.User;
import org.example.shared.model.enums.MessageType;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.MenuItem;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import javafx.scene.media.MediaView;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.stage.FileChooser;
import javafx.stage.Modality;
import javafx.stage.Stage;

import javax.sound.sampled.LineUnavailableException;

public class ChatController {
    @FXML
    private Label userEmailLabel;
    @FXML
    private ListView<User> contactListView;
    @FXML
    private ListView<Group> groupListView;
    @FXML
    private TextField newContactField, messageField, groupNameField, memberEmailField;
    @FXML
    private VBox chatHistoryContainer;
    @FXML
    private ScrollPane chatScrollPane;
    @FXML
    private Label statusLabel;
    @FXML
    private Button mediaButton;
    @FXML
    private Button audioRecordButton;
    @FXML
    private HBox attachmentPreviewContainer;
    @FXML
    private Label attachmentNameLabel;
    @FXML
    private HBox recordingIndicatorContainer;
    @FXML
    private Label recordingTimeLabel;

    @FXML
    private Button mediaGalleryButton;


    private ChatService chatService;
    private String userEmail;
    private User selectedContactUser;
    private Group selectedGroup;

    private final ObservableList<User> contacts = FXCollections.observableArrayList();
    private final ObservableList<Group> groups = FXCollections.observableArrayList();

    private final JsonLocalMessageRepository localRepo = new JsonLocalMessageRepository();
    private final ContactService contactService = new ContactService();
    private final GroupService groupService = new GroupService();
    private final UserService userService = new UserService();
    private final FileService fileService = new FileService();
    private final AudioRecorderService audioRecorderService = new AudioRecorderService();

    private final Object loadLock = new Object();

    private static final DateTimeFormatter TIME_FMT = DateTimeFormatter.ofPattern("HH:mm");

    // Media attachment state
    private File selectedMediaFile;
    private MessageType selectedMediaType;

    // Audio recording state
    private boolean isRecording = false;
    private Timer recordingTimer;
    private int recordingSeconds = 0;

    @FXML
    public void initialize() {
        mediaGalleryButton.setOnAction(this::handleOpenMediaGallery);
        contactListView.setItems(contacts);
        groupListView.setItems(groups);

        contactListView.setCellFactory(list -> createCell(
                user -> user.getDisplayNameOrEmail(),
                user -> {
                    try {
                        return localRepo.getLastContactMessage(userEmail,
                                chatService.getCurrentUserId(),
                                user.getId());
                    } catch (final IOException e) {
                        return Optional.empty();
                    }
                },
                User::getAvatarUrl,
                msg -> msg.map(m -> {
                    try {
                        final String prefix = (m.getSenderUserId() == chatService.getCurrentUserId()) ? "Vous: " : "";
                        if (m.isTextMessage()) {
                            return prefix + truncate(m.getContent(), 30);
                        } else {
                            String mediaTypeIcon = getMediaTypeIcon(m.getType());
                            return prefix + mediaTypeIcon + " " + (m.getFileName() != null ? m.getFileName() : "Média");
                        }
                    } catch (final Exception e) {
                        return "Erreur chargement";
                    }
                }).orElse("")));

        groupListView.setCellFactory(list -> createCell(
                group -> group.getName(),
                group -> {
                    try {
                        return localRepo.getLastGroupMessage(userEmail, group.getId());
                    } catch (final IOException e) {
                        return Optional.empty();
                    }
                },
                group -> Optional.ofNullable(group.getProfilePictureUrl())
                        .filter(u -> !u.isEmpty())
                        .orElse("/images/default_group.png"),
                msg -> msg.map(m -> {
                    String name = "Inconnu";
                    try {
                        name = userService.getUserById(m.getSenderUserId()).getEmail().split("@")[0];
                    } catch (final IOException e) {
                        /* ignore */ }
                    final String prefix = (m.getSenderUserId() == chatService.getCurrentUserId() ? "Vous: "
                            : name + ": ");
                    if (m.isTextMessage()) {
                        return prefix + truncate(m.getContent(), 30);
                    } else {
                        String mediaTypeIcon = getMediaTypeIcon(m.getType());
                        return prefix + mediaTypeIcon + " " + (m.getFileName() != null ? m.getFileName() : "Média");
                    }
                }).orElse("")));

        contactListView.getSelectionModel().selectedItemProperty().addListener((obs, old, sel) -> {
            if (sel != null) {
                groupListView.getSelectionModel().clearSelection();
                selectedContactUser = sel;
                selectedGroup = null;
                loadContactConversation(selectedContactUser);
                setStatus("Conversation chargée avec " + selectedContactUser.getDisplayNameOrEmail());
            }
        });

        groupListView.getSelectionModel().selectedItemProperty().addListener((obs, old, sel) -> {
            if (sel != null) {
                contactListView.getSelectionModel().clearSelection();
                selectedGroup = sel;
                selectedContactUser = null;
                loadGroupConversation(sel);
                setStatus("Conversation de groupe chargée : " + sel.getName());
            }
        });

        messageField.setOnAction(this::handleSendMessage);

        // Initialize media button context menu
        final ContextMenu mediaMenu = new ContextMenu();

        MenuItem imageItem = new MenuItem("Image");
        imageItem.setOnAction(e -> openMediaFileChooser("Images", "*.png", "*.jpg", "*.jpeg", "*.gif"));

        MenuItem videoItem = new MenuItem("Vidéo");
        videoItem.setOnAction(e -> openMediaFileChooser("Vidéos", "*.mp4", "*.avi", "*.mov", "*.wmv"));

        MenuItem documentItem = new MenuItem("Document");
        documentItem.setOnAction(e -> openMediaFileChooser("Documents", "*.*"));

        mediaMenu.getItems().addAll(imageItem, videoItem, documentItem);

        mediaButton.setOnMouseClicked(e -> {
            mediaMenu.show(mediaButton, e.getScreenX(), e.getScreenY());
        });

        // Check if audio recording is supported
        if (!audioRecorderService.isAudioRecordingSupported()) {
            audioRecordButton.setDisable(true);
            audioRecordButton.setTooltip(new javafx.scene.control.Tooltip("L'enregistrement audio n'est pas pris en charge sur ce système"));
        }
    }

    private String getMediaTypeIcon(MessageType type) {
        switch (type) {
            case IMAGE:
                return "🖼️";
            case VIDEO:
                return "🎬";
            case AUDIO:
                return "🔊";
            case DOCUMENT:
                return "📄";
            default:
                return "";
        }
    }

    public void initData(final ChatService service, final String userEmail) {
        this.chatService = service;
        this.userEmail = userEmail;
        userEmailLabel.setText(userEmail);

        chatService.setMessageConsumer(this::handleIncomingMessage);
        loadContacts();
        loadGroups();
    }

    private <T> ListCell<T> createCell(
            final java.util.function.Function<T, String> nameFn,
            final java.util.function.Function<T, Optional<Message>> lastMsgFn,
            final java.util.function.Function<T, String> avatarUrlFn,
            final java.util.function.Function<Optional<Message>, String> msgTextFn) {
        return new ListCell<>() {
            private final ImageView avatar = createCircularAvatar(null, 30);
            private final Label nameLabel = new Label();
            private final Label lastMsgLabel = new Label();
            private final VBox textVBox = new VBox(nameLabel, lastMsgLabel);
            private final HBox hbox = new HBox(10, avatar, textVBox);
            {
                lastMsgLabel.setTextFill(Color.GRAY);
                lastMsgLabel.setFont(Font.font("System", FontWeight.NORMAL, 12));
                hbox.setAlignment(Pos.CENTER_LEFT);

                // Définir une image par défaut pour éviter les problèmes d'initialisation
                try (InputStream defaultImageStream = getClass().getResourceAsStream("/images/default_avatar.png")) {
                    if (defaultImageStream != null) {
                        avatar.setImage(new Image(defaultImageStream, 30, 30, true, true));
                    }
                } catch (final IOException e) {
                    System.err.println("Impossible de charger l'image par défaut: " + e.getMessage());
                }
            }

            @Override
            protected void updateItem(final T item, final boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setText(null);
                    setGraphic(null);
                    return;
                }

                nameLabel.setText(nameFn.apply(item));
                final String url = avatarUrlFn.apply(item);
                if (url != null) { // Éviter de passer une URL null à loadImage
                    final Image img = loadImage(url, 30);
                    if (img != null) {
                        avatar.setImage(img);
                    }
                }
                final Optional<Message> msg = lastMsgFn.apply(item);
                lastMsgLabel.setText(msgTextFn.apply(msg));
                setGraphic(hbox);
            }
        };
    }

    private Image loadImage(final String imageUrl, final double size) {

        try (InputStream stream = getClass().getResourceAsStream(imageUrl)) {
            if (stream != null) {
                return new Image(stream, size, size, true, true);
            } else {
                final String fallback = imageUrl.contains("group") ? "/images/default_group.png"
                        : "/images/default_avatar.png";
                try (InputStream fallbackStream = getClass().getResourceAsStream(fallback)) {
                    if (fallbackStream != null) {
                        return new Image(fallbackStream, size, size, true, true);
                    }
                }
            }
        } catch (final IOException e) {
            System.err.println("Erreur lors du chargement de l'image " + imageUrl + ": " + e.getMessage());
        }
        return null;
    }

    private ImageView createCircularAvatar(final String imageUrl, final double size) {
        final ImageView imageView = new ImageView();
        imageView.setFitWidth(size);
        imageView.setFitHeight(size);
        imageView.setPreserveRatio(true);
        final javafx.scene.shape.Circle clip = new javafx.scene.shape.Circle(size / 2, size / 2, size / 2);
        imageView.setClip(clip);

        return imageView;
    }

    private void addMessageToChat(final Message message) {
        try {
            final User sender = userService.getUserById(message.getSenderUserId());
            final User currentUser = userService.getUserByEmail(userEmail);
            final boolean isMine = message.getSenderUserId() == currentUser.getId();
            final boolean isGroup = message.getGroupId() != null;

            final HBox messageContainer = new HBox(10);
            messageContainer.getStyleClass().add("message-container");
            messageContainer.setAlignment(isMine ? Pos.CENTER_RIGHT : Pos.CENTER_LEFT);
            messageContainer.setPadding(new Insets(5));
            messageContainer.setMaxWidth(chatHistoryContainer.getWidth() * 0.8);

            // Avatar
            final ImageView avatar = createCircularAvatar(sender.getAvatarUrl(), 35);
            avatar.getStyleClass().add("message-avatar");
            if (!isMine)
                messageContainer.getChildren().add(avatar);

            // Contenu du message
            final VBox contentBox = new VBox(5);
            contentBox.getStyleClass().add("message-content");
            contentBox.getStyleClass().add(isMine ? "my-message" : "other-message");

            if (isGroup && !isMine) {
                final Label nameLabel = new Label(sender.getDisplayNameOrEmail());
                nameLabel.getStyleClass().add("sender-name");
                contentBox.getChildren().add(nameLabel);
            }

            // For text messages, use the existing logic
            if (message.isTextMessage()) {
                // Créer un conteneur horizontal pour le texte et l'horodatage
                final HBox contentTimeContainer = new HBox();
                contentTimeContainer.getStyleClass().add("content-time-container");

                // Texte du message
                final Label contentLabel = new Label(message.getContent());
                contentLabel.setWrapText(true);
                contentLabel.getStyleClass().add("message-text");
                contentLabel.setMaxWidth(chatHistoryContainer.getWidth() * 0.6); // Pour laisser de la place à l'horodatage

                // Horodatage
                final Label timeLabel = new Label(message.getTimestamp().format(TIME_FMT));
                timeLabel.getStyleClass().add("message-time");

                // Assembler le conteneur de message
                contentTimeContainer.getChildren().addAll(contentLabel, timeLabel);
                contentBox.getChildren().add(contentTimeContainer);
            }
            // For media messages, create appropriate media preview
            else {
                // Add media content based on the type
                switch (message.getType()) {
                    case IMAGE:
                        addImageContent(contentBox, message);
                        break;
                    case VIDEO:
                        addVideoContent(contentBox, message);
                        break;
                    case AUDIO:
                        addAudioContent(contentBox, message);
                        break;
                    case DOCUMENT:
                        addDocumentContent(contentBox, message);
                        break;
                    default:
                        // Fallback to text representation
                        final Label fallbackLabel = new Label("Type de média non pris en charge");
                        contentBox.getChildren().add(fallbackLabel);
                }

                // Add timestamp below the media
                final HBox timeContainer = new HBox();
                timeContainer.setAlignment(Pos.CENTER_RIGHT);
                final Label timeLabel = new Label(message.getTimestamp().format(TIME_FMT));
                timeLabel.getStyleClass().add("message-time");
                timeContainer.getChildren().add(timeLabel);
                contentBox.getChildren().add(timeContainer);
            }

            messageContainer.getChildren().add(contentBox);

            if (isMine)
                messageContainer.getChildren().add(avatar);

            Platform.runLater(() -> {
                chatHistoryContainer.getChildren().add(messageContainer);
                scrollToBottom();
            });
        } catch (final IOException e) {
            setStatus("Erreur d'affichage du message : " + e.getMessage());
        }
    }

    private void addImageContent(VBox contentBox, Message message) {
        try {
            File imageFile = chatService.getMediaFile(message);
            if (imageFile.exists()) {
                Image image = new Image(imageFile.toURI().toString());
                ImageView imageView = new ImageView(image);

                // Limit image size
                double maxWidth = 250;
                double maxHeight = 250;

                if (image.getWidth() > maxWidth || image.getHeight() > maxHeight) {
                    double widthRatio = maxWidth / image.getWidth();
                    double heightRatio = maxHeight / image.getHeight();
                    double ratio = Math.min(widthRatio, heightRatio);

                    imageView.setFitWidth(image.getWidth() * ratio);
                    imageView.setFitHeight(image.getHeight() * ratio);
                } else {
                    imageView.setFitWidth(image.getWidth());
                    imageView.setFitHeight(image.getHeight());
                }

                imageView.getStyleClass().add("image-preview");

                // Add click handler to open the image in a new window
                imageView.setOnMouseClicked(e -> openImageViewer(image));

                contentBox.getChildren().add(imageView);

                // Add filename if available
                if (message.getFileName() != null) {
                    Label filenameLabel = new Label(message.getFileName());
                    filenameLabel.setTextFill(Color.GRAY);
                    filenameLabel.setFont(Font.font("System", FontWeight.NORMAL, 10));
                    contentBox.getChildren().add(filenameLabel);
                }
            } else {
                Label errorLabel = new Label("Image non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (Exception e) {
            Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    private void addVideoContent(VBox contentBox, Message message) {
        try {
            File videoFile = chatService.getMediaFile(message);
            if (videoFile.exists()) {
                HBox videoContainer = new HBox();
                videoContainer.setAlignment(Pos.CENTER);
                videoContainer.getStyleClass().add("video-preview");

                // Create a thumbnail or play button
                Button playButton = new Button("▶");
                playButton.getStyleClass().add("audio-play-button");
                playButton.setOnAction(e -> openVideoPlayer(videoFile));

                Label videoLabel = new Label(message.getFileName() != null ? message.getFileName() : "Vidéo");

                videoContainer.getChildren().addAll(playButton, videoLabel);
                contentBox.getChildren().add(videoContainer);
            } else {
                Label errorLabel = new Label("Vidéo non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (Exception e) {
            Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    private void addAudioContent(VBox contentBox, Message message) {
        try {
            File audioFile = chatService.getMediaFile(message);
            if (audioFile.exists()) {
                HBox audioPlayer = new HBox(10);
                audioPlayer.setAlignment(Pos.CENTER_LEFT);
                audioPlayer.getStyleClass().add("audio-player");

                Button playButton = new Button("▶");
                playButton.getStyleClass().add("audio-play-button");

                ProgressBar progressBar = new ProgressBar(0);
                progressBar.getStyleClass().add("audio-progress");
                progressBar.setPrefWidth(150);

                Label durationLabel = new Label("00:00");

                // Create the media player
                Media media = new Media(audioFile.toURI().toString());
                MediaPlayer mediaPlayer = new MediaPlayer(media);

                // Configure the progress bar and duration label
                mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
                    double progress = newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds();
                    Platform.runLater(() -> {
                        progressBar.setProgress(progress);
                        durationLabel.setText(formatDuration(newVal));
                    });
                });

                mediaPlayer.setOnEndOfMedia(() -> {
                    mediaPlayer.stop();
                    mediaPlayer.seek(javafx.util.Duration.ZERO);
                    playButton.setText("▶");
                });

                // Configure the play button
                playButton.setOnAction(e -> {
                    if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                        mediaPlayer.pause();
                        playButton.setText("▶");
                    } else {
                        mediaPlayer.play();
                        playButton.setText("⏸");
                    }
                });

                audioPlayer.getChildren().addAll(playButton, progressBar, durationLabel);
                contentBox.getChildren().add(audioPlayer);
            } else {
                Label errorLabel = new Label("Audio non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (Exception e) {
            Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    private void addDocumentContent(VBox contentBox, Message message) {
        try {
            File documentFile = chatService.getMediaFile(message);
            if (documentFile.exists()) {
                HBox documentContainer = new HBox(10);
                documentContainer.getStyleClass().add("document-preview");

                Label iconLabel = new Label("📄");
                iconLabel.getStyleClass().add("document-icon");

                VBox documentInfo = new VBox(5);

                Label nameLabel = new Label(message.getFileName() != null ? message.getFileName() : "Document");
                nameLabel.getStyleClass().add("document-name");

                Label sizeLabel = new Label(formatFileSize(message.getFileSize()));
                sizeLabel.getStyleClass().add("document-size");

                documentInfo.getChildren().addAll(nameLabel, sizeLabel);
                documentContainer.getChildren().addAll(iconLabel, documentInfo);

                // Add click handler to open the document
                documentContainer.setOnMouseClicked(e -> openDocument(documentFile));

                contentBox.getChildren().add(documentContainer);
            } else {
                Label errorLabel = new Label("Document non disponible");
                contentBox.getChildren().add(errorLabel);
            }
        } catch (Exception e) {
            Label errorLabel = new Label("Erreur de chargement: " + e.getMessage());
            contentBox.getChildren().add(errorLabel);
        }
    }

    // Helper method to format file size
    private String formatFileSize(Long size) {
        if (size == null) {
            return "Taille inconnue";
        }

        if (size < 1024) {
            return size + " octets";
        } else if (size < 1024 * 1024) {
            return String.format("%.1f KB", size / 1024.0);
        } else if (size < 1024 * 1024 * 1024) {
            return String.format("%.1f MB", size / (1024.0 * 1024));
        } else {
            return String.format("%.1f GB", size / (1024.0 * 1024 * 1024));
        }
    }

    // Helper method to format duration
    private String formatDuration(javafx.util.Duration duration) {
        int seconds = (int) Math.floor(duration.toSeconds());
        int minutes = seconds / 60;
        seconds = seconds % 60;
        return String.format("%02d:%02d", minutes, seconds);
    }

    // Open image in a larger viewer
    private void openImageViewer(Image image) {
        Stage imageStage = new Stage();
        imageStage.initModality(Modality.APPLICATION_MODAL);
        imageStage.setTitle("Visionneuse d'image");

        ImageView imageView = new ImageView(image);
        imageView.setPreserveRatio(true);

        // Limit size to fit screen
        imageView.setFitWidth(Math.min(image.getWidth(), 800));
        imageView.setFitHeight(Math.min(image.getHeight(), 600));

        ScrollPane scrollPane = new ScrollPane(imageView);
        scrollPane.setPannable(true);
        scrollPane.setFitToWidth(true);
        scrollPane.setFitToHeight(true);

        Scene scene = new Scene(scrollPane);
        imageStage.setScene(scene);
        imageStage.show();
    }

    // Open video player
    private void openVideoPlayer(File videoFile) {
        Stage videoStage = new Stage();
        videoStage.initModality(Modality.APPLICATION_MODAL);
        videoStage.setTitle("Lecteur vidéo");

        Media media = new Media(videoFile.toURI().toString());
        MediaPlayer mediaPlayer = new MediaPlayer(media);
        MediaView mediaView = new MediaView(mediaPlayer);

        // Set up controls
        Button playButton = new Button("⏸");
        playButton.setOnAction(e -> {
            if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                mediaPlayer.pause();
                playButton.setText("▶");
            } else {
                mediaPlayer.play();
                playButton.setText("⏸");
            }
        });

        ProgressBar progressBar = new ProgressBar(0);
        progressBar.setPrefWidth(300);

        mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
            double progress = newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds();
            Platform.runLater(() -> progressBar.setProgress(progress));
        });

        // Add seek functionality
        progressBar.setOnMouseClicked(e -> {
            double percent = e.getX() / progressBar.getWidth();
            mediaPlayer.seek(mediaPlayer.getTotalDuration().multiply(percent));
        });

        HBox controls = new HBox(10, playButton, progressBar);
        controls.setAlignment(Pos.CENTER);
        controls.setPadding(new Insets(10));

        VBox root = new VBox(10, mediaView, controls);
        root.setAlignment(Pos.CENTER);

        Scene scene = new Scene(root, 640, 480);
        videoStage.setScene(scene);

        videoStage.setOnCloseRequest(e -> mediaPlayer.stop());

        videoStage.show();
        mediaPlayer.play();
    }

    // Open document with system default application
    private void openDocument(File documentFile) {
        try {
            java.awt.Desktop.getDesktop().open(documentFile);
        } catch (Exception e) {
            setStatus("Erreur lors de l'ouverture du document: " + e.getMessage());
        }
    }

    private void scrollToBottom() {
        Platform.runLater(() -> {
            chatScrollPane.setVvalue(1.0);
        });
    }

    private void setStatus(final String status) {
        Platform.runLater(() -> {
            statusLabel.setText(status);
            statusLabel.getStyleClass().add("status-label");
        });
    }

    private String truncate(final String text, final int maxLength) {
        return text.length() > maxLength ? text.substring(0, maxLength) + "..." : text;
    }

    private void loadContacts() {
        try {
            final List<User> contactList = contactService.getContactUsers(userEmail);
            Platform.runLater(() -> {
                contacts.clear();
                contacts.addAll(contactList);
            });
        } catch (final IOException e) {
            setStatus("Erreur lors du chargement des contacts : " + e.getMessage());
        }
    }

    private void loadGroups() {
        try {
            final long userId = userService.getUserByEmail(userEmail).getId();
            final List<Group> groupList = groupService.getGroupsForUser(userId);
            Platform.runLater(() -> {
                groups.clear();
                groups.addAll(groupList);
            });
        } catch (final IOException e) {
            setStatus("Erreur lors du chargement des groupes : " + e.getMessage());
        }
    }

    private void loadContactConversation(final User contactUser) {
        Platform.runLater(() -> {
            chatHistoryContainer.getChildren().clear();
            try {
                final long myId = userService.getUserByEmail(userEmail).getId();
                final long contactId = contactUser.getId();
                final List<Message> contactMessages = localRepo.loadContactMessages(userEmail, myId, contactId);
                contactMessages.forEach(this::addMessageToChat);
                scrollToBottom();
            } catch (final IOException e) {
                setStatus("Erreur lors du chargement de la conversation avec " + contactUser.getDisplayNameOrEmail()
                        + " : "
                        + e.getMessage());
            }
        });
    }

    private void loadGroupConversation(final Group group) {
        Platform.runLater(() -> {
            synchronized (loadLock) {
                chatHistoryContainer.getChildren().clear();
                try {
                    final List<Message> groupMessages = localRepo.loadGroupMessages(userEmail, group.getId());
                    groupMessages.forEach(this::addMessageToChat);
                    scrollToBottom();
                } catch (final IOException e) {
                    setStatus("Erreur lors du chargement de l'historique de groupe : " + e.getMessage());
                }
            }
        });
    }

    @FXML
    private void handleSendMessage(final ActionEvent event) {
        System.out.println("////////::selected Media File ");
        if (selectedMediaFile != null) {
            sendMediaMessage();
            return;
        }

        final String content = messageField.getText().trim();
        if (content.isEmpty()) {
            return;
        }

        try {
            Message message;
            if (selectedContactUser != null) {
                final User sender = userService.getUserByEmail(userEmail);
                message = Message.newDirectMessage(sender.getId(), selectedContactUser.getId(), content);
                chatService.sendMessage(message);
            } else if (selectedGroup != null) {
                final User sender = userService.getUserByEmail(userEmail);
                message = Message.newGroupMessage(sender.getId(), selectedGroup.getId(), content);
                chatService.sendMessage(message);
            } else {
                setStatus("Veuillez sélectionner un groupe ou un contact.");
                return;
            }
            messageField.clear();
            addMessageToChat(message);
            localRepo.addLocalMessage(userEmail, message);
            if (message.getGroupId() != null) {
                groupListView.refresh();
            } else {
                contactListView.refresh();
            }
            setStatus("Message envoyé");
        } catch (final IOException e) {
            setStatus("Erreur lors de l'envoi du message : " + e.getMessage());
        }
    }

    /**
     * Sends the currently selected media file as a message.
     */
    private void sendMediaMessage() {
        try {
            // Fix for null selectedMediaType - detect it from the file if null
            if (selectedMediaType == null && selectedMediaFile != null) {
                selectedMediaType = fileService.detectMessageType(selectedMediaFile.getName());
                System.out.println("Auto-detected media type: " + selectedMediaType);
            }
            Message message;

            if (selectedContactUser != null) {
                switch (selectedMediaType) {
                    case IMAGE:
                    case VIDEO:
                    case DOCUMENT:
                        message = chatService.createDirectMediaMessage(
                                userEmail, selectedContactUser.getEmail(), selectedMediaFile);
                        break;
                    case AUDIO:
                        message = chatService.createDirectAudioMessage(
                                userEmail, selectedContactUser.getEmail(), selectedMediaFile);
                        break;
                    default:
                        throw new IllegalStateException("Type de média non pris en charge: " + selectedMediaType);
                }
            } else if (selectedGroup != null) {
                switch (selectedMediaType) {
                    case IMAGE:
                    case VIDEO:
                    case DOCUMENT:
                        message = chatService.createGroupMediaMessage(
                                userEmail, selectedGroup.getId(), selectedMediaFile);
                        break;
                    case AUDIO:
                        message = chatService.createGroupAudioMessage(
                                userEmail, selectedGroup.getId(), selectedMediaFile);
                        break;
                    default:
                        throw new IllegalStateException("Type de média non pris en charge: " + selectedMediaType);
                }
            } else {
                setStatus("Veuillez sélectionner un groupe ou un contact.");
                return;
            }

            // Send the message
            chatService.sendMessage(message);

            // Clear the selected media
            clearMediaSelection();

            // Add the message to the chat and local repository
            addMessageToChat(message);
            localRepo.addLocalMessage(userEmail, message);

            // Refresh the appropriate list view
            if (message.getGroupId() != null) {
                groupListView.refresh();
            } else {
                contactListView.refresh();
            }

            String mediaTypeStr = "";
            switch (selectedMediaType) {
                case IMAGE: mediaTypeStr = "Image"; break;
                case VIDEO: mediaTypeStr = "Vidéo"; break;
                case AUDIO: mediaTypeStr = "Audio"; break;
                case DOCUMENT: mediaTypeStr = "Document"; break;
            }

            setStatus(mediaTypeStr + " envoyé(e)");
        } catch (final IOException e) {
            setStatus("Erreur lors de l'envoi du média : " + e.getMessage());
        }
    }

    private void handleIncomingMessage(final Message message) {
        Platform.runLater(() -> {
            try {
                localRepo.addLocalMessage(userEmail, message);

                // Message de groupe
                if (message.getGroupId() != null) {
                    // Vérifier si le groupe est déjà dans la liste, sinon recharger les groupes
                    final boolean groupExists = groups.stream()
                            .anyMatch(g -> g.getId() == message.getGroupId());
                    if (!groupExists) {
                        loadGroups();
                    } else {
                        groupListView.refresh();
                    }

                    // Afficher le message si le groupe est actuellement sélectionné
                    if (selectedGroup != null && selectedGroup.getId() == message.getGroupId()) {
                        addMessageToChat(message);
                    }
                    setStatus("Nouveau message de groupe reçu");
                }
                // Message direct
                else {
                    final User sender = userService.getUserById(message.getSenderUserId());

                    // Ajouter le contact s'il n'existe pas
                    if (sender != null && !contacts.contains(sender)) {
                        contacts.add(sender);
                    }
                    contactListView.refresh();

                    // Afficher le message si la conversation est actuellement sélectionnée
                    if (selectedContactUser != null &&
                            sender.getId() == selectedContactUser.getId()) {
                        addMessageToChat(message);
                    }

                    if (message.isTextMessage()) {
                        setStatus("Nouveau message reçu");
                    } else {
                        setStatus("Nouveau média reçu");
                    }
                }

                scrollToBottom();
            } catch (final IOException e) {
                setStatus("Erreur lors du traitement du message : " + e.getMessage());
            }
        });
    }

    @FXML
    private void handleAddContact() {
        final String email = newContactField.getText().trim();

        if (email.isEmpty()) {
            setStatus("Veuillez saisir un email");
            return;
        }

        // Vérifier si le contact existe déjà dans la liste locale
        final boolean contactExists = contacts.stream()
                .anyMatch(user -> user.getEmail().equalsIgnoreCase(email));

        if (contactExists) {
            setStatus("Ce contact existe déjà.");
            newContactField.clear(); // Optionnel: vider le champ
            return;
        }

        try {
            final User addedUser = contactService.addContactUser(userEmail, email);
            if (addedUser != null) {
                contacts.add(addedUser);
                newContactField.clear();
                setStatus("Contact ajouté: " + addedUser.getDisplayNameOrEmail());
            }
        } catch (final IllegalArgumentException e) {
            setStatus("Erreur: " + e.getMessage());
        } catch (final IOException e) {
            setStatus("Erreur de connexion: " + e.getMessage());
        }
    }

    @FXML
    private void handleRemoveContact() {
        if (selectedContactUser == null) {
            setStatus("Aucun contact sélectionné pour la suppression");
            return;
        }
        try {
            final boolean removed = contactService.removeContact(userEmail, selectedContactUser.getEmail());
            if (removed) {
                contacts.remove(selectedContactUser);
                chatHistoryContainer.getChildren().clear();
                final long myId = chatService.getCurrentUserId();
                localRepo.removeConversation(userEmail, myId, selectedContactUser.getId());
                setStatus("Contact et conversation supprimés: " + selectedContactUser.getDisplayNameOrEmail());
                selectedContactUser = null;
            } else {
                setStatus("La suppression du contact a échoué");
            }
        } catch (final IOException e) {
            setStatus("Erreur: " + e.getMessage());
        }
    }

    @FXML
    private void handleCreateGroup(final ActionEvent event) {
        final String groupName = groupNameField.getText().trim();
        if (groupName.isEmpty()) {
            setStatus("Le nom du groupe est obligatoire");
            return;
        }
        final long ownerId = chatService.getCurrentUserId();
        final Group createdGroup = groupService.createGroup(groupName, ownerId);
        if (createdGroup.getId() > 0) {
            setStatus("Groupe créé : " + createdGroup.getName());
            groups.add(createdGroup);
            groupNameField.clear();
        } else {
            setStatus("Erreur lors de la création du groupe");
        }
    }

    @FXML
    private void handleAddMemberToGroup(final ActionEvent event) {
        final String memberEmail = memberEmailField.getText().trim();
        if (memberEmail.isEmpty()) {
            setStatus("Veuillez entrer l'email du membre à ajouter");
            return;
        }
        final Group selectedGroup = groupListView.getSelectionModel().getSelectedItem();
        if (selectedGroup == null) {
            setStatus("Veuillez sélectionner un groupe");
            return;
        }
        try {
            final long memberId = userService.getUserByEmail(memberEmail).getId();
            final boolean success = groupService.addMemberToGroup(selectedGroup.getId(), memberId);
            if (success) {
                setStatus("Membre ajouté avec succès");
                memberEmailField.clear();
            } else {
                setStatus("Le membre est déjà présent ou l'ajout a échoué");
            }
        } catch (final IOException e) {
            setStatus("Erreur lors de l'ajout du membre : " + e.getMessage());
        }
    }

    @FXML
    private void handleLogout() {
        try {
            chatService.disconnect();
            chatHistoryContainer.getChildren().clear();

            // final Stage stage = (Stage) userEmailLabel.getScene().getWindow();
            // stage.close();

            final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            final Parent loginView = loader.load();

            final Stage stage = (Stage) userEmailLabel.getScene().getWindow();
            stage.setTitle("Chat Application");
            stage.setScene(new Scene(loginView, 600, 400));
            stage.centerOnScreen();
        } catch (final IOException e) {
            setStatus("Erreur lors de la déconnexion: " + e.getMessage());
        }
    }



    private void openMediaFileChooser(final String description, final String... extensions) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Sélectionner un fichier");
        fileChooser.getExtensionFilters().add(
                new FileChooser.ExtensionFilter(description, extensions));

        File selectedFile = fileChooser.showOpenDialog(mediaButton.getScene().getWindow());
        if (selectedFile != null) {
            selectedMediaFile = selectedFile;
            selectedMediaType = fileService.detectMessageType(selectedFile.getName());

            // Show the attachment preview
            attachmentNameLabel.setText(selectedFile.getName());
            attachmentPreviewContainer.setManaged(true);
            attachmentPreviewContainer.setVisible(true);

            // Clear the message field
            messageField.clear();
            messageField.setPromptText("Appuyez sur Envoyer pour envoyer le fichier");
        }
    }

    @FXML
    private void handleRemoveAttachment() {
        clearMediaSelection();
    }

    private void clearMediaSelection() {
        selectedMediaFile = null;
        selectedMediaType = null;
        attachmentPreviewContainer.setManaged(false);
        attachmentPreviewContainer.setVisible(false);
        messageField.setPromptText("Écrire un message...");
    }

    @FXML
    private void handleAudioRecordButtonClick() {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    }

    private void startRecording() {
        try {
            // Start recording
            audioRecorderService.startRecording();
            isRecording = true;

            // Update UI
            audioRecordButton.setText("■");
            audioRecordButton.getStyleClass().add("recording");
            recordingIndicatorContainer.setManaged(true);
            recordingIndicatorContainer.setVisible(true);

            // Disable other inputs
            messageField.setDisable(true);
            mediaButton.setDisable(true);

            // Start timer
            recordingSeconds = 0;
            recordingTimeLabel.setText("00:00");
            recordingTimer = new Timer();
            recordingTimer.scheduleAtFixedRate(new TimerTask() {
                @Override
                public void run() {
                    recordingSeconds++;
                    Platform.runLater(() -> {
                        int minutes = recordingSeconds / 60;
                        int seconds = recordingSeconds % 60;
                        recordingTimeLabel.setText(String.format("%02d:%02d", minutes, seconds));
                    });
                }
            }, 1000, 1000);

            setStatus("Enregistrement audio démarré");
        } catch (LineUnavailableException e) {
            setStatus("Erreur lors du démarrage de l'enregistrement: " + e.getMessage());
        }
    }

    private void stopRecording() {
        try {
            // Stop the timer
            if (recordingTimer != null) {
                recordingTimer.cancel();
                recordingTimer = null;
            }

            // Stop recording and get the recorded file
            File audioFile = audioRecorderService.stopRecording();
            isRecording = false;

            // Update UI
            audioRecordButton.setText("🎤");
            audioRecordButton.getStyleClass().remove("recording");
            recordingIndicatorContainer.setManaged(false);
            recordingIndicatorContainer.setVisible(false);

            // Re-enable inputs
            messageField.setDisable(false);
            mediaButton.setDisable(false);

            // If we have a valid audio file, set it as the selected media
            if (audioFile != null && audioFile.exists()) {
                selectedMediaFile = audioFile;
                selectedMediaType = MessageType.AUDIO;

                // Show the attachment preview
                attachmentNameLabel.setText("Enregistrement audio (" + formatDuration(recordingSeconds) + ")");
                attachmentPreviewContainer.setManaged(true);
                attachmentPreviewContainer.setVisible(true);

                setStatus("Enregistrement audio terminé");
            } else {
                setStatus("L'enregistrement audio a échoué");
            }
        } catch (IOException e) {
            setStatus("Erreur lors de l'arrêt de l'enregistrement: " + e.getMessage());
        }
    }

    private String formatDuration(int seconds) {
        int minutes = seconds / 60;
        seconds = seconds % 60;
        return String.format("%02d:%02d", minutes, seconds);
    }
    @FXML
    private void handleOpenMediaGallery(ActionEvent event) {
        try {
            // First, check if we have a selected conversation
            if (selectedContactUser == null && selectedGroup == null) {
                setStatus("Veuillez sélectionner un contact ou un groupe pour voir la galerie média");
                return;
            }

            // Load all media messages for the current conversation
            List<Message> mediaMessages;
            String conversationName;
            boolean isGroup;

            if (selectedContactUser != null) {
                // Direct conversation
                final long myId = userService.getUserByEmail(userEmail).getId();
                final long contactId = selectedContactUser.getId();
                mediaMessages = localRepo.loadContactMessages(userEmail, myId, contactId)
                        .stream()
                        .filter(Message::isMediaMessage)
                        .collect(Collectors.toList());
                conversationName = selectedContactUser.getDisplayNameOrEmail();
                isGroup = false;
            } else {
                // Group conversation
                mediaMessages = localRepo.loadGroupMessages(userEmail, selectedGroup.getId())
                        .stream()
                        .filter(Message::isMediaMessage)
                        .collect(Collectors.toList());
                conversationName = selectedGroup.getName();
                isGroup = true;
            }

            // Check if there are any media messages
            if (mediaMessages.isEmpty()) {
                setStatus("Aucun média trouvé dans cette conversation");
                return;
            }

            // Load the media gallery
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/media_gallery.fxml"));
            Parent root = loader.load();

            // Get the controller and set up the gallery
            MediaGalleryController galleryController = loader.getController();
            galleryController.setData(chatService, userService, mediaMessages, conversationName, isGroup);

            // Create and show the gallery
            Stage galleryStage = new Stage();
            galleryStage.setTitle("Galerie média - " + conversationName);
            galleryStage.initModality(Modality.WINDOW_MODAL);
            galleryStage.initOwner(mediaGalleryButton.getScene().getWindow());
            galleryStage.setScene(new Scene(root));
            galleryStage.show();

        } catch (IOException e) {
            setStatus("Erreur lors de l'ouverture de la galerie média: " + e.getMessage());
        }
    }
    @FXML
    private void handleMediaButtonClick(final ActionEvent event) {
        try {
            // Load the media dialog
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/media_dialog.fxml"));
            Parent root = loader.load();

            // Get the controller and set up the send handler
            MediaDialogController dialogController = loader.getController();
            dialogController.setSendHandler((file, type) -> {
                // When media is selected in the dialog, handle it here
                selectedMediaFile = file;
                selectedMediaType = type;

                // Show the attachment preview
                attachmentNameLabel.setText(file.getName());
                attachmentPreviewContainer.setManaged(true);
                attachmentPreviewContainer.setVisible(true);

                // Clear the message field
                messageField.clear();
                messageField.setPromptText("Appuyez sur Envoyer pour envoyer le fichier");
            });

            // Create and show the dialog
            Stage dialogStage = new Stage();
            dialogStage.setTitle("Envoyer un média");
            dialogStage.initModality(Modality.WINDOW_MODAL);
            dialogStage.initOwner(mediaButton.getScene().getWindow());
            dialogStage.setScene(new Scene(root));
            dialogStage.showAndWait();

        } catch (IOException e) {
            setStatus("Erreur lors de l'ouverture du dialogue média: " + e.getMessage());
        }
    }
}


// File: src/main/java/org/example/client/gui/controllers/LoginController.java
package org.example.client.gui.controllers;

import java.io.IOException;

import org.example.client.gui.service.ChatService;
import org.example.shared.dto.Credentials;

import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.stage.Stage;

public class LoginController {

    @FXML
    private TextField emailField;
    
    @FXML
    private PasswordField passwordField;
    
    @FXML
    private Button loginButton;
    
    private final ChatService chatService;
    
    public LoginController() {
        this.chatService = new ChatService();
    }
    
    @FXML
    public void initialize() {
        // Activer le bouton de connexion seulement si des valeurs sont entrées
        loginButton.disableProperty().bind(
            emailField.textProperty().isEmpty().or(
            passwordField.textProperty().isEmpty())
        );
    }

    // this function takes in the login event from the view extracts credentials and calls connect from chat service
    @FXML
    private void handleLogin(final ActionEvent event) {
        // here we get credentials
        final String email = emailField.getText().trim();
        final String password = passwordField.getText();

        // Débinder la propriété disable avant de la modifier
        loginButton.disableProperty().unbind();
        loginButton.setDisable(true); // Désactiver le bouton

        new Thread(() -> {
            try {
                final Credentials credentials = new Credentials(email, password);
                // here we call connect() in chat service
                // connect does the following :
                    // - establishes connection with server socket (a client socket is created in server side for further communication)
                    // - it send credentials using the output stream and waits for response the server creates a client handler and checks authenticates client
                    // - if authenticated we run code in a thread (to load messages sent to the client offline using loadMessages() ), and we return "true".
                final boolean success = chatService.connect(credentials);
                
                Platform.runLater(() -> {
                    if (success) {
                        try {
                            // if authentication is successful we open the chat view
                            openChatWindow(email);
                        } catch (final IOException e) {
                            showError("Erreur d'interface", "Impossible d'ouvrir la fenêtre de chat: " + e.getMessage());
                            rebindLoginButton();
                        }
                    } else {
                        showError("Échec de connexion", "Email ou mot de passe incorrect");
                        rebindLoginButton();
                    }
                });
            } catch (final IOException e) {
                Platform.runLater(() -> {
                    showError("Erreur de connexion", "Impossible de se connecter au serveur: " + e.getMessage());
                    rebindLoginButton();
                });
            }
        }).start();
    }
    
    /**
     * Rétablit le binding du bouton de login
     */
    private void rebindLoginButton() {
        loginButton.disableProperty().unbind(); // S'assurer qu'il n'y a pas de binding actif
        loginButton.setDisable(false); // Réactiver le bouton
        // Rebinder le bouton avec la condition initiale
        loginButton.disableProperty().bind(
            emailField.textProperty().isEmpty().or(
            passwordField.textProperty().isEmpty())
        );
    }

    // this function loads chat.fxml and configures it with a controller chatController
    private void openChatWindow(final String userEmail) throws IOException {
        // Charger la vue de chat
        final FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/chat.fxml"));
        final Parent chatView = loader.load();
        
        // Configurer le contrôleur de chat
        final ChatController chatController = loader.getController();
        chatController.initData(chatService, userEmail);
        
        // Créer et afficher la nouvelle scène
        final Scene chatScene = new Scene(chatView, 800, 600);
        final Stage currentStage = (Stage) loginButton.getScene().getWindow();
        
        currentStage.setTitle("Chat - " + userEmail);
        currentStage.setScene(chatScene);
        currentStage.setMinWidth(800);
        currentStage.setMinHeight(600);
        currentStage.centerOnScreen();
    }
    
    private void showError(final String title, final String message) {
        final Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}



// File: src/main/java/org/example/client/gui/controllers/MediaDialogController.java
package org.example.client.gui.controllers;

import java.io.File;
import java.io.IOException;
import java.util.Timer;
import java.util.TimerTask;

import org.example.client.gui.service.AudioRecorderService;
import org.example.shared.model.enums.MessageType;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import javafx.scene.media.MediaView;
import javafx.stage.FileChooser;
import javafx.stage.Stage;

import javax.sound.sampled.LineUnavailableException;

public class MediaDialogController {

    @FXML
    private ComboBox<String> mediaTypeComboBox;

    @FXML
    private TextField filePathField;

    @FXML
    private VBox previewContainer;

    @FXML
    private HBox recordAudioContainer;

    @FXML
    private Button recordButton;

    @FXML
    private Label recordingTimeLabel;

    @FXML
    private ProgressBar audioLevelIndicator;

    @FXML
    private Button sendButton;

    private File selectedFile;
    private MessageType selectedType;
    private boolean isRecording = false;
    private Timer recordingTimer;
    private int recordingSeconds = 0;

    private final AudioRecorderService audioRecorderService = new AudioRecorderService();

    // Interface for handling send action
    public interface MediaSendHandler {
        void onMediaSelected(File file, MessageType type);
    }

    private MediaSendHandler sendHandler;

    @FXML
    public void initialize() {
        // Initialize media type combo box
        mediaTypeComboBox.setItems(FXCollections.observableArrayList(
                "Image", "Vidéo", "Document", "Audio"
        ));

        // Add listener to the combo box
        mediaTypeComboBox.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                switch (newVal) {
                    case "Image":
                        selectedType = MessageType.IMAGE;
                        recordAudioContainer.setVisible(false);
                        recordAudioContainer.setManaged(false);
                        break;
                    case "Vidéo":
                        selectedType = MessageType.VIDEO;
                        recordAudioContainer.setVisible(false);
                        recordAudioContainer.setManaged(false);
                        break;
                    case "Document":
                        selectedType = MessageType.DOCUMENT;
                        recordAudioContainer.setVisible(false);
                        recordAudioContainer.setManaged(false);
                        break;
                    case "Audio":
                        selectedType = MessageType.AUDIO;
                        recordAudioContainer.setVisible(true);
                        recordAudioContainer.setManaged(true);
                        break;
                }

                // Clear the file selection when changing type
                selectedFile = null;
                filePathField.clear();
                updatePreview();
            }
        });

        // Set default selected type
        mediaTypeComboBox.getSelectionModel().select(0);

        // Disable send button initially
        sendButton.setDisable(true);
    }

    /**
     * Sets the handler for send actions.
     *
     * @param handler The handler
     */
    public void setSendHandler(MediaSendHandler handler) {
        this.sendHandler = handler;
    }

    @FXML
    private void handleBrowseFile(ActionEvent event) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Sélectionner un fichier");

        // Set extension filters based on selected type
        switch (selectedType) {
            case IMAGE:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Images", "*.png", "*.jpg", "*.jpeg", "*.gif", "*.bmp"));
                break;
            case VIDEO:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Vidéos", "*.mp4", "*.avi", "*.mov", "*.wmv", "*.flv", "*.mkv"));
                break;
            case AUDIO:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Fichiers audio", "*.mp3", "*.wav", "*.ogg", "*.aac", "*.wma", "*.flac"));
                break;
            case DOCUMENT:
                fileChooser.getExtensionFilters().add(
                        new FileChooser.ExtensionFilter("Tous les fichiers", "*.*"));
                break;
        }

        // Show file chooser dialog
        File file = fileChooser.showOpenDialog(filePathField.getScene().getWindow());
        if (file != null) {
            selectedFile = file;
            filePathField.setText(file.getAbsolutePath());
            sendButton.setDisable(false);
            updatePreview();
        }
    }

    @FXML
    private void handleRecordAudio(ActionEvent event) {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    }

    private void startRecording() {
        try {
            // Start recording
            audioRecorderService.startRecording();
            isRecording = true;

            // Update UI
            recordButton.setText("■ Arrêter");
            recordingTimeLabel.setText("00:00");

            // Start timer
            recordingSeconds = 0;
            recordingTimer = new Timer();
            recordingTimer.scheduleAtFixedRate(new TimerTask() {
                @Override
                public void run() {
                    recordingSeconds++;
                    Platform.runLater(() -> {
                        int minutes = recordingSeconds / 60;
                        int seconds = recordingSeconds % 60;
                        recordingTimeLabel.setText(String.format("%02d:%02d", minutes, seconds));
                    });
                }
            }, 1000, 1000);

        } catch (LineUnavailableException e) {
            System.err.println("Error starting recording: " + e.getMessage());
        }
    }

    private void stopRecording() {
        try {
            // Stop the timer
            if (recordingTimer != null) {
                recordingTimer.cancel();
                recordingTimer = null;
            }

            // Stop recording and get the recorded file
            File audioFile = audioRecorderService.stopRecording();
            isRecording = false;

            // Update UI
            recordButton.setText("🎤 Enregistrer");

            // If we have a valid audio file, set it as the selected file
            if (audioFile != null && audioFile.exists()) {
                selectedFile = audioFile;
                filePathField.setText("Enregistrement audio (" + formatDuration(recordingSeconds) + ")");
                sendButton.setDisable(false);
                updatePreview();
            }
        } catch (IOException e) {
            System.err.println("Error stopping recording: " + e.getMessage());
        }
    }

    private String formatDuration(int seconds) {
        int minutes = seconds / 60;
        seconds = seconds % 60;
        return String.format("%02d:%02d", minutes, seconds);
    }

    private void updatePreview() {
        previewContainer.getChildren().clear();

        if (selectedFile == null) {
            return;
        }

        switch (selectedType) {
            case IMAGE:
                try {
                    Image image = new Image(selectedFile.toURI().toString());
                    ImageView imageView = new ImageView(image);

                    // Limit preview size
                    imageView.setFitWidth(300);
                    imageView.setFitHeight(200);
                    imageView.setPreserveRatio(true);

                    previewContainer.getChildren().add(imageView);
                } catch (Exception e) {
                    previewContainer.getChildren().add(new Label("Erreur de chargement de l'image"));
                }
                break;

            case VIDEO:
                try {
                    Media media = new Media(selectedFile.toURI().toString());
                    MediaPlayer mediaPlayer = new MediaPlayer(media);
                    MediaView mediaView = new MediaView(mediaPlayer);

                    // Limit preview size
                    mediaView.setFitWidth(300);
                    mediaView.setFitHeight(200);
                    mediaView.setPreserveRatio(true);

                    // Add play/pause button
                    Button playButton = new Button("▶ Play");
                    playButton.setOnAction(e -> {
                        if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                            mediaPlayer.pause();
                            playButton.setText("▶ Play");
                        } else {
                            mediaPlayer.play();
                            playButton.setText("⏸ Pause");
                        }
                    });

                    VBox videoBox = new VBox(10, mediaView, playButton);
                    previewContainer.getChildren().add(videoBox);
                } catch (Exception e) {
                    previewContainer.getChildren().add(new Label("Erreur de chargement de la vidéo"));
                }
                break;

            case AUDIO:
                try {
                    HBox audioPlayer = new HBox(10);
                    audioPlayer.setAlignment(javafx.geometry.Pos.CENTER_LEFT);

                    Button playButton = new Button("▶");

                    if (selectedFile.exists() && selectedFile.getName().toLowerCase().endsWith(".wav")) {
                        Media media = new Media(selectedFile.toURI().toString());
                        MediaPlayer mediaPlayer = new MediaPlayer(media);

                        playButton.setOnAction(e -> {
                            if (mediaPlayer.getStatus() == MediaPlayer.Status.PLAYING) {
                                mediaPlayer.pause();
                                playButton.setText("▶");
                            } else {
                                mediaPlayer.play();
                                playButton.setText("⏸");
                            }
                        });
                    } else {
                        // For non-playable files, just show a placeholder
                        playButton.setDisable(true);
                    }

                    Label audioLabel = new Label(selectedFile.getName());

                    audioPlayer.getChildren().addAll(playButton, audioLabel);
                    previewContainer.getChildren().add(audioPlayer);
                } catch (Exception e) {
                    previewContainer.getChildren().add(new Label("Erreur de chargement de l'audio"));
                }
                break;

            case DOCUMENT:
                Label docIcon = new Label("📄");
                docIcon.setStyle("-fx-font-size: 32px;");

                Label docName = new Label(selectedFile.getName());

                Label docSize = new Label(formatFileSize(selectedFile.length()));
                docSize.setStyle("-fx-text-fill: #888;");

                VBox docBox = new VBox(5, docIcon, docName, docSize);
                docBox.setAlignment(javafx.geometry.Pos.CENTER);

                previewContainer.getChildren().add(docBox);
                break;
        }
    }

    private String formatFileSize(long size) {
        if (size < 1024) {
            return size + " octets";
        } else if (size < 1024 * 1024) {
            return String.format("%.1f KB", size / 1024.0);
        } else if (size < 1024 * 1024 * 1024) {
            return String.format("%.1f MB", size / (1024.0 * 1024));
        } else {
            return String.format("%.1f GB", size / (1024.0 * 1024 * 1024));
        }
    }

    @FXML
    private void handleSend(ActionEvent event) {
        if (selectedFile != null && sendHandler != null) {
            sendHandler.onMediaSelected(selectedFile, selectedType);
            closeDialog();
        }
    }

    @FXML
    private void handleCancel(ActionEvent event) {
        // Stop recording if in progress
        if (isRecording) {
            try {
                audioRecorderService.stopRecording();
                if (recordingTimer != null) {
                    recordingTimer.cancel();
                }
            } catch (IOException e) {
                // Ignore
            }
        }

        closeDialog();
    }

    private void closeDialog() {
        Stage stage = (Stage) sendButton.getScene().getWindow();
        stage.close();
    }
}


// File: src/main/java/org/example/client/gui/controllers/MediaGalleryController.java
package org.example.client.gui.controllers;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.example.client.gui.service.ChatService;
import org.example.client.gui.service.UserService;
import org.example.shared.model.Message;
import org.example.shared.model.User;
import org.example.shared.model.enums.MessageType;

import javafx.collections.FXCollections;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.geometry.Pos;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class MediaGalleryController {

    @FXML
    private Label titleLabel;

    @FXML
    private ComboBox<String> mediaTypeFilter;

    @FXML
    private FlowPane mediaContainer;

    @FXML
    private Label statsLabel;

    private ChatService chatService;
    private UserService userService;
    private List<Message> mediaMessages;
    private String conversationName;
    private boolean isGroup;

    /**
     * Initializes the controller.
     */
    @FXML
    public void initialize() {
        // Initialize media type filter
        mediaTypeFilter.setItems(FXCollections.observableArrayList(
                "Tous", "Images", "Vidéos", "Documents", "Audio"
        ));

        // Add listener to filter media by type
        mediaTypeFilter.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                filterMediaByType(newVal);
            }
        });

        // Set default selection
        mediaTypeFilter.getSelectionModel().select(0);
    }

    /**
     * Sets the data for the gallery.
     *
     * @param chatService The chat service
     * @param userService The user service
     * @param mediaMessages The list of media messages
     * @param conversationName The name of the conversation
     * @param isGroup Whether the conversation is a group
     */
    public void setData(ChatService chatService, UserService userService, List<Message> mediaMessages,
                        String conversationName, boolean isGroup) {
        this.chatService = chatService;
        this.userService = userService;
        this.mediaMessages = new ArrayList<>(mediaMessages);
        this.conversationName = conversationName;
        this.isGroup = isGroup;

        // Update title
        titleLabel.setText("Galerie média - " + conversationName);

        // Load all media initially
        filterMediaByType("Tous");
    }

    /**
     * Filters the media by type.
     *
     * @param filterType The filter type
     */
    private void filterMediaByType(String filterType) {
        List<Message> filteredMessages;

        switch (filterType) {
            case "Images":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isImageMessage)
                        .collect(Collectors.toList());
                break;
            case "Vidéos":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isVideoMessage)
                        .collect(Collectors.toList());
                break;
            case "Documents":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isDocumentMessage)
                        .collect(Collectors.toList());
                break;
            case "Audio":
                filteredMessages = mediaMessages.stream()
                        .filter(Message::isAudioMessage)
                        .collect(Collectors.toList());
                break;
            default:
                filteredMessages = mediaMessages;
                break;
        }

        displayMedia(filteredMessages);
        updateStats(filteredMessages.size());
    }

    /**
     * Displays the media in the gallery.
     *
     * @param messages The messages to display
     */
    private void displayMedia(List<Message> messages) {
        mediaContainer.getChildren().clear();

        for (Message message : messages) {
            try {
                // Get the file
                File mediaFile = chatService.getMediaFile(message);

                // Create the media item based on type
                VBox mediaItem = createMediaItem(message, mediaFile);

                mediaContainer.getChildren().add(mediaItem);
            } catch (Exception e) {
                System.err.println("Error displaying media: " + e.getMessage());
            }
        }
    }

    /**
     * Creates a media item for the gallery.
     *
     * @param message The message
     * @param mediaFile The media file
     * @return The media item
     */
    private VBox createMediaItem(Message message, File mediaFile) throws IOException {
        VBox item = new VBox(5);
        item.setAlignment(Pos.CENTER);
        item.setStyle("-fx-background-color: #f5f5f5; -fx-padding: 10px; -fx-border-radius: 5px; " +
                "-fx-background-radius: 5px; -fx-border-color: #ddd;");
        item.setPrefWidth(150);
        item.setPrefHeight(180);

        // Create the preview based on media type
        switch (message.getType()) {
            case IMAGE:
                createImagePreview(item, mediaFile);
                break;
            case VIDEO:
                createVideoPreview(item);
                break;
            case AUDIO:
                createAudioPreview(item);
                break;
            case DOCUMENT:
                createDocumentPreview(item, message);
                break;
            default:
                item.getChildren().add(new Label("Type non pris en charge"));
                break;
        }

        // Add sender name
        try {
            User sender = userService.getUserById(message.getSenderUserId());
            Label senderLabel = new Label(sender.getDisplayNameOrEmail());
            senderLabel.setStyle("-fx-font-size: 10px; -fx-text-fill: #888;");
            item.getChildren().add(senderLabel);
        } catch (IOException e) {
            // Ignore
        }

        // Make the item clickable to open the media
        item.setOnMouseClicked(e -> openMedia(message, mediaFile));

        return item;
    }

    private void createImagePreview(VBox item, File mediaFile) {
        try {
            Image image = new Image(mediaFile.toURI().toString(), 130, 130, true, true);
            ImageView imageView = new ImageView(image);
            imageView.setFitWidth(130);
            imageView.setFitHeight(130);
            imageView.setPreserveRatio(true);

            item.getChildren().add(imageView);
        } catch (Exception e) {
            Label errorLabel = new Label("Erreur image");
            item.getChildren().add(errorLabel);
        }
    }

    private void createVideoPreview(VBox item) {
        Label videoIcon = new Label("🎬");
        videoIcon.setStyle("-fx-font-size: 48px;");

        Label videoLabel = new Label("Vidéo");

        item.getChildren().addAll(videoIcon, videoLabel);
    }

    private void createAudioPreview(VBox item) {
        Label audioIcon = new Label("🔊");
        audioIcon.setStyle("-fx-font-size: 48px;");

        Label audioLabel = new Label("Audio");

        item.getChildren().addAll(audioIcon, audioLabel);
    }

    private void createDocumentPreview(VBox item, Message message) {
        Label docIcon = new Label("📄");
        docIcon.setStyle("-fx-font-size: 48px;");

        Label docName = new Label(message.getFileName() != null ?
                truncateText(message.getFileName(), 15) : "Document");

        item.getChildren().addAll(docIcon, docName);
    }

    /**
     * Opens the media in an appropriate viewer.
     *
     * @param message The message
     * @param mediaFile The media file
     */
    private void openMedia(Message message, File mediaFile) {
        if (!mediaFile.exists()) {
            return;
        }

        switch (message.getType()) {
            case IMAGE:
                openImageViewer(mediaFile);
                break;
            case VIDEO:
                openVideoPlayer(mediaFile);
                break;
            case AUDIO:
                openAudioPlayer(mediaFile);
                break;
            case DOCUMENT:
                openDocument(mediaFile);
                break;
        }
    }

    private void openImageViewer(File imageFile) {
        try {
            // Create a new stage with an image viewer
            Stage imageStage = new Stage();
            imageStage.setTitle("Visionneuse d'image");

            Image image = new Image(imageFile.toURI().toString());
            ImageView imageView = new ImageView(image);
            imageView.setPreserveRatio(true);

            // Limit size to fit screen
            imageView.setFitWidth(Math.min(image.getWidth(), 800));
            imageView.setFitHeight(Math.min(image.getHeight(), 600));

            javafx.scene.control.ScrollPane scrollPane = new javafx.scene.control.ScrollPane(imageView);
            scrollPane.setPannable(true);
            scrollPane.setFitToWidth(true);
            scrollPane.setFitToHeight(true);

            javafx.scene.Scene scene = new javafx.scene.Scene(scrollPane);
            imageStage.setScene(scene);
            imageStage.show();
        } catch (Exception e) {
            System.err.println("Error opening image: " + e.getMessage());
        }
    }

    private void openVideoPlayer(File videoFile) {
        try {
            // Create a new stage with a video player
            Stage videoStage = new Stage();
            videoStage.setTitle("Lecteur vidéo");

            javafx.scene.media.Media media = new javafx.scene.media.Media(videoFile.toURI().toString());
            javafx.scene.media.MediaPlayer mediaPlayer = new javafx.scene.media.MediaPlayer(media);
            javafx.scene.media.MediaView mediaView = new javafx.scene.media.MediaView(mediaPlayer);

            // Set up controls
            javafx.scene.control.Button playButton = new javafx.scene.control.Button("▶ Play");
            playButton.setOnAction(e -> {
                if (mediaPlayer.getStatus() == javafx.scene.media.MediaPlayer.Status.PLAYING) {
                    mediaPlayer.pause();
                    playButton.setText("▶ Play");
                } else {
                    mediaPlayer.play();
                    playButton.setText("⏸ Pause");
                }
            });

            javafx.scene.control.ProgressBar progressBar = new javafx.scene.control.ProgressBar(0);
            progressBar.setPrefWidth(300);

            mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
                double progress = newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds();
                javafx.application.Platform.runLater(() -> progressBar.setProgress(progress));
            });

            // Add seek functionality
            progressBar.setOnMouseClicked(e -> {
                double percent = e.getX() / progressBar.getWidth();
                mediaPlayer.seek(mediaPlayer.getTotalDuration().multiply(percent));
            });

            HBox controls = new HBox(10, playButton, progressBar);
            controls.setAlignment(Pos.CENTER);
            controls.setPadding(new javafx.geometry.Insets(10));

            VBox root = new VBox(10, mediaView, controls);
            root.setAlignment(Pos.CENTER);

            javafx.scene.Scene scene = new javafx.scene.Scene(root, 640, 480);
            videoStage.setScene(scene);

            videoStage.setOnCloseRequest(e -> mediaPlayer.stop());

            videoStage.show();
            mediaPlayer.play();
        } catch (Exception e) {
            System.err.println("Error opening video: " + e.getMessage());
        }
    }

    private void openAudioPlayer(File audioFile) {
        try {
            // Create a new stage with an audio player
            Stage audioStage = new Stage();
            audioStage.setTitle("Lecteur audio");

            javafx.scene.media.Media media = new javafx.scene.media.Media(audioFile.toURI().toString());
            javafx.scene.media.MediaPlayer mediaPlayer = new javafx.scene.media.MediaPlayer(media);

            // Create controls
            javafx.scene.control.Button playButton = new javafx.scene.control.Button("▶ Play");
            javafx.scene.control.Slider timeSlider = new javafx.scene.control.Slider();
            javafx.scene.control.Label timeLabel = new javafx.scene.control.Label("00:00 / 00:00");

            // Configure play button
            playButton.setOnAction(e -> {
                if (mediaPlayer.getStatus() == javafx.scene.media.MediaPlayer.Status.PLAYING) {
                    mediaPlayer.pause();
                    playButton.setText("▶ Play");
                } else {
                    mediaPlayer.play();
                    playButton.setText("⏸ Pause");
                }
            });

            // Configure time slider
            timeSlider.setMin(0);
            timeSlider.setMax(1);
            timeSlider.setValue(0);
            timeSlider.setPrefWidth(300);

            timeSlider.valueProperty().addListener((obs, oldVal, newVal) -> {
                if (timeSlider.isValueChanging()) {
                    mediaPlayer.seek(mediaPlayer.getTotalDuration().multiply(newVal.doubleValue()));
                }
            });

            // Update time label and slider
            mediaPlayer.currentTimeProperty().addListener((obs, oldVal, newVal) -> {
                if (!timeSlider.isValueChanging()) {
                    timeSlider.setValue(newVal.toSeconds() / mediaPlayer.getTotalDuration().toSeconds());

                    int currentMinutes = (int) newVal.toMinutes();
                    int currentSeconds = (int) newVal.toSeconds() % 60;

                    int totalMinutes = (int) mediaPlayer.getTotalDuration().toMinutes();
                    int totalSeconds = (int) mediaPlayer.getTotalDuration().toSeconds() % 60;

                    timeLabel.setText(String.format("%02d:%02d / %02d:%02d",
                            currentMinutes, currentSeconds, totalMinutes, totalSeconds));
                }
            });

            // Layout
            HBox controls = new HBox(10, playButton, timeSlider, timeLabel);
            controls.setAlignment(Pos.CENTER);
            controls.setPadding(new javafx.geometry.Insets(20));

            audioStage.setScene(new javafx.scene.Scene(controls, 500, 100));
            audioStage.setOnCloseRequest(e -> mediaPlayer.stop());
            audioStage.show();
        } catch (Exception e) {
            System.err.println("Error opening audio: " + e.getMessage());
        }
    }

    private void openDocument(File documentFile) {
        try {
            java.awt.Desktop.getDesktop().open(documentFile);
        } catch (Exception e) {
            System.err.println("Error opening document: " + e.getMessage());
        }
    }

    /**
     * Updates the statistics label.
     *
     * @param count The number of media items
     */
    private void updateStats(int count) {
        statsLabel.setText("Total: " + count + " média" + (count > 1 ? "s" : ""));
    }

    /**
     * Truncates a text to a maximum length.
     *
     * @param text The text to truncate
     * @param maxLength The maximum length
     * @return The truncated text
     */
    private String truncateText(String text, int maxLength) {
        if (text.length() <= maxLength) {
            return text;
        }
        return text.substring(0, maxLength - 3) + "...";
    }

    /**
     * Handles the close button action.
     *
     * @param event The action event
     */
    @FXML
    private void handleClose(ActionEvent event) {
        Stage stage = (Stage) mediaContainer.getScene().getWindow();
        stage.close();
    }
}


// File: src/main/java/org/example/client/gui/Launcher.java
package org.example.client.gui;

/**
 * Classe de lancement pour l'application JavaFX.
 * Cette classe sert de point d'entrée principal pour éviter les problèmes
 * de modules JavaFX lors de l'exécution à partir d'un JAR.
 */
public class Launcher {
    /**
     * Point d'entrée principal de l'application.
     * @param args Arguments de ligne de commande
     */
    public static void main(final String[] args) {
        // Lance l'application JavaFX
        ChatClientApplication.main(args);
    }
}



// File: src/main/java/org/example/client/gui/repository/JsonLocalMessageRepository.java
package org.example.client.gui.repository;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.example.shared.model.Message;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

/**
 * Classe de persistance locale pour l'historique des messages d'un utilisateur.
 * L'historique est stocké sous forme de fichier JSON dans le dossier
 * "src/main/resources/client_data".
 */
public class JsonLocalMessageRepository {
    // Utilisation du répertoire de projet pour stocker les données clients
    private static final String LOCAL_FOLDER = System.getProperty("user.dir")
            + File.separator + "src" + File.separator + "main" + File.separator + "resources" + File.separator
            + "client_data";
    private final ObjectMapper objectMapper;

    public JsonLocalMessageRepository() {
        this.objectMapper = new ObjectMapper();
        // Register the JavaTimeModule for date-time support
        this.objectMapper.registerModule(new JavaTimeModule());
        // Pretty-print output
        this.objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        ensureLocalFolderExists();
    }

    private void ensureLocalFolderExists() {
        final Path folderPath = Paths.get(LOCAL_FOLDER);
        if (!folderPath.toFile().exists()) {
            try {
                folderPath.toFile().mkdirs();
            } catch (final Exception e) {
                System.err.println("Erreur lors de la création du dossier client_data : " + e.getMessage());
            }
        }
    }

    /**
     * Renvoie le chemin complet du fichier de l'utilisateur.
     */
    private String getUserFilePath(final String userEmail) {
        // Remplacer les caractères spéciaux pour créer un nom de fichier valide
        return LOCAL_FOLDER + File.separator + userEmail.replace("@", "_at_") + "_messages.json";
    }

    /**
     * Charge la liste des messages locaux pour l'utilisateur.
     */
    public List<Message> loadLocalMessages(final String userEmail) throws IOException {
        final String filePath = getUserFilePath(userEmail);
        final File file = new File(filePath);
        if (!file.exists()) {
            return new ArrayList<>();
        }
        final CollectionType listType = objectMapper.getTypeFactory()
                .constructCollectionType(ArrayList.class, Message.class);
        return objectMapper.readValue(file, listType);
    }

    /**
     * Enregistre la liste des messages locaux pour l'utilisateur.
     */
    public void saveLocalMessages(final String userEmail, final List<Message> messages) throws IOException {
        final String filePath = getUserFilePath(userEmail);
        objectMapper.writeValue(new File(filePath), messages);
    }

    /**
     * Ajoute un nouveau message dans l'historique local pour l'utilisateur.
     * message envoyé et recue
     */
    public void addLocalMessage(final String userEmail, final Message message) throws IOException {
        final List<Message> messages = loadLocalMessages(userEmail);
        messages.add(message);
        saveLocalMessages(userEmail, messages);
    }

    /**
     * Retourne la conversation entre deux utilisateurs en filtrant les messages
     * directs (sans groupId).
     */
    public List<Message> loadContactMessages(final String userEmail, final long myId, final long contactId)
            throws IOException {
        final List<Message> allMessages = loadLocalMessages(userEmail);
        final List<Message> contactMessages = allMessages.stream()
                .filter(msg -> msg.getGroupId() == null
                        && ((msg.getSenderUserId() == myId && msg.getReceiverUserId() != null
                                && msg.getReceiverUserId() == contactId)
                                || (msg.getSenderUserId() == contactId && msg.getReceiverUserId() != null
                                        && msg.getReceiverUserId() == myId)))
                .distinct()
                .collect(Collectors.toList());
        return contactMessages;
    }

    /**
     * Retourne la conversation de groupe en filtrant les messages dont le groupId
     * correspond
     * au groupe passé.
     */
    public List<Message> loadGroupMessages(final String userEmail, final long groupId) throws IOException {
        final List<Message> allMessages = loadLocalMessages(userEmail);
        final List<Message> groupMessages = new ArrayList<>();
        for (final Message msg : allMessages) {
            if (msg.getGroupId() != null && msg.getGroupId() == groupId) {
                groupMessages.add(msg);
            }
        }
        return groupMessages;
    }

    /**
     * Supprime un message de l'historique local pour l'utilisateur.
     */
    public void removeConversation(final String userEmail, final long myId, final long contactId) throws IOException {
        final List<Message> messages = loadLocalMessages(userEmail);
        messages.removeIf(m -> (m.getSenderUserId() == myId && m.getReceiverUserId() != null
                && m.getReceiverUserId() == contactId)
                || (m.getSenderUserId() == contactId && m.getReceiverUserId() != null
                        && m.getReceiverUserId() == myId));
        saveLocalMessages(userEmail, messages);
    }

    /**
     * Récupère le dernier message échangé avec un contact spécifique.
     */
    public Optional<Message> getLastContactMessage(final String userEmail, final long myId, final long contactId) throws IOException {
        return loadContactMessages(userEmail, myId, contactId).stream()
                .max(Comparator.comparing(Message::getTimestamp));
    }

    /**
     * Récupère le dernier message d'un groupe spécifique.
     */
    public Optional<Message> getLastGroupMessage(final String userEmail, final long groupId) throws IOException {
        return loadGroupMessages(userEmail, groupId).stream()
                .max(Comparator.comparing(Message::getTimestamp));
    }
}


// File: src/main/java/org/example/client/gui/service/AudioRecorderService.java
package org.example.client.gui.service;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.UUID;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.TargetDataLine;

/**
 * Service for recording audio messages.
 */
public class AudioRecorderService {

    private TargetDataLine targetLine;
    private boolean isRecording = false;
    private Thread recordingThread;
    private ByteArrayOutputStream byteOutputStream;

    // Audio format settings
    private static final float SAMPLE_RATE = 44100;
    private static final int SAMPLE_SIZE_BITS = 16;
    private static final int CHANNELS = 1;
    private static final boolean SIGNED = true;
    private static final boolean BIG_ENDIAN = false;
    private static final AudioFormat.Encoding ENCODING = AudioFormat.Encoding.PCM_SIGNED;

    /**
     * Starts recording audio.
     *
     * @throws LineUnavailableException If the audio line is unavailable
     */
    public void startRecording() throws LineUnavailableException {
        if (isRecording) {
            return;
        }

        // Create audio format
        AudioFormat format = new AudioFormat(
                ENCODING,
                SAMPLE_RATE,
                SAMPLE_SIZE_BITS,
                CHANNELS,
                (SAMPLE_SIZE_BITS / 8) * CHANNELS,
                SAMPLE_RATE,
                BIG_ENDIAN);

        // Get the target data line
        DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);
        if (!AudioSystem.isLineSupported(info)) {
            throw new LineUnavailableException("The system does not support the specified audio format");
        }

        targetLine = (TargetDataLine) AudioSystem.getLine(info);
        targetLine.open(format);
        targetLine.start();

        byteOutputStream = new ByteArrayOutputStream();
        isRecording = true;

        // Create a thread to read audio data
        recordingThread = new Thread(() -> {
            byte[] buffer = new byte[4096];
            int bytesRead;

            while (isRecording) {
                bytesRead = targetLine.read(buffer, 0, buffer.length);
                if (bytesRead > 0) {
                    byteOutputStream.write(buffer, 0, bytesRead);
                }
            }
        });

        recordingThread.start();
    }

    /**
     * Stops recording and returns the recorded audio file.
     *
     * @return The recorded audio file
     * @throws IOException If an I/O error occurs
     */
    public File stopRecording() throws IOException {
        if (!isRecording) {
            return null;
        }

        isRecording = false;

        try {
            // Wait for the recording thread to finish
            recordingThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        targetLine.stop();
        targetLine.close();

        // Create a WAV file from the recorded bytes
        byte[] audioBytes = byteOutputStream.toByteArray();
        AudioFormat format = new AudioFormat(
                ENCODING,
                SAMPLE_RATE,
                SAMPLE_SIZE_BITS,
                CHANNELS,
                (SAMPLE_SIZE_BITS / 8) * CHANNELS,
                SAMPLE_RATE,
                BIG_ENDIAN);

        ByteArrayInputStream byteInputStream = new ByteArrayInputStream(audioBytes);
        AudioInputStream audioInputStream = new AudioInputStream(byteInputStream, format, audioBytes.length / format.getFrameSize());

        // Create a temporary file
        File tempFile = File.createTempFile("audio_" + UUID.randomUUID().toString(), ".wav");
        try (FileOutputStream fos = new FileOutputStream(tempFile)) {
            AudioSystem.write(audioInputStream, AudioFileFormat.Type.WAVE, tempFile);
        } catch (IOException e) {
            throw new IOException("Failed to save audio file: " + e.getMessage(), e);
        }

        return tempFile;
    }

    /**
     * Checks if the system supports audio recording.
     *
     * @return true if audio recording is supported, false otherwise
     */
    public boolean isAudioRecordingSupported() {
        try {
            AudioFormat format = new AudioFormat(
                    ENCODING,
                    SAMPLE_RATE,
                    SAMPLE_SIZE_BITS,
                    CHANNELS,
                    (SAMPLE_SIZE_BITS / 8) * CHANNELS,
                    SAMPLE_RATE,
                    BIG_ENDIAN);

            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);
            return AudioSystem.isLineSupported(info);
        } catch (Exception e) {
            return false;
        }
    }
}


// File: src/main/java/org/example/client/gui/service/ChatService.java
package org.example.client.gui.service;

import java.io.*;
import java.net.ConnectException;
import java.net.Socket;
import java.util.List;
import java.util.function.Consumer;

import org.example.shared.dao.GroupDAO;
import org.example.shared.dao.MessageDAO;
import org.example.shared.dao.UserDAO;
import org.example.shared.dto.Credentials;
import org.example.shared.model.Message;
import org.example.shared.model.User;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.example.shared.model.enums.MessageType;

public class ChatService {
    private static final String SERVER_ADDRESS = "localhost";
    private static final int SERVER_PORT = 5000;

    private Socket socket;
    private PrintWriter out;
    private BufferedReader in;
    private String userEmail;
    private final ObjectMapper objectMapper;
    private Consumer<Message> messageConsumer;
    private Thread listenerThread;
    private boolean isRunning = false;

    // Instances DAO pour la persistance locale
    private final MessageDAO messageDAO;
    private final GroupDAO groupDAO;
    private final UserDAO userDAO; // Accès direct au DAO sans UserService

    // New file service for handling multimedia
    private final FileService fileService;

    public ChatService() {
        this.objectMapper = new ObjectMapper().registerModule(new JavaTimeModule());
        this.messageDAO = new MessageDAO();
        this.groupDAO = new GroupDAO();
        this.userDAO = new UserDAO();
        this.fileService = new FileService();
    }

    // resp : initie la connexion avec le serveur / l'authentification
    public boolean connect(final Credentials credentials) throws IOException {
        try {
            // resp 1 : etablissement de la connexion avec le serveur (creation de la socket coté serveur)
            System.out.println("Connexion au serveur " + SERVER_ADDRESS + ":" + SERVER_PORT);
            socket = new Socket(SERVER_ADDRESS, SERVER_PORT);
            out = new PrintWriter(socket.getOutputStream(), true);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            // Envoyer les identifiants
            final String jsonCredentials = objectMapper.writeValueAsString(credentials);
            out.println(jsonCredentials);

            // Attendre la réponse du serveur
            final String response = in.readLine();
            final boolean success = "AUTH_SUCCESS".equals(response);

            if (success) {
                this.userEmail = credentials.getEmail();
                startMessageListener();
                System.out.println("Authentification réussie pour " + userEmail);
            } else {
                System.out.println("Échec de l'authentification");
                disconnect();
            }

            return success;
        } catch (final ConnectException e) {
            throw new IOException(
                    "Impossible de se connecter au serveur. Assurez-vous que le serveur est démarré et accessible sur "
                            + SERVER_ADDRESS + ":" + SERVER_PORT,
                    e);
        } catch (final Exception e) {
            throw new IOException("Erreur lors de la connexion au serveur: " + e.getMessage(), e);
        }
    }

    public void disconnect() throws IOException {
        // Envoi d'un message de déconnexion (exemple simplifié)
        final Message logoutMsg = new Message();
        logoutMsg.setSenderUserId(getCurrentUserId());
        out.println(objectMapper.writeValueAsString(logoutMsg));

        closeResources();

        userEmail = null;
        messageConsumer = null;
        isRunning = false;
        System.out.println("Déconnexion complète");
    }

    private void closeResources() {
        try {
            if (out != null) out.close();
        } catch (final Exception e) { /* Ignorer */ }
        try {
            if (in != null) in.close();
        } catch (final Exception e) { /* Ignorer */ }
        try {
            if (socket != null && !socket.isClosed()) socket.close();
        } catch (final IOException e) { /* Ignorer */ }
        out = null;
        in = null;
        socket = null;
    }

    public long getCurrentUserId() {
        try {
            // Utiliser directement UserDAO
            final User currentUser = userDAO.findUserByEmail(userEmail);
            return currentUser != null ? currentUser.getId() : -1;
        } catch (final Exception e) {
            return -1;
        }
    }

    public Message createDirectMessage(final String senderEmail, final String receiverEmail, final String content)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);
        final User receiver = userDAO.findUserByEmail(receiverEmail);
        return Message.newDirectMessage(sender.getId(), receiver.getId(), content);
    }

    public Message createGroupMessage(final String senderEmail, final long groupId, final String content) throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);
        return Message.newGroupMessage(sender.getId(), groupId, content);
    }

    // New methods for creating multimedia messages
    public Message createDirectMediaMessage(final String senderEmail, final String receiverEmail, final File mediaFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);
        final User receiver = userDAO.findUserByEmail(receiverEmail);

        // Detect file type and save the file
        final MessageType type = fileService.detectMessageType(mediaFile.getName());
        final String filePath = fileService.saveFile(mediaFile, type, mediaFile.getName());
        System.out.println("file");
        final String mimeType = fileService.getMimeType(mediaFile);

        return Message.newDirectMediaMessage(
                sender.getId(),
                receiver.getId(),
                filePath,
                type,
                mediaFile.getName(),
                mediaFile.length(),
                mimeType);
    }

    public Message createGroupMediaMessage(final String senderEmail, final long groupId, final File mediaFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);

        // Detect file type and save the file
        final MessageType type = fileService.detectMessageType(mediaFile.getName());
        final String filePath = fileService.saveFile(mediaFile, type, mediaFile.getName());
        final String mimeType = fileService.getMimeType(mediaFile);

        return Message.newGroupMediaMessage(
                sender.getId(),
                groupId,
                filePath,
                type,
                mediaFile.getName(),
                mediaFile.length(),
                mimeType);
    }

    public Message createDirectAudioMessage(final String senderEmail, final String receiverEmail, final File audioFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);
        final User receiver = userDAO.findUserByEmail(receiverEmail);

        // Save the audio file
        final String filePath = fileService.saveFile(audioFile, MessageType.AUDIO, audioFile.getName());
        final String mimeType = fileService.getMimeType(audioFile);

        return Message.newDirectMediaMessage(
                sender.getId(),
                receiver.getId(),
                filePath,
                MessageType.AUDIO,
                audioFile.getName(),
                audioFile.length(),
                mimeType);
    }

    public Message createGroupAudioMessage(final String senderEmail, final long groupId, final File audioFile)
            throws IOException {
        final User sender = userDAO.findUserByEmail(senderEmail);

        // Save the audio file
        final String filePath = fileService.saveFile(audioFile, MessageType.AUDIO, audioFile.getName());
        final String mimeType = fileService.getMimeType(audioFile);

        return Message.newGroupMediaMessage(
                sender.getId(),
                groupId,
                filePath,
                MessageType.AUDIO,
                audioFile.getName(),
                audioFile.length(),
                mimeType);
    }
    // resp : envoi des messages au serveur via socket
    public boolean sendMessage(final Message message) throws IOException {
        if (socket == null || socket.isClosed() || out == null) {
            throw new IOException("Non connecté au serveur");
        }
        final String jsonMessage = objectMapper.writeValueAsString(message);
        out.println(jsonMessage);
        return true;
    }

    /**
     * Gets the file associated with a media message.
     *
     * @param message The message
     * @return The file
     */
    public File getMediaFile(final Message message) {
        if (!message.isMediaMessage()) {
            throw new IllegalArgumentException("Not a media message");
        }
        return fileService.getFile(message.getContent());
    }

    // Récupère la conversation entre deux utilisateurs
    public List<Message> getConversation(final long user1Id, final long user2Id) throws IOException {
        return messageDAO.getConversation(user1Id, user2Id);
    }

    // resp : configuration du message consumer (handleIncomingMessage)
    public void setMessageConsumer(final Consumer<Message> consumer) {
        this.messageConsumer = consumer;
    }
    // resp : initie une boucle qui reagit a tous message recue
    private void startMessageListener() {
        isRunning = true;
        listenerThread = new Thread(() -> {
            try {
                String jsonMessage;
                while (isRunning && (jsonMessage = in.readLine()) != null) {
                    try {
                        final Message message = objectMapper.readValue(jsonMessage, Message.class);
                        if (messageConsumer != null) {
                            messageConsumer.accept(message);
                        }
                    } catch (final Exception e) {
                        System.err.println("Erreur lors du traitement du message: " + e.getMessage());
                    }
                }
            } catch (final IOException e) {
                if (isRunning) {
                    System.err.println("Connexion perdue: " + e.getMessage());
                }
            } finally {
                isRunning = false;
            }
        });
        listenerThread.setDaemon(true);
        listenerThread.start();
    }
}



// File: src/main/java/org/example/client/gui/service/ContactService.java
package org.example.client.gui.service;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.dao.ContactDAO;
import org.example.shared.dao.UserDAO;
import org.example.shared.model.Contact;
import org.example.shared.model.User;

/**
 * Service dédié à la gestion des contacts.
 */
public class ContactService {

    private final UserDAO userDAO;
    private final ContactDAO contactDAO;
    private final UserService userService = new UserService();

    public ContactService() {
        this.userDAO = new UserDAO();
        this.contactDAO = new ContactDAO();
    }

    /**
     * Récupère la liste des emails des contacts
     */
    public List<String> getContacts(final String userEmail) throws IOException {
        final User user = userDAO.findUserByEmail(userEmail);
        if (user == null) {
            throw new IOException("Utilisateur non trouvé: " + userEmail);
        }
        return contactDAO.getContactsByUserId(user.getId());
    }

    /**
     * Récupère la liste des objets User complets pour les contacts
     */
    public List<User> getContactUsers(final String userEmail) throws IOException {
        final List<String> contactEmails = getContacts(userEmail);
        final List<User> users = new ArrayList<>();
        
        for (final String email : contactEmails) {
            final User user = userService.getUserByEmail(email);
            if (user != null) {
                users.add(user);
            }
        }
        
        return users;
    }

    /**
     * Ajoute un contact et retourne l'objet User correspondant
     */
    public User addContactUser(final String userEmail, final String contactEmail) throws IOException {
        final boolean added = addContact(userEmail, contactEmail);
        if (added) {
            return userService.getUserByEmail(contactEmail);
        }
        return null;
    }

    /**
     * Ajoute un contact par email
     */
    public boolean addContact(final String userEmail, final String contactEmail) throws IOException {
        final User user = userDAO.findUserByEmail(userEmail);
        final User contactUser = userDAO.findUserByEmail(contactEmail);

        if (user == null) {
            throw new IOException("Utilisateur non trouvé: " + userEmail);
        }
        if (contactUser == null) {
            throw new IOException("Contact non trouvé: " + contactEmail);
        }
        if (user.getId() == contactUser.getId()) {
            throw new IllegalArgumentException("Vous ne pouvez pas vous ajouter vous-même comme contact.");
        }

        final Contact newContact = new Contact(user.getId(), contactUser.getId());
        contactDAO.createContact(newContact);
        return true;
    }

    /**
     * Supprime un contact
     */
    public boolean removeContact(final String userEmail, final String contactEmail) throws IOException {
        final User user = userDAO.findUserByEmail(userEmail);
        final User contactUser = userDAO.findUserByEmail(contactEmail);

        if (user == null) {
            throw new IOException("Utilisateur non trouvé: " + userEmail);
        }
        if (contactUser == null) {
            return false;
        }

        return contactDAO.deleteContact(user.getId(), contactUser.getId());
    }
}



// File: src/main/java/org/example/client/gui/service/FileService.java
package org.example.client.gui.service;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

import org.example.shared.model.Message;
import org.example.shared.model.enums.MessageType;

/**
 * Service for handling file operations for multimedia messages.
 */
public class FileService {

    // Base directory for storing media files
    private static final String MEDIA_DIR = System.getProperty("user.dir") + File.separator +
            "media_files";

    // Subdirectories for different media types
    private static final String IMAGES_DIR = MEDIA_DIR + File.separator + "images";
    private static final String VIDEOS_DIR = MEDIA_DIR + File.separator + "videos";
    private static final String DOCUMENTS_DIR = MEDIA_DIR + File.separator + "documents";
    private static final String AUDIO_DIR = MEDIA_DIR + File.separator + "audio";

    // Maximum file size (20MB)
    private static final long MAX_FILE_SIZE = 20 * 1024 * 1024;

    /**
     * Constructor - creates necessary directories if they don't exist.
     */
    public FileService() {
        createDirectories();
    }

    /**
     * Creates all necessary directories for storing media files.
     */

    private void createDirectories() {
        try {
            File mediaDir = new File(MEDIA_DIR);
            if (!mediaDir.exists()) {
                boolean created = mediaDir.mkdirs();
                System.out.println("Created main media directory: " + created + " at " + mediaDir.getAbsolutePath());
            } else {
                System.out.println("Main media directory already exists at: " + mediaDir.getAbsolutePath());
            }

            // Create each subdirectory individually and log results
            File imagesDir = new File(IMAGES_DIR);
            if (!imagesDir.exists()) {
                boolean created = imagesDir.mkdirs();
                System.out.println("Created images directory: " + created + " at " + imagesDir.getAbsolutePath());
            } else {
                System.out.println("Images directory already exists at: " + imagesDir.getAbsolutePath());
            }

            File videosDir = new File(VIDEOS_DIR);
            if (!videosDir.exists()) {
                boolean created = videosDir.mkdirs();
                System.out.println("Created videos directory: " + created + " at " + videosDir.getAbsolutePath());
            } else {
                System.out.println("Videos directory already exists at: " + videosDir.getAbsolutePath());
            }

            File documentsDir = new File(DOCUMENTS_DIR);
            if (!documentsDir.exists()) {
                boolean created = documentsDir.mkdirs();
                System.out.println("Created documents directory: " + created + " at " + documentsDir.getAbsolutePath());
            } else {
                System.out.println("Documents directory already exists at: " + documentsDir.getAbsolutePath());
            }

            File audioDir = new File(AUDIO_DIR);
            if (!audioDir.exists()) {
                boolean created = audioDir.mkdirs();
                System.out.println("Created audio directory: " + created + " at " + audioDir.getAbsolutePath());
            } else {
                System.out.println("Audio directory already exists at: " + audioDir.getAbsolutePath());
            }

            // Log summary
            System.out.println("Directory structure setup complete. Media files will be stored in: " + MEDIA_DIR);
        } catch (Exception e) {
            System.err.println("Error creating directories: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Saves a file to the appropriate directory and returns the path where it was saved.
     *
     * @param file The file to save
     * @param type The type of media
     * @param originalFilename The original filename
     * @return The path where the file was saved (relative to the media directory)
     * @throws IOException If an I/O error occurs
     * @throws IllegalArgumentException If the file is too large or of an invalid type
     */
    public String saveFile(File file, MessageType type, String originalFilename) throws IOException {
       System.out.println("//// Saving file of type " + type);
        // Check file size
        if (file.length() > MAX_FILE_SIZE) {
            throw new IllegalArgumentException("File is too large. Maximum size is " +
                    (MAX_FILE_SIZE / (1024 * 1024)) + "MB");
        }

        // Get the appropriate directory
        String directory;
        switch (type) {
            case IMAGE:
                directory = IMAGES_DIR;
                break;
            case VIDEO:
                directory = VIDEOS_DIR;
                break;
            case DOCUMENT:
                directory = DOCUMENTS_DIR;
                break;
            case AUDIO:
                directory = AUDIO_DIR;
                break;
            default:
                throw new IllegalArgumentException("Invalid file type: " + type);
        }

        // Generate a unique filename to avoid collisions
        String fileExtension = getFileExtension(originalFilename);
        String uniqueFilename = UUID.randomUUID().toString() + fileExtension;
        String fullPath = directory + File.separator + uniqueFilename;

        System.out.println("Full path: " + fullPath);

        // Copy the file
        try (InputStream in = new FileInputStream(file);
             OutputStream out = new FileOutputStream(fullPath)) {
            byte[] buffer = new byte[4096];
            int length;
            while ((length = in.read(buffer)) > 0) {
                out.write(buffer, 0, length);
            }
        }

        // Return the relative path to be stored in the message
        return type.name().toLowerCase() + "/" + uniqueFilename;
    }

    /**
     * Gets the full path to a media file from its relative path.
     *
     * @param relativePath The relative path stored in the message
     * @return The full path to the file
     */
    public File getFile(String relativePath) {
        return new File(MEDIA_DIR + File.separator + relativePath);
    }

    /**
     * Detects the message type based on the file extension.
     *
     * @param filename The name of the file
     * @return The detected message type
     */
    public MessageType detectMessageType(String filename) {
        String extension = getFileExtension(filename).toLowerCase();

        // Image formats
        if (extension.matches("\\.(jpg|jpeg|png|gif|bmp|webp)$")) {
            return MessageType.IMAGE;
        }

        // Video formats
        if (extension.matches("\\.(mp4|avi|mov|wmv|flv|mkv|webm)$")) {
            return MessageType.VIDEO;
        }

        // Audio formats
        if (extension.matches("\\.(mp3|wav|ogg|aac|wma|flac)$")) {
            return MessageType.AUDIO;
        }

        // Default to document for all other types
        return MessageType.DOCUMENT;
    }

    /**
     * Gets the MIME type for a file.
     *
     * @param file The file
     * @return The MIME type
     */
    public String getMimeType(File file) throws IOException {
        return Files.probeContentType(file.toPath());
    }

    /**
     * Gets the file extension from a filename.
     *
     * @param filename The filename
     * @return The file extension (including the dot)
     */
    private String getFileExtension(String filename) {
        int lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex >= 0) {
            return filename.substring(lastDotIndex);
        }
        return "";
    }

    /**
     * Deletes a file if it exists.
     *
     * @param relativePath The relative path to the file
     * @return true if the file was deleted, false otherwise
     */
    public boolean deleteFile(String relativePath) {
        File file = getFile(relativePath);
        if (file.exists()) {
            return file.delete();
        }
        return false;
    }
}


// File: src/main/java/org/example/client/gui/service/GroupService.java
package org.example.client.gui.service;

import java.io.IOException;
import java.util.List;

import org.example.shared.dao.GroupDAO;
import org.example.shared.dao.GroupMembershipDAO;
import org.example.shared.model.Group;
import org.example.shared.model.GroupMembership;

public class GroupService {

    private final GroupDAO groupDAO;
    private final GroupMembershipDAO groupMembershipDAO;

    public GroupService() {
        this.groupDAO = new GroupDAO();
        this.groupMembershipDAO = new GroupMembershipDAO();
    }

    public Group createGroup(final String groupName, final long ownerUserId) {
        final Group group = new Group(groupName, ownerUserId); // constructeur qui initialise aussi createdAt
        groupDAO.createGroup(group);
        if (group.getId() > 0) {
            final GroupMembership membership = new GroupMembership(ownerUserId, group.getId());
            groupMembershipDAO.createGroupMembership(membership);
        }
        return group;
    }

    public boolean addMemberToGroup(final long groupId, final long userId) {
        if (groupMembershipDAO.findGroupMembership(userId, groupId) == null) {
            final GroupMembership membership = new GroupMembership(userId, groupId);
            groupMembershipDAO.createGroupMembership(membership);
            return true;
        }
        return false;
    }
    
    public List<Group> getGroupsForUser(final long userId) throws IOException {
        return groupDAO.getGroupsForUser(userId);
    }
}



// File: src/main/java/org/example/client/gui/service/UserService.java
package org.example.client.gui.service;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.example.shared.dao.UserDAO;
import org.example.shared.model.User;

/**
 * Service pour gérer les utilisateurs avec cache
 */
public class UserService {
    private final UserDAO userDAO;
    private final Map<String, User> userEmailCache = new HashMap<>();
    private final Map<Long, User> userIdCache = new HashMap<>();

    public UserService() {
        this.userDAO = new UserDAO();
    }
    
    /**
     * Récupère un utilisateur par email 
     */
    public User getUserByEmail(final String email) throws IOException {
        if (email == null || email.trim().isEmpty()) {
            throw new IllegalArgumentException("L'email ne peut pas être vide");
        }
        
        // Vérifier le cache d'abord
        if (userEmailCache.containsKey(email)) {
            return userEmailCache.get(email);
        }
        
        // Sinon, interroger la base de données
        final User user = userDAO.findUserByEmail(email);
        if (user == null) {
            throw new IOException("Utilisateur non trouvé avec email: " + email);
        }
        
        // Mettre en cache
        userEmailCache.put(email, user);
        userIdCache.put(user.getId(), user);
        
        return user;
    }
    
    /**
     * Récupère un utilisateur par ID
     */
    public User getUserById(final long userId) throws IOException {
        if (userId <= 0) {
            throw new IllegalArgumentException("L'ID utilisateur doit être positif");
        }
        
        // Vérifier le cache d'abord
        if (userIdCache.containsKey(userId)) {
            return userIdCache.get(userId);
        }
        
        // Sinon, interroger la base de données
        final User user = userDAO.findUserById(userId);
        if (user == null) {
            throw new IOException("Utilisateur non trouvé avec ID: " + userId);
        }
        
        // Mettre en cache
        userEmailCache.put(user.getEmail(), user);
        userIdCache.put(userId, user);
        
        return user;
    }
    
    /**
     * Efface le cache pour forcer le rechargement des données
     */
    public void clearCache() {
        userEmailCache.clear();
        userIdCache.clear();
    }
    
    /**
     * Met à jour un utilisateur dans la base de données et le cache
     */
    public void updateUser(final User user) throws IOException {
        if (user == null) {
            throw new IllegalArgumentException("L'utilisateur ne peut pas être null");
        }
        
        userDAO.updateUser(user);
        
        // Mettre à jour le cache
        userEmailCache.put(user.getEmail(), user);
        userIdCache.put(user.getId(), user);
    }
}



// File: src/main/java/org/example/server/broker/MessageBroker.java
package org.example.server.broker;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;

import org.example.server.ClientHandler;
import org.example.shared.dao.GroupDAO;
import org.example.shared.dao.MessageDAO;
import org.example.shared.model.Message;
import org.example.shared.model.enums.MessageStatus;

public class MessageBroker {
    private static MessageBroker instance;
    private final Map<Long, MessageQueue> userQueues;
    private final MessageDAO messageDAO;
    final GroupDAO groupDAO;

    public static synchronized MessageBroker getInstance() {
        if (instance == null) {
            instance = new MessageBroker();
        }
        return instance;
    }

    private MessageBroker() {
        this.userQueues = new ConcurrentHashMap<>();
        this.messageDAO = new MessageDAO();
        this.groupDAO = new GroupDAO();
    }

    public void registerListener(final long userId, final ClientHandler listener) {
        final MessageQueue queue = getOrCreateQueue(userId);
        queue.setListener(listener);
        queue.loadPersistedMessages();
        queue.deliverPendingMessages();
    }

    public void unregisterListener(final long userId) {
        final MessageQueue queue = userQueues.remove(userId);
        if (queue != null) {
            queue.setListener(null);
            queue.clearQueue();
        }
    }

    public void sendMessage(final Message message) {
        
        if (message.isGroupMessage()) {
            final List<Long> groupMemberIds = groupDAO.getMembersForGroup(message.getGroupId());
            for (final Long memberId : groupMemberIds) {
                // Ignorer l'expéditeur
                if (memberId != message.getSenderUserId()) {
                    final MessageQueue queue = getOrCreateQueue(memberId);
                    if (queue != null ) {
                        message.setStatus(MessageStatus.DELIVERED);
                        queue.tryDeliver(message);
                    } else {
                        persistMessage(message);
                    }
                }
            }
        } else {
            final MessageQueue queue = userQueues.get(message.getReceiverUserId());
            if (queue != null) {
                message.setStatus(MessageStatus.DELIVERED);
                queue.tryDeliver(message);
            } else {
                persistMessage(message);
            }
        }
    }

    private void persistMessage(final Message message) {
        message.setStatus(MessageStatus.QUEUED);
        try {
            messageDAO.createMessage(message);
        } catch (final Exception e) {
            System.err.println("Failed to queue message: " + e.getMessage());
        }
    }

    private MessageQueue getOrCreateQueue(final long userId) {
        return userQueues.computeIfAbsent(userId, MessageQueue::new);
    }

    private class MessageQueue {
        private final long userId;
        private final BlockingQueue<Message> messages;
        private ClientHandler listener;

        MessageQueue(final long userId) {
            this.userId = userId;
            this.messages = new LinkedBlockingQueue<>();
        }

        synchronized void setListener(final ClientHandler listener) {
            this.listener = listener;
        }

        void addMessageToQueue(final Message message) {
            messages.offer(message);
        }

        synchronized void clearQueue() {
            messages.clear();
        }

        synchronized void loadPersistedMessages() {
            try {
                final List<Message> pendingMessages = messageDAO.getPendingMessagesForUser(userId);
                pendingMessages.forEach(this::addMessageToQueue);
            } catch (final Exception e) {
                System.err.println("Error reloading persisted messages for user " + userId + ": " + e.getMessage());
            }
        }

        boolean tryDeliver(final Message message) {
            if (listener != null) {
                try {
                    listener.onMessageReceived(message);
                    return true;
                } catch (final IOException e) {
                    System.err.println("Delivery failed for message " + message.getId());
                }
            }
            return false;
        }

        void deliverPendingMessages() {
            while (!messages.isEmpty()) {
                final Message message = messages.peek();
                if (tryDeliver(message)) {
                    try {
                        messages.poll();
                        messageDAO.deleteMessage(message.getId());
                    } catch (final Exception e) {
                        System.err.println("Delivery failed, keeping message in queue");
                        break;
                    }
                } else {
                    break;
                }
            }
        }
    }
}


// File: src/main/java/org/example/server/ChatServer.java
package org.example.server;

import java.net.ServerSocket;
import java.net.Socket;

public class ChatServer {
    private static final int PORT = 5000;
    public static void main(final String[] args) throws Exception {

        final ServerSocket server = new ServerSocket(PORT);
        System.out.println("Server started on port " + PORT);
        System.out.println("Waiting for clients...");

        while (true) {
            final Socket client = server.accept();
            final ClientHandler clientHandler = new ClientHandler(client);
            new Thread(clientHandler).start();
        }
    }
}


// File: src/main/java/org/example/server/ClientHandler.java
package org.example.server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

import org.example.server.broker.MessageBroker;
import org.example.shared.dao.UserDAO;
import org.example.shared.dto.Credentials;
import org.example.shared.model.Message;
import org.example.shared.model.User;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

public class ClientHandler implements Runnable {

    private final Socket clientSocket;
    private final MessageBroker broker;
    private final UserDAO userDAO;
    private final ObjectMapper mapper;
    private final ServerFileService fileService;

    private String clientEmail;
    private long clientId;
    private PrintWriter output;
    private BufferedReader input;
    private volatile boolean isConnected;

    public ClientHandler(final Socket socket) {
        this.clientSocket = socket;
        this.broker = MessageBroker.getInstance();
        this.userDAO = new UserDAO();
        this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
        this.fileService = new ServerFileService();
    }

    @Override
    public void run() {
        try (
                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {
            this.input = in;
            this.output = out;

            if (!authenticateUser()) {
                sendResponse("AUTH_FAILED");
                return;
            }
            sendResponse("AUTH_SUCCESS");
            
            initializeSubscription();
            processMessages();
        } catch (final IOException e) {
            System.out.println("Client connection error: " + e.getMessage());
        } finally {
            cleanup();
        }
    }

    private boolean authenticateUser() throws IOException {
        final Credentials credentials = mapper.readValue(input.readLine(), Credentials.class);
        final User user = userDAO.findUserByEmail(credentials.getEmail());
        if (user != null && user.getPasswordHash().equals(credentials.getPassword())) {
            this.clientEmail = user.getEmail();
            this.clientId = user.getId();
            return true;
        }
        return false;
    }

    private void initializeSubscription() throws IOException {
        broker.registerListener(clientId, this);
        isConnected = true;
    }

    private void processMessages() throws IOException {
        String messageJson;
        while (isConnected && (messageJson = input.readLine()) != null) {
            try {
                final Message message = mapper.readValue(messageJson, Message.class);
                if ("LOGOUT".equalsIgnoreCase(message.getContent())) {
                    terminateSession();
                } else {
                    // Process the message
                    if (message.isMediaMessage()) {
                        processMediaMessage(message);
                    }
                    broker.sendMessage(message);
                }
            } catch (final IOException e) {
                System.out.println("Invalid message format: " + messageJson);
            }
        }
    }

    /**
     * Processes a media message by ensuring the file is available on the server
     * for all clients to access.
     *
     * @param message The media message
     */
    private void processMediaMessage(Message message) {
        try {
            // For most cases, the client will have already saved the file locally
            // and the server will use the same path. However, we need to make sure
            // the directory structure exists on the server.

            // Ensure the corresponding media directory exists based on type
            fileService.ensureMediaDirectoriesExist();

            System.out.println("Processing media message: " + message.getType() +
                    ", File: " + (message.getFileName() != null ? message.getFileName() : "Unknown"));

        } catch (Exception e) {
            System.err.println("Error processing media message: " + e.getMessage());
        }
    }

    public void onMessageReceived(final Message message) throws IOException {
        output.println(mapper.writeValueAsString(message));
    }

    private void sendResponse(final String response) {
        output.println(response);
    }

    private void terminateSession() {
        isConnected = false;
    }

    private void cleanup() {
        if (clientEmail != null) {
            broker.unregisterListener(clientId);
        }
    }
}


// File: src/main/java/org/example/server/ServerFileService.java
package org.example.server;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

import org.example.shared.model.enums.MessageType;

/**
 * Service for handling file operations on the server side.
 */
public class ServerFileService {

    // Base directory for storing media files
    private static final String MEDIA_DIR = System.getProperty("user.dir") + File.separator +
            "media_files";

    // Subdirectories for different media types
    private static final String IMAGES_DIR = MEDIA_DIR + File.separator + "images";
    private static final String VIDEOS_DIR = MEDIA_DIR + File.separator + "videos";
    private static final String DOCUMENTS_DIR = MEDIA_DIR + File.separator + "documents";
    private static final String AUDIO_DIR = MEDIA_DIR + File.separator + "audio";

    /**
     * Creates all necessary directories for storing media files.
     */
    public void ensureMediaDirectoriesExist() throws IOException {
        Files.createDirectories(Paths.get(IMAGES_DIR));
        Files.createDirectories(Paths.get(VIDEOS_DIR));
        Files.createDirectories(Paths.get(DOCUMENTS_DIR));
        Files.createDirectories(Paths.get(AUDIO_DIR));
    }

    /**
     * Gets the full path to a media file from its relative path.
     *
     * @param relativePath The relative path stored in the message
     * @return The full path to the file
     */
    public File getFile(String relativePath) {
        return new File(MEDIA_DIR + File.separator + relativePath);
    }

    /**
     * Saves a file to the appropriate directory and returns the path where it was saved.
     *
     * @param inputStream The input stream of the file
     * @param type The type of media
     * @param originalFilename The original filename
     * @return The path where the file was saved (relative to the media directory)
     * @throws IOException If an I/O error occurs
     */
    public String saveFile(InputStream inputStream, MessageType type, String originalFilename) throws IOException {
        // Get the appropriate directory
        String directory;
        switch (type) {
            case IMAGE:
                directory = IMAGES_DIR;
                break;
            case VIDEO:
                directory = VIDEOS_DIR;
                break;
            case DOCUMENT:
                directory = DOCUMENTS_DIR;
                break;
            case AUDIO:
                directory = AUDIO_DIR;
                break;
            default:
                throw new IllegalArgumentException("Invalid file type: " + type);
        }

        // Generate a unique filename to avoid collisions
        String fileExtension = getFileExtension(originalFilename);
        String uniqueFilename = UUID.randomUUID().toString() + fileExtension;
        String fullPath = directory + File.separator + uniqueFilename;

        // Save the file
        try (FileOutputStream fos = new FileOutputStream(fullPath)) {
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                fos.write(buffer, 0, bytesRead);
            }
        }

        // Return the relative path to be stored in the message
        return type.name().toLowerCase() + "/" + uniqueFilename;
    }

    /**
     * Gets the file extension from a filename.
     *
     * @param filename The filename
     * @return The file extension (including the dot)
     */
    private String getFileExtension(String filename) {
        int lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex >= 0) {
            return filename.substring(lastDotIndex);
        }
        return "";
    }

    /**
     * Deletes a file if it exists.
     *
     * @param relativePath The relative path to the file
     * @return true if the file was deleted, false otherwise
     */
    public boolean deleteFile(String relativePath) {
        File file = getFile(relativePath);
        if (file.exists()) {
            return file.delete();
        }
        return false;
    }
}


// File: src/main/java/org/example/shared/dao/ContactDAO.java
package org.example.shared.dao;

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLIntegrityConstraintViolationException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.model.Contact;

public class ContactDAO {

    public void createContact(final Contact contact) {
        final String sql = "INSERT INTO contacts (user_id, contact_user_id, added_at) VALUES (?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, contact.getUserId());
            stmt.setLong(2, contact.getContactUserId());
            stmt.setTimestamp(3, Timestamp.valueOf(contact.getAddedAt()));
            stmt.executeUpdate();
        } catch (final SQLIntegrityConstraintViolationException ex) {
            System.err.println("Contact déjà existant: " + ex.getMessage());
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public Contact findContactById(final long id) {
        final String sql = "SELECT * FROM contacts WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    final Contact contact = new Contact();
                    // Remplacer par l'attribution des champs si un id existe dans Contact
                    contact.setUserId(rs.getLong("user_id"));
                    contact.setContactUserId(rs.getLong("contact_user_id"));
                    contact.setAddedAt(rs.getTimestamp("added_at").toLocalDateTime());
                    return contact;
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public boolean deleteContact(final long userId, final long contactId) {
        final String sql = "DELETE FROM contacts WHERE user_id = ? AND contact_user_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            stmt.setLong(2, contactId);
            final int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    public List<String> getContactsByUserId(final long userId) throws IOException {
        final List<String> contactEmails = new ArrayList<>();
        final String sql = "SELECT u.email FROM contacts c JOIN users u ON c.contact_user_id = u.id WHERE c.user_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    contactEmails.add(rs.getString("email"));
                }
            }
        } catch (final SQLException e) {
            throw new IOException("Erreur lors de la récupération des contacts", e);
        }
        return contactEmails;
    }
}



// File: src/main/java/org/example/shared/dao/GroupDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.model.Group;

public class GroupDAO {

    public void createGroup(final Group group) {
        // Mise à jour de la requête pour inclure profile_picture_url
        final String sql = "INSERT INTO `groups` (name, owner_user_id, created_at, profile_picture_url) VALUES (?,?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setString(1, group.getName());
            stmt.setLong(2, group.getOwnerUserId());
            stmt.setTimestamp(3, Timestamp.valueOf(group.getCreatedAt()));
            stmt.setString(4, group.getProfilePictureUrl());
            stmt.executeUpdate();
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    group.setId(generatedKeys.getLong(1));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public Group findGroupById(final long id) {
        final String sql = "SELECT * FROM `groups` WHERE id = ?";
        Group group = null;
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    group = new Group();
                    group.setId(rs.getLong("id"));
                    group.setName(rs.getString("name"));
                    group.setOwnerUserId(rs.getLong("owner_user_id"));
                    group.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
                    group.setProfilePictureUrl(rs.getString("profile_picture_url"));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return group;
    }

    /**
     * Récupère les identifiants des utilisateurs membres du groupe.
     */
    public List<Long> getMembersForGroup(final long groupId) {
        final List<Long> memberIds = new ArrayList<>();
        final String sql = "SELECT user_id FROM group_memberships WHERE group_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, groupId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    memberIds.add(rs.getLong("user_id"));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return memberIds;
    }

    /**
     * Récupère les groupes auxquels un utilisateur appartient.
     */
    public List<Group> getGroupsForUser(final long userId) {
        final List<Group> groups = new ArrayList<>();
        final String sql = "SELECT g.id, g.name, g.owner_user_id, g.created_at " +
                     "FROM `groups` g " +
                     "JOIN group_memberships gm ON g.id = gm.group_id " +
                     "WHERE gm.user_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    final Group group = new Group();
                    group.setId(rs.getLong("id"));
                    group.setName(rs.getString("name"));
                    group.setOwnerUserId(rs.getLong("owner_user_id"));
                    group.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
                    groups.add(group);
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return groups;
    }
}


// File: src/main/java/org/example/shared/dao/GroupMembershipDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;

import org.example.shared.model.GroupMembership;

public class GroupMembershipDAO {

    public void createGroupMembership(final GroupMembership membership) {
        final String sql = "INSERT INTO group_memberships (user_id, group_id, joined_at) VALUES (?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, membership.getUserId());
            stmt.setLong(2, membership.getGroupId());
            stmt.setTimestamp(3, Timestamp.valueOf(membership.getJoinedAt()));
            stmt.executeUpdate();
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public GroupMembership findGroupMembership(final long userId, final long groupId) {
        final String sql = "SELECT * FROM group_memberships WHERE user_id = ? AND group_id = ?";
        try (Connection conn = JDBCUtil.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, userId);
            stmt.setLong(2, groupId);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    final GroupMembership membership = new GroupMembership();
                    membership.setUserId(rs.getLong("user_id"));
                    membership.setGroupId(rs.getLong("group_id"));
                    membership.setJoinedAt(rs.getTimestamp("joined_at").toLocalDateTime());
                    return membership;
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }
}



// File: src/main/java/org/example/shared/dao/JDBCUtil.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class JDBCUtil {
    private static final String URL = "jdbc:mysql://localhost:3306/chat_db";
    private static final String USER = "root";
    private static final String PASSWORD = "password";

    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(URL, USER, PASSWORD);
    }
}



// File: src/main/java/org/example/shared/dao/MessageDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import org.example.shared.model.Message;
import org.example.shared.model.enums.MessageStatus;
import org.example.shared.model.enums.MessageType;

public class MessageDAO {

    public void createMessage(final Message message) {
        final String sql = "INSERT INTO messages (sender_user_id, receiver_user_id, group_id, content, timestamp, status, " + "message_type, file_name, file_size, mime_type) VALUES (?,?,?,?,?,?,?,?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setLong(1, message.getSenderUserId());
            if (message.getReceiverUserId() != null) {
                stmt.setLong(2, message.getReceiverUserId());
            } else {
                stmt.setNull(2, Types.BIGINT);
            }
            if (message.getGroupId() != null) {
                stmt.setLong(3, message.getGroupId());
            } else {
                stmt.setNull(3, Types.BIGINT);
            }
            stmt.setString(4, message.getContent());
            stmt.setTimestamp(5, Timestamp.valueOf(message.getTimestamp()));
            stmt.setString(6, message.getStatus().name());
            stmt.setString(7, message.getType().name());
            // Set multimedia fields
            if (message.getFileName() != null) {
                stmt.setString(8, message.getFileName());
            } else {
                stmt.setNull(8, Types.VARCHAR);
            }

            if (message.getFileSize() != null) {
                stmt.setLong(9, message.getFileSize());
            } else {
                stmt.setNull(9, Types.BIGINT);
            }

            if (message.getMimeType() != null) {
                stmt.setString(10, message.getMimeType());
            } else {
                stmt.setNull(10, Types.VARCHAR);
            }
            stmt.executeUpdate();
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    message.setId(generatedKeys.getLong(1));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public Message findMessageById(final long id) {
        final String sql = "SELECT * FROM messages WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return extractMessageFromResultSet(rs);
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<Message> getPendingMessagesForUser(final long receiverUserId) throws SQLException {
        final List<Message> messages = new ArrayList<>();
        // Récupérer les messages directs et les messages de groupe pour lesquels
        // l'utilisateur est membre
        final String sql = "SELECT * FROM messages " +
                "WHERE ((receiver_user_id = ? AND status = ?) " +
                "OR (group_id IS NOT NULL AND status = ? " +
                "    AND group_id IN (SELECT group_id FROM group_memberships WHERE user_id = ?)))";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, receiverUserId);
            stmt.setString(2, MessageStatus.QUEUED.name());
            stmt.setString(3, MessageStatus.QUEUED.name());
            stmt.setLong(4, receiverUserId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    messages.add(extractMessageFromResultSet(rs));
                }
            }
        }
        return messages;
    }

    public List<Message> getConversation(final long user1Id, final long user2Id) {
        final List<Message> messages = new ArrayList<>();
        final String sql = "SELECT * FROM messages WHERE " +
                " (sender_user_id = ? AND receiver_user_id = ?) OR (sender_user_id = ? AND receiver_user_id = ?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, user1Id);
            stmt.setLong(2, user2Id);
            stmt.setLong(3, user2Id);
            stmt.setLong(4, user1Id);

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    messages.add(extractMessageFromResultSet(rs));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return messages;
    }

    public boolean deleteMessage(final long messageId) throws SQLException {
        final String sql = "DELETE FROM messages WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, messageId);
            final int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        }
    }

    // Helper method to extract a Message from a ResultSet
    private Message extractMessageFromResultSet(final ResultSet rs) throws SQLException {
        final Message message = new Message();
        message.setId(rs.getLong("id"));
        message.setSenderUserId(rs.getLong("sender_user_id"));

        final long receiverUserId = rs.getLong("receiver_user_id");
        if (!rs.wasNull()) {
            message.setReceiverUserId(receiverUserId);
        }

        final long groupId = rs.getLong("group_id");
        if (!rs.wasNull()) {
            message.setGroupId(groupId);
        }

        message.setContent(rs.getString("content"));
        final Timestamp ts = rs.getTimestamp("timestamp");
        if (ts != null) {
            message.setTimestamp(ts.toLocalDateTime());
        }

        message.setStatus(MessageStatus.valueOf(rs.getString("status")));

        // Extract multimedia fields
        String messageTypeStr = rs.getString("message_type");
        if (messageTypeStr != null) {
            message.setType(MessageType.valueOf(messageTypeStr));
        } else {
            message.setType(MessageType.TEXT); // Default to TEXT for backward compatibility
        }

        message.setFileName(rs.getString("file_name"));

        final long fileSize = rs.getLong("file_size");
        if (!rs.wasNull()) {
            message.setFileSize(fileSize);
        }

        message.setMimeType(rs.getString("mime_type"));

        return message;
    }
}



// File: src/main/java/org/example/shared/dao/UserDAO.java
package org.example.shared.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;

import org.example.shared.model.User;

public class UserDAO {

    public void createUser(final User user) {
        final String sql = "INSERT INTO users (email, display_name, password_hash, is_online, created_at, last_login_at, profile_picture_url) VALUES (?,?,?,?,?,?,?)";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setString(1, user.getEmail());
            stmt.setString(2, user.getDisplayName());
            stmt.setString(3, user.getPasswordHash());
            stmt.setBoolean(4, user.isOnline());
            stmt.setTimestamp(5, Timestamp.valueOf(user.getCreatedAt()));
            stmt.setTimestamp(6, user.getLastLoginAt() != null ? Timestamp.valueOf(user.getLastLoginAt()) : null);
            stmt.setString(7, user.getProfilePictureUrl());

            stmt.executeUpdate();
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    user.setId(generatedKeys.getLong(1));
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public User findUserById(final long id) {
        final String sql = "SELECT * FROM users WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    final User user = new User();
                    user.setId(rs.getLong("id"));
                    user.setEmail(rs.getString("email"));
                    user.setDisplayName(rs.getString("display_name"));
                    user.setPasswordHash(rs.getString("password_hash"));
                    user.setOnline(rs.getBoolean("is_online"));
                    user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
                    final Timestamp ts = rs.getTimestamp("last_login_at");
                    if (ts != null) {
                        user.setLastLoginAt(ts.toLocalDateTime());
                    }
                    user.setProfilePictureUrl(rs.getString("profile_picture_url"));
                    return user;
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public User findUserByEmail(final String email) {
        final String sql = "SELECT * FROM users WHERE email = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, email);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    final User user = new User();
                    user.setId(rs.getLong("id"));
                    user.setEmail(rs.getString("email"));
                    user.setDisplayName(rs.getString("display_name"));
                    user.setPasswordHash(rs.getString("password_hash"));
                    user.setOnline(rs.getBoolean("is_online"));
                    user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
                    final Timestamp ts = rs.getTimestamp("last_login_at");
                    if (ts != null) {
                        user.setLastLoginAt(ts.toLocalDateTime());
                    }
                    user.setProfilePictureUrl(rs.getString("profile_picture_url"));
                    return user;
                }
            }
        } catch (final SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void updateUser(final User user) {
        final String sql = "UPDATE users SET email=?, display_name=?, password_hash=?, is_online=?, created_at=?, last_login_at=?, profile_picture_url=? WHERE id=?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, user.getEmail());
            stmt.setString(2, user.getDisplayName());
            stmt.setString(3, user.getPasswordHash());
            stmt.setBoolean(4, user.isOnline());
            stmt.setTimestamp(5, Timestamp.valueOf(user.getCreatedAt()));
            stmt.setTimestamp(6, user.getLastLoginAt() != null ? Timestamp.valueOf(user.getLastLoginAt()) : null);
            stmt.setString(7, user.getProfilePictureUrl());
            stmt.setLong(8, user.getId());
            stmt.executeUpdate();
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }

    public void deleteUser(final long id) {
        final String sql = "DELETE FROM users WHERE id = ?";
        try (Connection conn = JDBCUtil.getConnection();
                PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);
            stmt.executeUpdate();
        } catch (final SQLException e) {
            e.printStackTrace();
        }
    }
    
}



// File: src/main/java/org/example/shared/dto/Credentials.java
package org.example.shared.dto;

/**
 * Classe DTO pour les informations d'authentification.
 */
public class Credentials {
    private String email;
    private String password;
    
    // Constructeur par défaut requis pour Jackson
    public Credentials() {
    }
    
    public Credentials(final String email, final String password) {
        this.email = email;
        this.password = password;
    }
    
    // Getters et Setters
    public String getEmail() {
        return email;
    }
    
    public void setEmail(final String email) {
        this.email = email;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(final String password) {
        this.password = password;
    }
}


// File: src/main/java/org/example/shared/model/Contact.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;

public class Contact {

    private long userId;        // FK vers User.id (celui qui ajoute)
    private long contactUserId; // FK vers User.id (celui qui est ajouté)
    private LocalDateTime addedAt;

    // Constructeur par défaut
    public Contact() {
        this.addedAt = LocalDateTime.now();
    }

    // Constructeur principal
    public Contact(final long userId, final long contactUserId) {
        this();
        this.userId = userId;
        this.contactUserId = contactUserId;
    }

    // ...existing getters and setters...
    public long getUserId() { return userId; }
    public void setUserId(final long userId) { this.userId = userId; }
    public long getContactUserId() { return contactUserId; }
    public void setContactUserId(final long contactUserId) { this.contactUserId = contactUserId; }
    public LocalDateTime getAddedAt() { return addedAt; }
    public void setAddedAt(final LocalDateTime addedAt) { this.addedAt = addedAt; }

    // ...equals, hashCode, toString...
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final Contact contact = (Contact) o;
        return userId == contact.userId && contactUserId == contact.contactUserId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(userId, contactUserId);
    }

    @Override
    public String toString() {
        return "Contact{" + "userId=" + userId + ", contactUserId=" + contactUserId + ", addedAt=" + addedAt + '}';
    }
}



// File: src/main/java/org/example/shared/model/enums/MessageStatus.java
package org.example.shared.model.enums;

/**
 * Définit les statuts possibles d'un message.
 * 
 * Les statuts permettent de suivre l'état d'un message dans le système.
 */
public enum MessageStatus {
    SENT,       // Envoyé par le client, potentiellement en transit vers le destinataire/groupe
    DELIVERED,  // Confirmé comme reçu par le serveur/broker du destinataire (pas forcément lu)
    READ,       // Confirmé comme lu par le client destinataire (nécessite logique d'ACK)
    FAILED,     // Échec de l'envoi ou de la persistance
    QUEUED      // Mis en file d'attente car le destinataire était hors ligne
}



// File: src/main/java/org/example/shared/model/enums/MessageType.java
package org.example.shared.model.enums;

/**
 * Defines the types of messages that can be sent in the chat system.
 */
public enum MessageType {
    TEXT,       // Text message
    IMAGE,      // Image file (jpg, png, gif, etc.)
    VIDEO,      // Video file (mp4, mov, etc.)
    DOCUMENT,   // Document file (pdf, doc, xlsx, etc.)
    AUDIO       // Audio file (mp3, wav, etc.)
}


// File: src/main/java/org/example/shared/model/Group.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;

public class Group {

    private long id;
    private String name;
    private long ownerUserId; // FK vers User.id
    private LocalDateTime createdAt;
    private String profilePictureUrl; // Nouvelle propriété pour l'image

    // Constructeur par défaut
    public Group() {
        this.createdAt = LocalDateTime.now();
    }

    // Constructeur pour la création initiale
    public Group(final String name, final long ownerUserId) {
        this();
        this.name = name;
        this.ownerUserId = ownerUserId;
    }

    // ...existing getters and setters...
    public long getId() { return id; }
    public void setId(final long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(final String name) { this.name = name; }
    public long getOwnerUserId() { return ownerUserId; }
    public void setOwnerUserId(final long ownerUserId) { this.ownerUserId = ownerUserId; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(final LocalDateTime createdAt) { this.createdAt = createdAt; }

    public String getProfilePictureUrl() {
        return profilePictureUrl;
    }
    public void setProfilePictureUrl(final String profilePictureUrl) {
        this.profilePictureUrl = profilePictureUrl;
    }

    // ...equals, hashCode, toString...
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final Group group = (Group) o;
        return id > 0 && id == group.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "Group{" + "id=" + id + ", name='" + name + '\'' +
               ", ownerUserId=" + ownerUserId + '}';
    }
}



// File: src/main/java/org/example/shared/model/GroupMembership.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;

public class GroupMembership {

    private long userId;   // FK vers User.id
    private long groupId;  // FK vers Group.id
    private LocalDateTime joinedAt;

    // Constructeur par défaut
    public GroupMembership() {
        this.joinedAt = LocalDateTime.now();
    }

    // Constructeur principal
    public GroupMembership(final long userId, final long groupId) {
        this();
        this.userId = userId;
        this.groupId = groupId;
    }

    // ...existing getters and setters...
    public long getUserId() { return userId; }
    public void setUserId(final long userId) { this.userId = userId; }
    public long getGroupId() { return groupId; }
    public void setGroupId(final long groupId) { this.groupId = groupId; }
    public LocalDateTime getJoinedAt() { return joinedAt; }
    public void setJoinedAt(final LocalDateTime joinedAt) { this.joinedAt = joinedAt; }

    // ...equals, hashCode, toString...
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final GroupMembership that = (GroupMembership) o;
        return userId == that.userId && groupId == that.groupId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(userId, groupId);
    }

    @Override
    public String toString() {
        return "GroupMembership{" + "userId=" + userId + ", groupId=" + groupId + ", joinedAt=" + joinedAt + '}';
    }
}



// File: src/main/java/org/example/shared/model/Message.java
package org.example.shared.model;

import java.time.LocalDateTime;
import java.util.Objects;

import org.example.shared.model.enums.MessageStatus;
import org.example.shared.model.enums.MessageType;  // New import

import com.fasterxml.jackson.annotation.JsonIgnore;

public class Message {

    private long id;
    private long senderUserId;   // FK vers User.id
    private Long receiverUserId; // FK vers User.id (Nullable)
    private Long groupId;        // FK vers Group.id (Nullable)
    private String content;
    private LocalDateTime timestamp;
    private MessageStatus status; // Utilise l'Enum MessageStatus

    // New fields for multimedia support
    private MessageType type;    // Type of message (TEXT, IMAGE, VIDEO, DOCUMENT, AUDIO)
    private String fileName;     // Original file name
    private Long fileSize;       // Size of file in bytes
    private String mimeType;     // MIME type of the file


    // Constructeur par défaut
    public Message() {
        this.timestamp = LocalDateTime.now();
        this.status = MessageStatus.SENT;
        this.type = MessageType.TEXT;  // Default type is TEXT
    }

    // Méthode factory pour créer un message direct
    public static Message newDirectMessage(final long senderUserId, final long receiverUserId, final String content) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setReceiverUserId(receiverUserId);
        msg.setContent(content);
        return msg;
    }

    // Méthode factory pour créer un message de groupe
    public static Message newGroupMessage(final long senderUserId, final long groupId, final String content) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setGroupId(groupId);
        msg.setContent(content);
        return msg;
    }

    // New factory methods for media messages
    public static Message newDirectMediaMessage(final long senderUserId, final long receiverUserId,
                                                final String filePath, final MessageType type, final String fileName,
                                                final Long fileSize, final String mimeType) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setReceiverUserId(receiverUserId);
        msg.setContent(filePath);
        msg.setType(type);
        msg.setFileName(fileName);
        msg.setFileSize(fileSize);
        msg.setMimeType(mimeType);
        return msg;
    }

    public static Message newGroupMediaMessage(final long senderUserId, final long groupId,
                                               final String filePath, final MessageType type, final String fileName,
                                               final Long fileSize, final String mimeType) {
        final Message msg = new Message();
        msg.setSenderUserId(senderUserId);
        msg.setGroupId(groupId);
        msg.setContent(filePath);
        msg.setType(type);
        msg.setFileName(fileName);
        msg.setFileSize(fileSize);
        msg.setMimeType(mimeType);
        return msg;
    }





    public long getId() { return id; }
    public void setId(final long id) { this.id = id; }
    public long getSenderUserId() { return senderUserId; }
    public void setSenderUserId(final long senderUserId) { this.senderUserId = senderUserId; }
    public Long getReceiverUserId() { return receiverUserId; }
    public void setReceiverUserId(final Long receiverUserId) { this.receiverUserId = receiverUserId; }
    public Long getGroupId() { return groupId; }
    public void setGroupId(final Long groupId) { this.groupId = groupId; }
    public String getContent() { return content; }
    public void setContent(final String content) { this.content = content; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(final LocalDateTime timestamp) { this.timestamp = timestamp; }
    public MessageStatus getStatus() { return status; }
    public void setStatus(final MessageStatus status) { this.status = status; }

    // New getters and setters for multimedia
    public MessageType getType() { return type; }
    public void setType(final MessageType type) { this.type = type; }
    public String getFileName() { return fileName; }
    public void setFileName(final String fileName) { this.fileName = fileName; }
    public Long getFileSize() { return fileSize; }
    public void setFileSize(final Long fileSize) { this.fileSize = fileSize; }
    public String getMimeType() { return mimeType; }
    public void setMimeType(final String mimeType) { this.mimeType = mimeType; }




    @JsonIgnore
    public boolean isDirectMessage() {
        return receiverUserId != null && groupId == null;
    }

    @JsonIgnore
    public boolean isGroupMessage() {
        return groupId != null && receiverUserId == null;
    }

    @JsonIgnore
    public boolean isTextMessage() {
        return type == MessageType.TEXT;
    }

    @JsonIgnore
    public boolean isMediaMessage() {
        return type != MessageType.TEXT;
    }

    @JsonIgnore
    public boolean isImageMessage() {
        return type == MessageType.IMAGE;
    }

    @JsonIgnore
    public boolean isVideoMessage() {
        return type == MessageType.VIDEO;
    }

    @JsonIgnore
    public boolean isDocumentMessage() {
        return type == MessageType.DOCUMENT;
    }

    @JsonIgnore
    public boolean isAudioMessage() {
        return type == MessageType.AUDIO;
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final Message message = (Message) o;
        return id > 0 && id == message.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "Message{" + "id=" + id + ", senderUserId=" + senderUserId +
               (isDirectMessage() ? ", receiverUserId=" + receiverUserId : "") +
               (isGroupMessage() ? ", groupId=" + groupId : "") +
               ", status=" + status + ", timestamp=" + timestamp + '}';
    }
}



// File: src/main/java/org/example/shared/model/User.java
package org.example.shared.model;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Objects;

public class User implements Serializable {
    private static final long serialVersionUID = 1L;

    private long id;
    private String email; // Unique
    private String displayName;
    private String passwordHash; // Important: C'est un HASH !
    private boolean isOnline;
    private LocalDateTime createdAt;
    private LocalDateTime lastLoginAt; // Peut être null
    private String profilePictureUrl; // URL de l'image de profil
    private String status;

    // Constructeur par défaut
    public User() {
        this.createdAt = LocalDateTime.now();
        this.isOnline = false;
        this.profilePictureUrl = "default_avatar.png"; // Image par défaut
    }

    // Constructeur pour la création initiale (avant sauvegarde)
    public User(final String email, final String displayName, final String passwordHash) {
        this();
        this.email = email;
        this.displayName = displayName;
        this.passwordHash = passwordHash;
    }

    public long getId() { return id; }
    public void setId(final long id) { this.id = id; }
    public String getEmail() { return email; }
    public void setEmail(final String email) { this.email = email; }
    public String getDisplayName() { return displayName; }
    public void setDisplayName(final String displayName) { this.displayName = displayName; }
    public String getPasswordHash() { return passwordHash; }
    public void setPasswordHash(final String passwordHash) { this.passwordHash = passwordHash; }
    public boolean isOnline() { return isOnline; }
    public void setOnline(final boolean online) { isOnline = online; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(final LocalDateTime createdAt) { this.createdAt = createdAt; }
    public LocalDateTime getLastLoginAt() { return lastLoginAt; }
    public void setLastLoginAt(final LocalDateTime lastLoginAt) { this.lastLoginAt = lastLoginAt; }
    public String getProfilePictureUrl() { 
        return profilePictureUrl; 
    }
    public void setProfilePictureUrl(final String profilePictureUrl) { 
        this.profilePictureUrl = profilePictureUrl; 
    }
    public String getStatus() { return status; }
    public void setStatus(final String status) { this.status = status; }

    /**
     * Retourne le nom d'affichage si disponible, sinon l'email
     */
    public String getDisplayNameOrEmail() {
        return displayName != null && !displayName.isEmpty() ? displayName : email;
    }

    /**
     * Retourne l'URL de l'avatar ou une image par défaut
     */
    public String getAvatarUrl() {
        return profilePictureUrl != null && !profilePictureUrl.isEmpty() ? 
               profilePictureUrl : "/images/default_avatar.png";
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final User user = (User) o;
        if (id > 0 && user.id > 0) return id == user.id;
        return Objects.equals(email, user.email);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id > 0 ? id : email);
    }

    @Override
    public String toString() {
        return "User{" + "id=" + id + ", email='" + email + '\'' + ", displayName='" + displayName + '\'' + '}';
    }
}



// File: src/main/resources/fxml/chat.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.client.gui.controllers.ChatController"
            prefHeight="600.0" prefWidth="800.0">

    <stylesheets>
        <URL value="@../css/chat.css"/>
    </stylesheets>

    <top>
        <HBox alignment="CENTER_LEFT" spacing="10" styleClass="header">
            <Label text="Chat Application" styleClass="header-text"/>
            <Button fx:id="mediaGalleryButton" text="🖼️ Galerie Média" styleClass="media-gallery-button"/>
            <Region HBox.hgrow="ALWAYS"/>
            <Label fx:id="userEmailLabel" styleClass="header-text"/>
            <Button text="Déconnexion" onAction="#handleLogout"/>
        </HBox>
    </top>

    <left>
        <VBox spacing="5" prefWidth="250">
            <padding>
                <Insets top="5" right="5" bottom="5" left="5"/>
            </padding>

            <Label text="Contacts" style="-fx-font-weight: bold;"/>
            <HBox spacing="5">
                <TextField fx:id="newContactField" promptText="Ajouter un contact" HBox.hgrow="ALWAYS"/>
                <Button text="+" onAction="#handleAddContact"/>
                <Button text="-" onAction="#handleRemoveContact"/>
            </HBox>
            <ListView fx:id="contactListView" VBox.vgrow="ALWAYS" styleClass="contact-list">
                <placeholder>
                    <Label text="Aucun contact"/>
                </placeholder>
            </ListView>

            <Separator>
                <padding>
                    <Insets top="10" bottom="10"/>
                </padding>
            </Separator>

            <Label text="Groupes" style="-fx-font-weight: bold;"/>
            <HBox spacing="5">
                <TextField fx:id="groupNameField" promptText="Nom du groupe" HBox.hgrow="ALWAYS"/>
                <Button text="+" onAction="#handleCreateGroup"/>
            </HBox>
            <ListView fx:id="groupListView" VBox.vgrow="ALWAYS" styleClass="group-list">
                <placeholder>
                    <Label text="Aucun groupe"/>
                </placeholder>
            </ListView>
            <HBox spacing="5">
                <TextField fx:id="memberEmailField" promptText="Ajouter un membre" HBox.hgrow="ALWAYS"/>
                <Button text="+" onAction="#handleAddMemberToGroup"/>
            </HBox>
        </VBox>
    </left>

    <center>
        <BorderPane>
            <center>
                <ScrollPane fx:id="chatScrollPane" fitToWidth="true">
                    <VBox fx:id="chatHistoryContainer" spacing="5" styleClass="chat-history"/>
                </ScrollPane>
            </center>
            <bottom>
                <VBox spacing="5">
                    <!-- Media attachment indicator -->
                    <HBox fx:id="attachmentPreviewContainer" spacing="5" alignment="CENTER_LEFT" styleClass="attachment-preview" managed="false" visible="false">
                        <Label fx:id="attachmentNameLabel" styleClass="attachment-name"/>
                        <Region HBox.hgrow="ALWAYS"/>
                        <Button text="×" onAction="#handleRemoveAttachment" styleClass="remove-attachment-button"/>
                    </HBox>

                    <!-- Recording indicator -->
                    <HBox fx:id="recordingIndicatorContainer" spacing="5" alignment="CENTER_LEFT" styleClass="recording-indicator" managed="false" visible="false">
                        <Label text="⚫ Enregistrement en cours..." styleClass="recording-label"/>
                        <Region HBox.hgrow="ALWAYS"/>
                        <Label fx:id="recordingTimeLabel" text="00:00" styleClass="recording-time"/>
                    </HBox>

                    <!-- Message input area -->
                    <HBox spacing="5" alignment="CENTER_LEFT" style="-fx-padding: 10px;">
                        <!-- Media attachment button -->
                        <Button fx:id="mediaButton" text="Media" styleClass="media-button" onAction="#handleMediaButtonClick"/>

                        <!-- Audio recording button -->
                        <Button fx:id="audioRecordButton" text="Audio" styleClass="record-button" onAction="#handleAudioRecordButtonClick"/>

                        <!-- Message text field -->
                        <TextField fx:id="messageField" promptText="Écrire un message..." HBox.hgrow="ALWAYS"/>

                        <!-- Send button -->
                        <Button text="Envoyer" styleClass="send-button" onAction="#handleSendMessage"/>
                    </HBox>
                </VBox>
            </bottom>
            <top>
                <HBox alignment="CENTER_LEFT" style="-fx-background-color: #f5f5f5; -fx-padding: 10px;">
                    <Label fx:id="statusLabel" styleClass="status-label"/>
                </HBox>
            </top>
        </BorderPane>
    </center>
</BorderPane>


// File: src/main/resources/fxml/login.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.PasswordField?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<BorderPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="400.0" minWidth="600.0"
    prefHeight="400.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/17"
    xmlns:fx="http://javafx.com/fxml/1" fx:controller="org.example.client.gui.controllers.LoginController">
    <center>
        <VBox alignment="CENTER" maxWidth="400.0" spacing="15.0" BorderPane.alignment="CENTER">
            <children>
                <Label text="Chat Application" textAlignment="CENTER">
                    <font>
                        <Font name="System Bold" size="24.0" />
                    </font>
                </Label>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Email" />
                        <TextField fx:id="emailField" promptText="Entrez votre email" />
                    </children>
                </VBox>
                <VBox spacing="5.0">
                    <children>
                        <Label text="Mot de passe" />
                        <PasswordField fx:id="passwordField" promptText="Entrez votre mot de passe" />
                    </children>
                </VBox>
                <Button fx:id="loginButton" defaultButton="true" maxWidth="1.7976931348623157E308"
                    mnemonicParsing="false" onAction="#handleLogin" text="Se connecter">
                    <VBox.margin>
                        <Insets top="10.0" />
                    </VBox.margin>
                </Button>
            </children>
            <BorderPane.margin>
                <Insets left="20.0" right="20.0" />
            </BorderPane.margin>
            <padding>
                <Insets bottom="20.0" left="20.0" right="20.0" top="20.0" />
            </padding>
        </VBox>
    </center>
    <bottom>
        <HBox alignment="CENTER" prefHeight="50.0" spacing="10.0" BorderPane.alignment="CENTER">
            <children>
                <Label text="© 2025 Chat Application" textFill="#686868" />
            </children>
        </HBox>
    </bottom>
</BorderPane>


// File: src/main/resources/fxml/media_dialog.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.Text?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.client.gui.controllers.MediaDialogController"
            prefWidth="500.0" prefHeight="400.0">

    <top>
        <HBox alignment="CENTER" spacing="10" style="-fx-background-color: #4caf50; -fx-padding: 10px;">
            <Label text="Envoyer un média" style="-fx-text-fill: white; -fx-font-size: 16px;"/>
        </HBox>
    </top>

    <center>
        <VBox spacing="15" style="-fx-padding: 20px;">
            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Type de média:" />
                <ComboBox fx:id="mediaTypeComboBox" promptText="Choisir type de média" prefWidth="200"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Fichier:" />
                <TextField fx:id="filePathField" editable="false" HBox.hgrow="ALWAYS" />
                <Button text="Parcourir..." onAction="#handleBrowseFile" />
            </HBox>

            <VBox fx:id="previewContainer" VBox.vgrow="ALWAYS" spacing="10" style="-fx-padding: 10px; -fx-border-color: #ddd; -fx-border-radius: 5px;">
                <Text text="Aperçu du média sera affiché ici" style="-fx-fill: #999;"/>
            </VBox>

            <HBox fx:id="recordAudioContainer" spacing="10" alignment="CENTER_LEFT" visible="false" managed="false">
                <Button fx:id="recordButton" text="🎤 Enregistrer" onAction="#handleRecordAudio" />
                <Label fx:id="recordingTimeLabel" text="00:00" />
                <Region HBox.hgrow="ALWAYS" />
                <ProgressBar fx:id="audioLevelIndicator" progress="0" prefWidth="100" />
            </HBox>
        </VBox>
    </center>

    <bottom>
        <HBox alignment="CENTER_RIGHT" spacing="10" style="-fx-padding: 10px; -fx-background-color: #f5f5f5;">
            <Button text="Annuler" onAction="#handleCancel" style="-fx-padding: 5px 15px;" />
            <Button fx:id="sendButton" text="Envoyer" onAction="#handleSend" style="-fx-padding: 5px 15px; -fx-background-color: #4caf50; -fx-text-fill: white;" />
        </HBox>
    </bottom>

</BorderPane>


// File: src/main/resources/fxml/media_gallery.fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.client.gui.controllers.MediaGalleryController"
            prefWidth="800.0" prefHeight="600.0">

    <top>
        <HBox alignment="CENTER_LEFT" spacing="10" style="-fx-background-color: #4caf50; -fx-padding: 10px;">
            <Label fx:id="titleLabel" text="Galerie média"
                   style="-fx-text-fill: white; -fx-font-size: 18px;"/>
            <Region HBox.hgrow="ALWAYS"/>
            <ComboBox fx:id="mediaTypeFilter" prefWidth="150"/>
        </HBox>
    </top>

    <center>
        <ScrollPane fitToWidth="true" fitToHeight="true">
            <FlowPane fx:id="mediaContainer" hgap="10" vgap="10" prefWrapLength="700">
                <padding>
                    <Insets top="10" right="10" bottom="10" left="10"/>
                </padding>
            </FlowPane>
        </ScrollPane>
    </center>

    <bottom>
        <HBox alignment="CENTER_RIGHT" spacing="10" style="-fx-padding: 10px; -fx-background-color: #f5f5f5;">
            <Label fx:id="statsLabel" text="Total: 0 médias"/>
            <Region HBox.hgrow="ALWAYS"/>
            <Button text="Fermer" onAction="#handleClose"
                    style="-fx-padding: 5px 15px;"/>
        </HBox>
    </bottom>

</BorderPane>


